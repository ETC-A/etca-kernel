0xffff8000:                               # .set STREAM 1
0xffff8000:                               # .set MODEQ 2
0xffff8000:                               # .set OUTPUT 3
0xffff8000:                               # .set SRCLINENO_OFS       -12
0xffff8000:                               # .set SYMTAB_HEAD_OFS     -8
0xffff8000:                               # .set RELOC_TAB_HEAD_OFS  -4
0xffff8000:                               # .set HEAP_LIMIT_OFS       4
0xffff8000:                               # .set EOL_CHAR_OFS         8
0xffff8000:                               # .set STATIC_DATA_PTR    0x8000000C
0xffff8000:                               # .set INIT_HEAP_LIMIT    0x80000018
0xffff8000:                               # .set INIT_STK_PTR       0xA0000000
0xffff8000:                               # .set INIT_OBJ_STK_PTR   0x20000000
0xffff8000:                               # .set RT_BUFFER_PTR      0x80000014   ; runtime buffer for itoa/utoa &c
0xffff8000:                               # .set BUFFER_PTR         0x00000020   ; small buffer for reading opcodes/registers etc
0xffff8000:                               # .set CODE_SEGMENT       0x00000030   ; we still use 0x20-0x30 as a buffer for non read_name lexing
0xffff8000: b0 5c                         #             call    _start
0xffff8002:                               # object_return_stub:
0xffff8002: 59 00                         #             mov     %r0, 0                  ; SYSCALL_EXIT
0xffff8004: 59 20                         #             mov     %r1, 0                  ; STATUS_OK
0xffff8006:                               # syscall:
0xffff8006: 43 04                         #             cmph    %r0, 4                  ; biggest known syscall is 4.
0xffff8008: 88 0a                         #             jbe     good_service_no         ; service <= 4? if yes, keep going. Otherwise, exit 140
0xffff800a: 59 00                         #             mov     %r0, 0
0xffff800c: 58 24 5c 2c                   #             mov     %r1, 140                ; exit code 140, SIGSYS
0xffff8010: 9e f6                         #             jmp     syscall
0xffff8012:                               # good_service_no:
0xffff8012: 57 c3                         #             testx   %sp, 3                  ; test the bottom 2 stack bits. The ABI requires that these
0xffff8014: 80 0c                         #             jz      aligned_stack           ; crash the program with code 139 (segfault) if it's on
0xffff8016: 66 de                         #             andd    %sp, -2                 ; align the stack so that we don't weirdloop
0xffff8018: 59 00                         #             mov     %r0, 0
0xffff801a: 58 24 5c 2b                   #             mov     %r1, 139
0xffff801e: 9e e8                         #             jmp syscall
0xffff8020:                               # aligned_stack:
0xffff8020: 2d dc                         #             pushd   %ln                     ; the stack is now guaranteed to be aligned. Save %ln.
0xffff8022: 60 c4                         #             addd    %sp, 4                  ; But without pushing, so that we save the right %sp.
0xffff8024: 69 fe 6c e0 6c e0 6c e0 6c e0 6c e0 6c e0#             mov     %ln, 0x80000000         ; &static_data->user_sp
0xffff8032: 2b dc                         #             std     %sp, %ln                ; static_data->user_sp = %sp
0xffff8034: 61 c4                         #             subd    %sp, 4                  ; go back to where we put our return address
0xffff8036: 2c f8                         #             popd    %ln                     ; restore our return address
0xffff8038: 69 de 6c d0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %sp, INIT_STK_PTR       ; initialize our own stack
0xffff8046: 2d dc                         #             pushd   %ln                     ; and save our return address there.
0xffff8048: b0 0c                         #             call    syscall_with_table      ; get the syscall table
0xffff804a: 48 8d                         #             .word   syscall_exit    &0xFFFF
0xffff804c: 86 8d                         #             .word   syscall_putuint &0xFFFF
0xffff804e: 86 8d                         #             .word   syscall_putsint &0xFFFF
0xffff8050: b4 8d                         #             .word   syscall_puts    &0xFFFF
0xffff8052: ba 8d                         #             .word   syscall_sbrk    &0xFFFF
0xffff8054:                               # syscall_with_table:
0xffff8054: 00 00                         #             addh    %r0, %r0                ; service_no *= sizeof(word)
0xffff8056: 20 e0                         #             addd    %ln, %r0                ; offset into the syscall table
0xffff8058: 1a fc                         #             ldx     %ln, %ln                ; load the system function to call, ldx will sign extend
0xffff805a: af ee                         #             jmp     %ln                     ; invoke it
0xffff805c:                               # _start:
0xffff805c: 5e 00                         #             mov     %r0, %cpuid1            ; get cpuid1 to check for 32-bit operations
0xffff805e: 58 30 5c 20 5c 20             #             mov     %r1, 0x4000             ; 32-bit operations
0xffff8064: 17 04                         #             testx   %r0, %r1
0xffff8066: 80 1a                         #             jz      missing_feature
0xffff8068: 6e 00                         #             movd    %r0, %cpuid1            ; get cpuid1 to check for S&F,8b,32b,32p
0xffff806a: 68 22 6c 30 6c 20 6c 2a       #             mov     %r1, 0x1400A            ; S&F,8b,32b,32p
0xffff8072: 26 04                         #             andd    %r0, %r1
0xffff8074: 23 04                         #             cmpd    %r0, %r1
0xffff8076: 81 0a                         #             jne     missing_feature
0xffff8078: 5e 02                         #             mov     %r0, %feat              ; get features to check for VN
0xffff807a: 57 01                         #             testx   %r0, 1                  ; VN
0xffff807c: 80 04                         #             jz      missing_feature
0xffff807e: 8e 04                         #             jmp     good_features
0xffff8080:                               # missing_feature:
0xffff8080: b6 18                         #             call    die_missing_feature
0xffff8082:                               # good_features:
0xffff8082: 59 02                         #             mov     %r0, 2                  ; 32-bit address mode
0xffff8084: 5f 11                         #             mov     %mode, %r0
0xffff8086: 69 be 6c a0 6c a0 6c a0 6c a0 6c a0 6c ac#             mov     %r5, STATIC_DATA_PTR
0xffff8094: 69 de 6c d0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %r6, INIT_STK_PTR
0xffff80a2: 29 14                         #             movd    %r0, %r5
0xffff80a4: 60 0c                         #             addd    %r0, 12                 ; INIT_HEAP_LIMIT is STATIC_DATA_PTR+12
0xffff80a6: 29 34                         #             movd    %r1, %r5
0xffff80a8: 60 24                         #             addd    %r1, HEAP_LIMIT_OFS     ; &static_data.heap_limit
0xffff80aa: 2b 04                         #             std     %r0, %r1                ; static_data->heap_limit = INIT_HEAP_LIMIT
0xffff80ac: 61 24                         #             subd    %r1, 4                  ; &static_data.asm_ip
0xffff80ae: 58 01 5c 10                   #             mov     %r0, CODE_SEGMENT       ; initial code segment ip
0xffff80b2: 2b 04                         #             std     %r0, %r1                ; static_data->asm_ip = CODE_SEGMENT
0xffff80b4: 61 24                         #             subd    %r1, 4                  ; &static_data.reloc_table_head
0xffff80b6: 59 00                         #             mov     %r0, 0                  ; NULL
0xffff80b8: 2b 04                         #             std     %r0, %r1                ; static_data->reloc_table_head = NULL
0xffff80ba: 61 24                         #             subd    %r1, 4                  ; &static_data.symtab_head
0xffff80bc: 2b 04                         #             std     %r0, %r1                ; static_data->symtab_head = NULL
0xffff80be: 61 24                         #             subd    %r1, 4                  ; &static_data.src_lineno
0xffff80c0: 59 01                         #             mov     %r0, 1                  ; initial line is line 1
0xffff80c2: 1b 04                         #             stx     %r0, %r1                ; static_data->src_lineno = 1
0xffff80c4: b1 06                         #             call    assemble_fp
0xffff80c6: b1 20                         #             call    assemble_sp
0xffff80c8: b0 0c                         #             call    get_start_stub
0xffff80ca: 00 00                         # 
0xffff80cc: 5f 73 74 61 72 74 00          #             .asciiz "_start"
0xffff80d3: 00                            # 
0xffff80d4:                               # get_start_stub:
0xffff80d4: 60 e3                         #             addd    %ln, 3
0xffff80d6: 66 fc                         #             andd    %ln, -4                 ; dword align %ln to get to the string
0xffff80d8: 29 1c                         #             movd    %r0, %ln                ; arg 0 = "_start"
0xffff80da: b0 6c                         #             call    find_table_entry        ; find (or create, boo) a table entry for "_start"
0xffff80dc: b1 be                         #             call    sp_get_symbol           ; xlookup the address for _start
0xffff80de: 2d c0                         #             pushd   %r0                     ; stash that while we clean up
0xffff80e0: 69 1f 6c 03 6c 12 6c 10       #             mov     %r0, completed_assembly_msg
0xffff80e8: 69 ff 6c e3 6c ea 6c e0       #             mov     %ln, puts
0xffff80f0: af fe                         #             call    %ln                     ; inform the user that their program is starting soon
0xffff80f2: 69 ff 6c e0 6c e0 6c e2       #             mov     %ln, object_return_stub
0xffff80fa: 59 04                         #             mov     %r0, 4                  ; syscall - object return stub
0xffff80fc: 20 1c                         #             addd    %r0, %ln                ; r0 = syscall
0xffff80fe: 2c 38                         #             popd    %r1                     ; reload address of _start to prepare transfer of control
0xffff8100: 68 d0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %sp, INIT_OBJ_STK_PTR   ; initialize the object program stack pointer
0xffff810c: 59 40                         #             mov     %r2, 0
0xffff810e: 59 60                         #             mov     %r3, 0
0xffff8110: 59 80                         #             mov     %r4, 0
0xffff8112: 59 a0                         #             mov     %r5, 0
0xffff8114: af 2e                         #             jmp     %r1                     ; give control to the object program!
0xffff8116:                               # shr5:
0xffff8116: 2d c8                         #             pushd   %r2      ; having separated vaneers like this is fewer instructions
0xffff8118: 58 50                         #             movzx   %r2, 16  ; I have optimized for the placement of shr4 here.
0xffff811a: 10 48                         #             addx    %r2, %r2        ; 16 + 16 = 32
0xffff811c: 8e 06                         #             jmp     shr_L1
0xffff811e:                               # shr4:
0xffff811e: 2d c8                         #             pushd   %r2
0xffff8120: 58 50                         #             movzx   %r2, 16
0xffff8122:                               # shr_L1:
0xffff8122: 2d cc                         #             pushd   %r3
0xffff8124: 29 60                         #             movd    %r3, %r0        ; move x to r3
0xffff8126: 2d d0                         #             pushd   %r4
0xffff8128: 59 81                         #             mov     %r4, 1          ; b = 1
0xffff812a: 59 00                         #             mov     %r0, 0          ; clear r0 (it holds 'r')
0xffff812c:                               # shr_L2:                             ; top of shr loop
0xffff812c: 27 4c                         #             testd   %r2, %r3        ; test mask & x
0xffff812e: 80 04                         #             jz      shr_L3          ; don't set bit of r if !(mask & x)
0xffff8130: 24 10                         #             ord     %r0, %r4        ; r |= b if mask & x, shifts that bit over
0xffff8132:                               # shr_L3:
0xffff8132: 20 48                         #             addd    %r2, %r2        ; mask <<= 1
0xffff8134: 23 4c                         #             cmpd    %r2, %r3        ; mask >? x
0xffff8136: 89 08                         #             ja      shr_L4          ; if yes, further testds will fail and we can quit.
0xffff8138: 20 90                         #             addd    %r4, %r4        ; b <<= 1
0xffff813a: 41 21                         #             subh    %r1, 1          ; --width
0xffff813c: 91 f0                         #             jnz     shr_L2          ; loop if width != 0
0xffff813e:                               # shr_L4:
0xffff813e: 2c 98                         #             popd    %r4             ; now r0 has the result
0xffff8140: 2c 78                         #             popd    %r3             ; so we can unwind
0xffff8142: 2c 58                         #             popd    %r2
0xffff8144: af ee                         #             ret
0xffff8146:                               # find_table_entry:
0xffff8146: 2d dc                         #             pushd   %ln                 ; prologue, we call other functions
0xffff8148: 29 74                         #             movd    %r3, %r5            ; copy &static_data
0xffff814a: 60 78                         #             addd    %r3, SYMTAB_HEAD_OFS; re = &static_data.symtab_head
0xffff814c: 2a 2c                         #             ldd     %r1, %r3            ; r1 = static_data->symtab_head
0xffff814e: 8e 20                         #             jmp     find_table_entry_check
0xffff8150:                               # find_table_entry_loop:                  ; loop top
0xffff8150: 2d c0                         #             pushd   %r0                 ; save name
0xffff8152: 2d c4                         #             pushd   %r1                 ; save ste
0xffff8154: 60 28                         #             addd    %r1, 8              ; &ste->symbol
0xffff8156: 59 5f                         #             mov     %r2, -1             ; uint32_t_MAX
0xffff8158: b5 48                         #             call    strncmp             ; r0 = !(name `streq` ste->symbol)
0xffff815a: 57 1f                         #             test    %r0, -1             ; set Z if the strings were equal
0xffff815c: 81 0a                         #             jnz     find_table_entry_L2 ; skip return if we missed
0xffff815e: 2c 18                         #             popd    %r0                 ; restore ste to r0
0xffff8160: 60 c4                         #             addd    %sp, 4              ; pop name
0xffff8162: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8164: af ee                         #             ret
0xffff8166:                               # find_table_entry_L2:
0xffff8166: 2c 38                         #             popd    %r1                 ; restore ste to r1
0xffff8168: 2c 18                         #             popd    %r0                 ; restore name to r0
0xffff816a: 2a 24                         #             ldd     %r1, %r1            ; ste = ste->next
0xffff816c: 66 3e                         #             andd    %r1, -2             ; untag the pointer
0xffff816e:                               # find_table_entry_check:
0xffff816e: 67 3f                         #             testd   %r1, -1             ; is the pointer null?
0xffff8170: 91 e0                         #             jnz     find_table_entry_loop ; if not, loop
0xffff8172: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8174:                               # add_table_entry:
0xffff8174: 29 54                         #             movd    %r2, %r5            ; char *ptr = &static_data
0xffff8176: 60 44                         #             addd    %r2, HEAP_LIMIT_OFS ; ptr = &static_data.heap_limit
0xffff8178: 2a 48                         #             ldd     %r2, %r2            ; ptr = static_data->heap_limit
0xffff817a: 29 68                         #             movd    %r3, %r2            ; te = ptr
0xffff817c: 60 48                         #             addd    %r2, 8              ; ptr += offsetof(table_entry_t, symbol)
0xffff817e: 23 08                         #             cmpd    %r0, %r2            ; compare ptr to name
0xffff8180: 80 12                         #             je      add_table_entry_NCL ; jump to non-copying loop if not equal
0xffff8182:                               # add_table_entry_CL:                     ; otherwise fall through to copying loop
0xffff8182: 2a 20                         #             ldd     %r1, %r0            ; temp = *name, 32-bit transfer
0xffff8184: 2b 28                         #             std     %r1, %r2            ; *ptr = *name, 32-bit transfer
0xffff8186: 60 04                         #             addd    %r0, 4              ; name += 4
0xffff8188: 60 44                         #             addd    %r2, 4              ; ptr  += 4
0xffff818a: 0a 20                         #             ldh     %r1, %r0            ; temp = *name again
0xffff818c: 47 3f                         #             testh   %r1, -1             ; is *name zero?
0xffff818e: 91 f4                         #             jnz     add_table_entry_CL  ; if not, loop
0xffff8190: 8e 0a                         #             jmp     add_table_entry_done; otherwise go after the loops
0xffff8192:                               # add_table_entry_NCL:
0xffff8192: 60 44                         #             addd    %r2, 4              ; ptr  += 4
0xffff8194: 0a 28                         #             ldh     %r1, %r2            ; temp = *ptr
0xffff8196: 47 3f                         #             testh   %r1, -1             ; is *ptr zero?
0xffff8198: 91 fa                         #             jnz     add_table_entry_NCL ; if not, loop
0xffff819a:                               # add_table_entry_done:
0xffff819a: 60 44                         #             addd    %r2, 4              ; ptr += 4
0xffff819c: 29 34                         #             movd    %r1, %r5            ; copy &static_data
0xffff819e: 60 24                         #             addd    %r1, HEAP_LIMIT_OFS ; &static_data.heap_limit
0xffff81a0: 2b 44                         #             std     %r2, %r1            ; static_data->heap_limit = ptr
0xffff81a2: 60 34                         #             addd    %r1, -12            ; &static_data.symtab_head
0xffff81a4: 2a 04                         #             ldd     %r0, %r1            ; r0 = static_data->symtab_head
0xffff81a6: 2b 0c                         #             std     %r0, %r3            ; copy symtab_head to te->next
0xffff81a8: 2b 64                         #             std     %r3, %r1            ; static_data->symtab_head = te
0xffff81aa: 29 0c                         #             movd    %r0, %r3            ; copy te to return register
0xffff81ac: af ee                         #             ret
0xffff81ae:                               # ste_attach_payload:
0xffff81ae: 2d dc                         #             pushd   %ln                 ; save return address
0xffff81b0: 2d c4                         #             pushd   %r1                 ; save payload
0xffff81b2: bf 94                         #             call    find_table_entry    ; r0 = entry for 'name'
0xffff81b4: 2a 20                         #             ldd     %r1, %r0            ; r1 = entry->next
0xffff81b6: 64 21                         #             ord     %r1, 1              ; tag the entry as valid
0xffff81b8: 2b 20                         #             std     %r1, %r0            ; entry->next = tagged pointer
0xffff81ba: 60 04                         #             addd    %r0, 4              ; r0 = &entry.payload
0xffff81bc: 2c 38                         #             popd    %r1                 ; r1 = payload
0xffff81be: 2b 20                         #             std     %r1, %r0            ; entry->payload = payload
0xffff81c0: 2c f8                         #             popd    %ln
0xffff81c2: af ee                         #             ret
0xffff81c4:                               # ste_get_payload:
0xffff81c4: 60 04                         #             addd    %r0, 4
0xffff81c6: 2a 00                         #             ldd     %r0, %r0            ; entry->payload
0xffff81c8: af ee                         #             ret
0xffff81ca:                               # assemble_fp:
0xffff81ca: 2d dc                         #             pushd   %ln
0xffff81cc:                               # assemble_fp_L1:
0xffff81cc: b2 c8                         #             call    fpsm
0xffff81ce: 29 14                         #             movd    %r0, %bp            ; r0 = &static_data
0xffff81d0: 60 14                         #             addd    %r0, SRCLINENO_OFS  ; r0 = &static_data.src_lineno
0xffff81d2: 1a 20                         #             ldx     %r1, %r0            ; r1 = static_data->src_lineno
0xffff81d4: 50 21                         #             addx    %r1, 1
0xffff81d6: 1b 20                         #             stx     %r1, %r0            ; static_data->src_lineno++
0xffff81d8: 29 14                         #             movd    %r0, %bp            ; r0 = &static_data again
0xffff81da: 60 08                         #             addd    %r0, EOL_CHAR_OFS   ; ro = &static_data.eol_char
0xffff81dc: 0a 00                         #             ldh     %r0, %r0            ; r0 = static_data->eol_char
0xffff81de: 47 1f                         #             testh   %r0, -1             ; test the char
0xffff81e0: 91 ec                         #             jnz     assemble_fp_L1      ; loop if it's not \NUL
0xffff81e2: 2c f8                         #             popd    %ln                 ; if it's \NUL, we're done.
0xffff81e4: af ee                         #             ret
0xffff81e6:                               # assemble_sp:
0xffff81e6: 2d dc                         #             pushd   %ln
0xffff81e8: 2a 14                         #             ldd     %r0, %bp            ; r0 = static_data->asm_ip
0xffff81ea: 2d c0                         #             pushd   %r0                 ; save ip at end of program
0xffff81ec: 59 14                         #             mov     %r0, SRCLINENO_OFS
0xffff81ee: 20 14                         #             addd    %r0, %bp            ; r0 = &static_data.src_lineno
0xffff81f0: 1a 00                         #             ldx     %r0, %r0            ; r0 = static_data->src_lineno
0xffff81f2: 2d c0                         #             pushd   %r0                 ; save final lineno, in case can't find _start
0xffff81f4: 59 1c                         #             mov     %r0, RELOC_TAB_HEAD_OFS
0xffff81f6: 20 14                         #             addd    %r0, %bp            ; r0 = &static_data.reloc_tab_head
0xffff81f8: 2a 40                         #             ldd     %r2, %r0            ; r2 = reloc_entry = static_data->reloc_tab_head
0xffff81fa: 67 5f                         #             testd   %r2, -1             ; test the pointer to see if it's null
0xffff81fc: 80 22                         #             jz      assemble_sp_L2      ; skip the loop entirely if so
0xffff81fe:                               # assemble_sp_L1:
0xffff81fe: 2d c8                         #             pushd   %r2                 ; save original value of reloc_entry
0xffff8200: 2a 28                         #             ldd     %r1, %r2            ; r1 = arg 1 = reloc_entry->asm_ip
0xffff8202: 2b 34                         #             std     %r1, %bp            ; static_data->asm_ip = reloc_entry->asm_ip
0xffff8204: 60 4c                         #             addd    %r2, 12             ; &reloc_entry.src_lineno
0xffff8206: 1a 08                         #             ldx     %r0, %r2            ; r0 = reloc_entry->src_lineno
0xffff8208: 59 74                         #             mov     %r3, SRCLINENO_OFS
0xffff820a: 20 74                         #             addd    %r3, %bp            ; r3 = &static_data.src_lineno
0xffff820c: 1b 0c                         #             stx     %r0, %r3            ; static_data->src_lineno = reloc_entry->src_lineno
0xffff820e: 61 48                         #             subd    %r2, 8              ; &reloc_entry.entry
0xffff8210: 2a 08                         #             ldd     %r0, %r2            ; arg 0 = reloc_entry->entry
0xffff8212: b0 1c                         #             call    assemble_sp_visit   ; handle this reloc table entry
0xffff8214: 2c 58                         #             popd    %r2                 ; reload original value of reloc_entry
0xffff8216: 60 48                         #             addd    %r2, 8              ; &entry->next
0xffff8218: 2a 48                         #             ldd     %r2, %r2            ; entry = entry->next
0xffff821a: 67 5f                         #             testd   %r2, -1             ; is entry now NULL?
0xffff821c: 91 e2                         #             jnz     assemble_sp_L1      ; if entry is not NULL, it's a valid entry. Loop.
0xffff821e:                               # assemble_sp_L2:
0xffff821e: 2c 18                         #             popd    %r0                 ; restore final lineno
0xffff8220: 59 34                         #             mov     %r1, SRCLINENO_OFS
0xffff8222: 20 34                         #             addd    %r1, %bp            ; &static_data.src_lineno
0xffff8224: 1b 04                         #             stx     %r0, %r1            ; static_data->src_lineno = saved original lineno
0xffff8226: 2c 18                         #             popd    %r0                 ; restore ip at end of program
0xffff8228: 2b 14                         #             std     %r0, %bp            ; static_data->asm_ip = ip at end of program
0xffff822a: 2c f8                         #             popd    %ln                 ; restore return address
0xffff822c: af ee                         #             ret
0xffff822e:                               # assemble_sp_visit:
0xffff822e: 2d dc                         #             pushd   %ln
0xffff8230: b0 6a                         #             call    sp_get_symbol       ; arg 0 = target = sp_get_symbol(ste)
0xffff8232: 0a 44                         #             ldh     %r2, %r1            ; opc = *asm_ip
0xffff8234: 43 5d                         #             cmph    %r2, -3             ; test if opc is -3
0xffff8236: 81 0e                         #             jne     assemble_sp_visit_L2; fall through if it is...
0xffff8238: 60 21                         #             addd    %r1, 1              ; asm_ip + 1
0xffff823a: 0a 44                         #             ldh     %r2, %r1            ; r2 = reg = *(asm_ip+1)
0xffff823c: 29 20                         #             movd    %r1, %r0            ; arg 1 = target
0xffff823e: 09 08                         #             movh    %r0, %r2            ; arg 0 = reg
0xffff8240: 49 41                         #             movh    %r2, 1              ; arg 2 = true [tell assemble_long_mov to use nops]
0xffff8242: b1 78                         #             call    assemble_long_mov   ; tail-call (it won't be returning here), it returns off stack
0xffff8244:                               # assemble_sp_visit_L2:
0xffff8244: 43 40                         #             cmph    %r2, 0              ; compare opc to 0
0xffff8246: 8b 0a                         #             jge     assemble_sp_visit_tx; if >= 0, it's a control transfer
0xffff8248: 09 28                         #             movh    %r1, %r2            ; prepare for arg 1 to have -opc
0xffff824a: 42 20                         #             rsubh   %r1, 0              ; arg1 = -opc
0xffff824c: 29 54                         #             movd    %r2, %r5            ; arg2 = &static_data (that's encode_value's cc)
0xffff824e: b4 74                         #             call    encode_value_stkret ; tail-call the encode_value entrypoint that wants %ln on the stack.
0xffff8250:                               # assemble_sp_visit_tx:
0xffff8250: 43 4f                         #             cmph    %r2, 15             ; opc >? 15
0xffff8252: 89 84                         #             ja      fp_call_L           ; if yes, this is a call
0xffff8254: 8e b0                         #             jmp     fp_jump_L           ; otherwise, it's a jump
0xffff8256:                               # fp_get_symbol:
0xffff8256: 2d dc                         #             pushd   %ln
0xffff8258: 2d c8                         #             pushd   %r2                 ; we promise to preserve this, so can't clobber
0xffff825a: be ec                         #             call    find_table_entry    ; r0 = entry = find_table_entry(name)
0xffff825c: 29 40                         #             movd    %r2, %r0            ; copy entry so we can check validity
0xffff825e: 2a 48                         #             ldd     %r2, %r2            ; entry->next, which is tagged with validity
0xffff8260: 47 41                         #             testh   %r2, 1              ; if that bit is on, the entry is valid
0xffff8262: 2c 58                         #             popd    %r2                 ; unwind the stack, we aren't calling more functions
0xffff8264: 2c f8                         #             popd    %ln                 ; final unwind
0xffff8266: af e1                         #             retnz                       ; if that bit was on, nz is set, entry is in r0, return!
0xffff8268: 59 64                         #             mov     %r3, HEAP_LIMIT_OFS
0xffff826a: 20 74                         #             addd    %r3, %r5            ; &static_data.heap_limit
0xffff826c: 2a 2c                         #             ldd     %r1, %r3            ; reloc_entry = static_data->heap_limit
0xffff826e: 60 24                         #             addd    %r1, 4              ; &reloc_entry->ste
0xffff8270: 2b 04                         #             std     %r0, %r1            ; reloc_entry->ste = entry
0xffff8272: 29 04                         #             movd    %r0, %r1            ; copy static_data->heap_limit+4
0xffff8274: 60 0c                         #             addd    %r0, 12             ; static_data->heap_limit+4 + 12
0xffff8276: 2b 0c                         #             std     %r0, %r3            ; static_data->heap_limit += 16
0xffff8278: 60 3c                         #             addd    %r1, -4             ; &reloc_entry->inst
0xffff827a: 2a 14                         #             ldd     %r0, %r5            ; r0 <- static_data->asm_ip
0xffff827c: 2b 04                         #             std     %r0, %r1            ; reloc_entry->inst = static_data->asm_ip
0xffff827e: 60 28                         #             addd    %r1, 8              ; &reloc_entry->next
0xffff8280: 59 1c                         #             mov     %r0, RELOC_TAB_HEAD_OFS
0xffff8282: 20 14                         #             addd    %r0, %r5            ; &static_data->reloc_tab_head
0xffff8284: 2a 60                         #             ldd     %r3, %r0            ; static_data->reloc_tab_head
0xffff8286: 2b 64                         #             std     %r3, %r1            ; reloc_entry->next = static_data->reloc_tab_head
0xffff8288: 60 38                         #             addd    %r1, -8             ; recover pointer to reloc_entry
0xffff828a: 2b 20                         #             std     %r1, %r0            ; static_data->reloc_tab_head = reloc_entry
0xffff828c: 60 2c                         #             addd    %r1, 12             ; &reloc_entry->lineno
0xffff828e: 59 14                         #             mov     %r0, SRCLINENO_OFS
0xffff8290: 20 14                         #             addd    %r0, %r5            ; &static_data->src_lineno
0xffff8292: 1a 00                         #             ldx     %r0, %r0            ; static_data->src_lineno
0xffff8294: 1b 04                         #             stx     %r0, %r1            ; reloc_entry->lineno = static_data->src_lineno
0xffff8296: 59 00                         #             mov     %r0, 0
0xffff8298: af ee                         #             ret
0xffff829a:                               # sp_get_symbol:
0xffff829a: 2d dc                         #             pushd   %ln
0xffff829c: 2d c0                         #             pushd   %r0                 ; save entry
0xffff829e: 2a 00                         #             ldd     %r0, %r0            ; entry->next, tagged with validity
0xffff82a0: 47 01                         #             testh   %r0, 1              ; if the tag bit is on, it's valid!
0xffff82a2: 81 06                         #             jnz     sp_get_symbol_valid
0xffff82a4: 2c 38                         #             popd    %r1                 ; reload entry to arg1 = r1
0xffff82a6: b3 f6                         #             call    die_unknown_symbol  ; crash. Since we're crashing, no need to recover %ln.
0xffff82a8:                               # sp_get_symbol_valid:
0xffff82a8: 2c 18                         #             popd    %r0                 ; reload entry to return register
0xffff82aa: bf 1a                         #             call    ste_get_payload     ; r0 = entry->payload
0xffff82ac: 2c f8                         #             popd    %ln
0xffff82ae: af ee                         #             ret
0xffff82b0:                               # fp_die_out_range:
0xffff82b0: b3 e4                         #             call    die_out_of_range
0xffff82b2:                               # fp_0:
0xffff82b2: 43 4f                         #             cmph    %r2, 15             ; opc <=? 15
0xffff82b4: 89 0e                         #             ja      fp_0_encode_ret     ; if not, encode a return
0xffff82b6: 49 04                         #             movh    %r0, 4              ; otherwise, enc_fst = 4
0xffff82b8: 4c 00                         #             sloh    %r0, 0              ; enc_fst <<= 5
0xffff82ba: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0xffff82bc: 49 20                         #             movh    %r1, 0              ; enc_snd = 0
0xffff82be: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff82c0: 8e 8e                         #             jmp     finalize_encoding   ; tail-call
0xffff82c2:                               # fp_0_encode_ret:
0xffff82c2: 59 07                         #             mov     %r0, 7              ; regL = 7
0xffff82c4: 46 4f                         #             andh    %r2, 15             ; opc &= 15
0xffff82c6: 8e 02                         #             jmp     fp_RJ               ; tail-call
0xffff82c8:                               # fp_RJ:
0xffff82c8: 09 20                         #             movh    %r1, %r0            ; enc_snd = reg
0xffff82ca: 4c 20                         #             sloh    %r1, 0              ; enc_snd <<= 5
0xffff82cc: 04 28                         #             orh     %r1, %r2            ; enc_snd |= opc
0xffff82ce: 49 05                         #             movh    %r0, 5              ; enc_fst = 5
0xffff82d0: 4c 0f                         #             sloh    %r0, 15             ; enc_fst = enc_fst << 5 | 15
0xffff82d2: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff82d4: 8e 7a                         #             jmp     finalize_encoding   ; tail-call
0xffff82d6:                               # fp_call_L:
0xffff82d6: 21 04                         #             subd    %r0, %r1            ; disp = tgt - here
0xffff82d8: 58 21 5c 3f 5c 3f             #             mov     %r1, 2047           ; get 2047 for comparison
0xffff82de: 23 04                         #             cmpd    %r0, %r1            ; disp >? 2047
0xffff82e0: 9d d0                         #             jg      fp_die_out_range    ; if yes, die
0xffff82e2: 62 3f                         #             rsubd   %r1, -1             ; r1 = ~2047 = -2048
0xffff82e4: 23 04                         #             cmpd    %r0, %r1            ; disp <? -2048
0xffff82e6: 9a ca                         #             jl      fp_die_out_range
0xffff82e8: 19 60                         #             mov     %r3, %r0            ; save displacement in r3
0xffff82ea: 59 28                         #             mov     %r1, 8              ; arg 1 = 8
0xffff82ec: be 32                         #             call    shr4                ; imm = (imm >> 4) & 0xFF
0xffff82ee: 59 24                         #             mov     %r1, 4              ; arg 1 = 4
0xffff82f0: be 2e                         #             call    shr4                ; imm = (imm >> 4) & 0xF
0xffff82f2: 40 08                         #             addh    %r0, 8
0xffff82f4: 40 08                         #             addh    %r0, 8              ; imm += 16
0xffff82f6: 59 25                         #             mov     %r1, 5
0xffff82f8: 4c 20                         #             sloh    %r1, 0              ; r1 = 5 << 5
0xffff82fa: 04 04                         #             orh     %r0, %r1            ; enc_fst = imm | (5 << 5)
0xffff82fc: 19 2c                         #             mov     %r1, %r3            ; put displacement back in arg 1
0xffff82fe: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff8300: 8e 4e                         #             jmp     finalize_encoding   ; tail-call
0xffff8302:                               # fp_jump_L_stdcall:
0xffff8302: 2d dc                         #             pushd   %ln
0xffff8304:                               # fp_jump_L:
0xffff8304: 22 20                         #             rsubd   %r1, %r0            ; disp = tgt - done
0xffff8306: 58 07 5c 1f                   #             mov     %r0, 255            ; get 255 for comparison
0xffff830a: 23 20                         #             cmpd    %r1, %r0            ; disp >? 255
0xffff830c: 9d a4                         #             jg      fp_die_out_range    ; if yes, die
0xffff830e: 62 1f                         #             rsubd   %r0, -1             ; r0 = ~255 = -256
0xffff8310: 23 20                         #             cmpd    %r1, %r0            ; disp <? -256
0xffff8312: 9a 9e                         #             jl      fp_die_out_range
0xffff8314: 53 20                         #             cmpx    %r1, 0              ; disp <? 0
0xffff8316: 8b 06                         #             jge     fp_jump_L_skip_inc  ; if not, don't adjust the opcode
0xffff8318: 50 48                         #             addx    %r2, 8
0xffff831a: 50 48                         #             addx    %r2, 8              ; opc += 16
0xffff831c:                               # fp_jump_L_skip_inc:
0xffff831c: 59 04                         #             mov     %r0, 4              ; enc_fst = 4
0xffff831e: 4c 00                         #             sloh    %r0, 0              ; enc_fst <<= 5
0xffff8320: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0xffff8322: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff8324: 8e 2a                         #             jmp     finalize_encoding   ; tail-call
0xffff8326:                               # fp_RR:
0xffff8326: 00 24                         #             addh    %r1, %r1            ; regR <<= 1
0xffff8328: 00 24                         #             addh    %r1, %r1            ; regR <<= 1
0xffff832a: 4c 00                         #             sloh    %r0, 0              ; regL <<= 5
0xffff832c: 04 20                         #             orh     %r1, %r0            ; enc_snd = regL (<< 5) | regR (<< 2)
0xffff832e:                               # fp_RX_shared:
0xffff832e: 00 6c                         #             addh    %r3, %r3            ; size_bits << 1
0xffff8330: 00 6c                         #             addh    %r3, %r3            ; size_bits << 2
0xffff8332: 00 6c                         #             addh    %r3, %r3            ; size_bits << 3
0xffff8334: 00 6c                         #             addh    %r3, %r3            ; size_bits << 4
0xffff8336: 09 0c                         #             movh    %r0, %r3            ; enc_fst = size_bits << 4
0xffff8338: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0xffff833a: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff833c: 8e 12                         #             jmp     finalize_encoding
0xffff833e:                               # fp_RI_stdcall:
0xffff833e: 2d dc                         #             pushd   %ln
0xffff8340:                               # fp_RI:
0xffff8340: 4c 00                         #             sloh    %r0, 0              ; regL <<= 5
0xffff8342: 58 ff                         #             movz    %r7, 31
0xffff8344: 06 3c                         #             andh    %r1, %r7            ; imm &= 31
0xffff8346: 04 20                         #             orh     %r1, %r0            ; enc_snd = regL (<< 5) | imm (& 31)
0xffff8348: 40 64                         #             addh    %r3, 4              ; size_bits += 4
0xffff834a: 9e e4                         #             jmp     fp_RX_shared        ; tail-call to setup enc_fst and numbytes
0xffff834c:                               # finalize_encoding_stdcall:
0xffff834c: 2d dc                         #             pushd   %ln
0xffff834e:                               # finalize_encoding:
0xffff834e: 2a f4                         #             ldd     %r7, %bp            ; r7 = iloc = static_data->asm_ip
0xffff8350: 20 5c                         #             addd    %r2, %r7            ; r2 = iloc + numbytes
0xffff8352: 2b 54                         #             std     %r2, %bp            ; static_data->asm_ip += numbytes
0xffff8354: 0b 1c                         #             sth     %r0, %r7            ; *iloc = first byte
0xffff8356: 60 e1                         #             addd    %r7, 1              ; iloc + 1
0xffff8358: 0b 3c                         #             sth     %r1, %r7            ; *(iloc + 1) = second byte
0xffff835a: 2c f8                         #             popd    %ln
0xffff835c: af ee                         #             ret
0xffff835e:                               # fp_R:
0xffff835e: 43 4c                         #             cmph    %r2, 12             ; opc == 12?
0xffff8360: 81 06                         #             jne     fp_R_push           ; if not, encode a push
0xffff8362: 49 26                         #             movh    %r1, 6              ; otherwise, encode a pop
0xffff8364: 9e c2                         #             jmp     fp_RR               ; tail-call
0xffff8366:                               # fp_R_push:
0xffff8366: 09 20                         #             movh    %r1, %r0            ; regR = regL
0xffff8368: 49 06                         #             movh    %r0, 6              ; regL = 6
0xffff836a: 9e bc                         #             jmp     fp_RR               ; tail-call
0xffff836c:                               # fp_I:
0xffff836c: 49 06                         #             movh    %r0, 6              ; regL = 6
0xffff836e: 9e d2                         #             jmp     fp_RI               ; tail-call
0xffff8370:                               # fp_LM:
0xffff8370: 67 9f                         #             testd   %r4, -1             ; test name
0xffff8372: 59 40                         #             mov     %r2, 0              ; arg 2 <- false [long_mov doesn't need nops]
0xffff8374: 80 46                         #             jz      assemble_long_mov   ; if it's null, dispatch immediately (tail call)
0xffff8376: 09 40                         #             movh    %r2, %r0            ; r2 = reg
0xffff8378: 29 10                         #             movd    %r0, %r4            ; arg 0 = name
0xffff837a: be dc                         #             call    fp_get_symbol       ; lookup the symtab entry for name
0xffff837c: 67 1f                         #             testd   %r0, -1             ; test it
0xffff837e: 81 0a                         #             jnz     fp_LM_have_entry    ; if it's not null, rearrange args and go
0xffff8380: 49 1d                         #             movh    %r0, -3             ; otherwise, set up to defer
0xffff8382: 09 28                         #             movh    %r1, %r2            ; arg 1 = reg
0xffff8384: 59 4e                         #             movx    %r2, 14             ; numbytes = 14
0xffff8386: 9e c8                         #             jmp     finalize_encoding   ; tail-call
0xffff8388:                               # fp_LM_have_entry:
0xffff8388: be 3c                         #             call    ste_get_payload     ; r0 <- payload from entry in r0
0xffff838a: 29 20                         #             movd    %r1, %r0            ; arg 1 = imm
0xffff838c: 09 08                         #             movh    %r0, %r2            ; arg 0 = reg
0xffff838e: 59 40                         #             mov     %r2, 0              ; arg 2 = false [long move doesn't need nops]
0xffff8390: 8e 2a                         #             jmp     assemble_long_mov
0xffff8392:                               # fp_LJ_good_payload:
0xffff8392: be 32                         #             call    ste_get_payload     ; arg 0 = entry->payload
0xffff8394: 58 3e                         #             mov     %r1, 30             ; get 30 for comparison
0xffff8396: 03 44                         #             cmph    %r2, %r1            ; opc == 30?
0xffff8398: 2a 34                         #             ldd     %r1, %bp            ; arg 1 = static_data->asm_ip
0xffff839a: 90 3c                         #             je      fp_call_L           ; if opc == 30, go to call_L
0xffff839c: 9e 68                         #             jmp     fp_jump_L           ; otherwise, to jump_L
0xffff839e:                               # fp_LJ:
0xffff839e: 43 4f                         #             cmph    %r2, 15             ; opc >? 15
0xffff83a0: 88 0a                         #             jbe     fp_LJ_good_opc      ; if no, we have a jump which is valid
0xffff83a2: 58 1e                         #             mov     %r0, 30             ; get 30 for comparison
0xffff83a4: 03 40                         #             cmph    %r2, %r0            ; opc == 30?
0xffff83a6: 80 04                         #             je      fp_LJ_good_opc      ; if yes, opcode is good
0xffff83a8: b1 c4                         #             call    fpsm_reject         ; if no, reject
0xffff83aa:                               # fp_LJ_good_opc:
0xffff83aa: 29 10                         #             movd    %r0, %r4            ; arg 0 = name
0xffff83ac: be aa                         #             call    fp_get_symbol       ; r0 = entry for name in symtab
0xffff83ae: 67 1f                         #             testd   %r0, -1             ; test the entry pointer
0xffff83b0: 91 e2                         #             jnz     fp_LJ_good_payload  ; if it's not NULL, dispatch to {call/jump}_L
0xffff83b2: 09 08                         #             movh    %r0, %r2            ; arg 0 = opc
0xffff83b4: 59 3f                         #             mov     %r1, -1             ; arg 1 = -1
0xffff83b6: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff83b8: 9e 96                         #             jmp     finalize_encoding   ; tail-call
0xffff83ba:                               # assemble_long_mov:
0xffff83ba: 2d c0                         #             pushd   %r0                 ; cache all our arguments on the stack.
0xffff83bc: 2d c8                         #             pushd   %r2                 ; we will retrieve these as needed (painfully).
0xffff83be: 2d c4                         #             pushd   %r1                 ; push imm last because it is also the last bit_group.
0xffff83c0: 29 04                         #             movd    %r0, %r1            ; arg 0 = imm
0xffff83c2: 58 3b                         #             movz    %r1, 27             ; arg 1 = 27 (#bits to preserve)
0xffff83c4: bd 52                         #             call    shr5
0xffff83c6: 2d c0                         #             pushd   %r0                 ; groups[5] = imm >> 5
0xffff83c8: 58 36                         #             movz    %r1, 22
0xffff83ca: bd 4c                         #             call    shr5
0xffff83cc: 2d c0                         #             pushd   %r0                 ; groups[4] = groups[5] >> 5
0xffff83ce: 58 31                         #             movz    %r1, 17
0xffff83d0: bd 46                         #             call    shr5
0xffff83d2: 2d c0                         #             pushd   %r0                 ; groups[3] = groups[4] >> 5
0xffff83d4: 58 2c                         #             movz    %r1, 12
0xffff83d6: bd 40                         #             call    shr5
0xffff83d8: 2d c0                         #             pushd   %r0                 ; groups[2] = groups[3] >> 5
0xffff83da: 58 27                         #             movz    %r1, 7
0xffff83dc: bd 3a                         #             call    shr5
0xffff83de: 2d c0                         #             pushd   %r0                 ; groups[1] = groups[2] >> 5
0xffff83e0: 58 22                         #             movz    %r1, 2
0xffff83e2: bd 34                         #             call    shr5                ; r0 = groups[1] >> 5 (2 bits)
0xffff83e4: 65 02                         #             xord    %r0, 2              ; this xor-sub sequence performs
0xffff83e6: 61 02                         #             subd    %r0, 2              ; sign-extension from 2 bits!
0xffff83e8: 2d c0                         #             pushd   %r0                 ; groups[0] = sext(groups[1] >> 5, from 2)
0xffff83ea: 59 80                         #             mov     %r4, 0              ; group = 0 [0*4], in r4 where it won't get clobbered.
0xffff83ec: 58 18                         #             mov     %r0, 24
0xffff83ee: 20 18                         #             addd    %r0, %sp            ; r0 = &imm
0xffff83f0: 2a 00                         #             ldd     %r0, %r0            ; r0 = imm
0xffff83f2: 63 00                         #             cmpd    %r0, 0              ; compare imm against 0
0xffff83f4: 58 18                         #             mov     %r0, 24             ; retrieve 28 in r0, for comparisons later.
0xffff83f6: 8b 3c                         #             jge     alm_pos_check       ; go to the positive loop if its positive
0xffff83f8: 19 70                         #             mov     %r3, %r4            ; copy group-idx to r3
0xffff83fa: 20 78                         #             addd    %r3, %sp            ; &groups[group]
0xffff83fc: 2a 6c                         #             ldd     %r3, %r3            ; groups[group]
0xffff83fe: 8e 04                         #             jmp     alm_neg_check
0xffff8400:                               # alm_neg_loop:
0xffff8400: 50 84                         #             addx    %r4, 4              ; group += 1
0xffff8402:                               # alm_neg_check:
0xffff8402: 29 4c                         #             movd    %r2, %r3            ; copy-down the predictive group
0xffff8404: 19 70                         #             mov     %r3, %r4            ; copy group
0xffff8406: 50 64                         #             addx    %r3, 4              ; group + 1
0xffff8408: 20 78                         #             addd    %r3, %sp            ; &groups[group+1]
0xffff840a: 2a 6c                         #             ldd     %r3, %r3            ; groups[group+1]
0xffff840c: 13 80                         #             cmpx    %r4, %r0            ; compare group-idx against 24
0xffff840e: 85 10                         #             jae     alm_neg_mov         ; if it's not below, exit the loop
0xffff8410: 58 3f                         #             movz    %r1, 0x1F           ; r1 = 1F, nothing magic here
0xffff8412: 06 44                         #             andh    %r2, %r1            ; groups[group] & 0x1F
0xffff8414: 03 44                         #             cmph    %r2, %r1            ; groups[group] & 0x1F ==? 0x1F
0xffff8416: 81 08                         #             jne     alm_neg_mov         ; exit the loop if not equal,
0xffff8418: 58 30                         #             mov     %r1, 0x10           ; but we also have to exit if the next group
0xffff841a: 07 64                         #             testh   %r3, %r1            ; is the first bit of the next group on?
0xffff841c: 91 e4                         #             jnz     alm_neg_loop        ; if yes, loop.
0xffff841e:                               # alm_neg_mov:
0xffff841e: 58 01 5c 00                   #             mov     %r0, 32
0xffff8422: 20 18                         #             addd    %r0, %sp            ; &reg
0xffff8424: 2a 00                         #             ldd     %r0, %r0            ; arg 0 = reg
0xffff8426: 19 28                         #             mov     %r1, %r2            ; arg 1 = groups[group]. fp_RI will & with 31 for us.
0xffff8428: 59 49                         #             mov     %r2, 9              ; arg 2 = movs opcode
0xffff842a: 59 62                         #             mov     %r3, 2              ; arg 3 = dword size bits
0xffff842c: bf 12                         #             call    fp_RI_stdcall
0xffff842e: 8e 22                         #             jmp     alm_check_pass      ; we're done skipping groups. Insert nops?
0xffff8430:                               # alm_pos_loop:
0xffff8430: 50 84                         #             addx    %r4, 4              ; group += 1
0xffff8432:                               # alm_pos_check:
0xffff8432: 19 50                         #             mov     %r2, %r4            ; copy group-idx
0xffff8434: 20 58                         #             addd    %r2, %sp            ; &groups[group]
0xffff8436: 2a 48                         #             ldd     %r2, %r2            ; groups[group]
0xffff8438: 13 80                         #             cmpx    %r4, %r0            ; compare group-idx against 24
0xffff843a: 85 06                         #             jae     alm_pos_mov         ; if not below, exit the loop
0xffff843c: 63 40                         #             cmpd    %r2, 0              ; groups[group] ==? 0
0xffff843e: 90 f2                         #             je      alm_pos_loop        ; if yes, loop
0xffff8440:                               # alm_pos_mov:
0xffff8440: 58 01 5c 00                   #             mov     %r0, 32
0xffff8444: 20 18                         #             addd    %r0, %sp            ; &reg
0xffff8446: 2a 00                         #             ldd     %r0, %r0            ; arg 0 = reg
0xffff8448: 19 28                         #             mov     %r1, %r2            ; arg 1 = groups[group]. fp_RI will & with 31
0xffff844a: 59 48                         #             mov     %r2, 8              ; arg 2 = movz opcode
0xffff844c: 59 62                         #             mov     %r3, 2              ; arg 3 = dword size bits
0xffff844e: be f0                         #             call    fp_RI_stdcall
0xffff8450:                               # alm_check_pass:
0xffff8450: 58 1c                         #             mov     %r0, 28
0xffff8452: 20 18                         #             addd    %r0, %sp            ; &pass
0xffff8454: 2a 00                         #             ldd     %r0, %r0            ; pass
0xffff8456: 47 1f                         #             testh   %r0, -1             ; if pass is zero, skip nops
0xffff8458: 80 2c                         #             jz      alm_slo_check
0xffff845a: 59 60                         #             mov     %r3, 0              ; group is initially 0 and goes up by 4,
0xffff845c: 8e 0c                         #             jmp     alm_nop_check       ; so we have to match that for nop_count
0xffff845e:                               # alm_nop_loop:
0xffff845e: 59 00                         #             mov     %r0, 0
0xffff8460: 59 20                         #             mov     %r1, 0              ; arg 0 = arg 1 = 0. Jump disp will be 0.
0xffff8462: 59 4f                         #             mov     %r2, 15             ; arg 2 = NEVER cond code. canonical nop
0xffff8464: be 9e                         #             call    fp_jump_L_stdcall
0xffff8466: 50 64                         #             addx    %r3, 4              ; nop_count++
0xffff8468:                               # alm_nop_check:
0xffff8468: 13 70                         #             cmpx    %r3, %r4            ; nop_count <? group
0xffff846a: 94 f4                         #             jb      alm_nop_loop        ; loop if below
0xffff846c: 8e 18                         #             jmp     alm_slo_check       ; enter the slo-making loop
0xffff846e:                               # alm_slo_loop:
0xffff846e: 50 84                         #             addx    %r4, 4              ; group += 1
0xffff8470: 58 01 5c 00                   #             mov     %r0, 32
0xffff8474: 20 18                         #             addd    %r0, %sp            ; &reg
0xffff8476: 2a 00                         #             ldd     %r0, %r0            ; arg 0 = reg
0xffff8478: 19 30                         #             mov     %r1, %r4            ; r1 = group-idx
0xffff847a: 20 38                         #             addd    %r1, %sp            ; r1 = &groups[group]
0xffff847c: 2a 24                         #             ldd     %r1, %r1            ; arg 1 = groups[group]
0xffff847e: 59 4c                         #             mov     %r2, 12             ; arg 2 = slo opcode
0xffff8480: 59 62                         #             mov     %r3, 2              ; arg 3 = dword size bits
0xffff8482: be bc                         #             call    fp_RI_stdcall
0xffff8484:                               # alm_slo_check:
0xffff8484: 58 18                         #             mov     %r0, 24
0xffff8486: 13 80                         #             cmpx    %r4, %r0            ; group-idx <? 24 [group <? 6]
0xffff8488: 94 e6                         #             jb      alm_slo_loop        ; if yes, keep going.
0xffff848a: 60 cc                         #             addd    %sp, 12
0xffff848c: 60 cc                         #             addd    %sp, 12
0xffff848e: 60 cc                         #             addd    %sp, 12             ; %sp += 36. Same instr count as mov ?,36;add.
0xffff8490: 2c f8                         #             popd    %ln
0xffff8492: af ee                         #             ret
0xffff8494:                               # fpsm:
0xffff8494: 2d dc                         #             pushd   %ln
0xffff8496: 2d d4                         #             pushd   %r5
0xffff8498: 2a 74                         #             ldd     %r3, %r5            ; r3 = static_data->asm_ip
0xffff849a: 4a a1                         #             ldh     %r5, STREAM         ; initialize reader
0xffff849c: b7 4a                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff849e: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff84a0: 80 18                         #             jz      fpsm_0_notalpha     ; branch past name read if not name start
0xffff84a2: b4 f2                         #             call    read_name           ; r0 = pointer to read-in name
0xffff84a4: 09 94                         #             movh    %r4, %r5            ; stash cur in r4
0xffff84a6: 2a b8                         #             ldd     %r5, %sp            ; temporarily reload &static_data
0xffff84a8: 29 2c                         #             movd    %r1, %r3            ; r1 = static_data->asm_ip
0xffff84aa: bd 04                         #             call    ste_attach_payload  ; add this entry to the symbol table
0xffff84ac: 09 b0                         #             movh    %r5, %r4            ; restore cur to r5
0xffff84ae: 58 01 5c 1a                   #             mov     %r0, 58             ; setup 58 == ':' for comparison
0xffff84b2: b6 06                         #             call    match               ; cur == ':'?
0xffff84b4: 47 1f                         #             testh   %r0, -1             ; test result
0xffff84b6: 81 b6                         #             jne     fpsm_reject         ; reject with syntax error if cur != ':'
0xffff84b8:                               # fpsm_0_notalpha:
0xffff84b8: 58 01 5c 0e                   #             mov     %r0, 46             ; setup '.' for comparison
0xffff84bc: 03 a0                         #             cmph    %r5, %r0            ; cur ==? '.'
0xffff84be: 80 06                         #             je      fpsm_process_directive ; if yes, process a directive. That will return from fpsm.
0xffff84c0: 59 21                         #             mov     %r1, 1              ; state = 1
0xffff84c2: 8e b2                         #             jmp     fpsm_iterate        ; step the loop
0xffff84c4:                               # fpsm_process_directive:
0xffff84c4: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar(), step past '.'
0xffff84c6: b4 ce                         #             call    read_name           ; r0 = direc = read_name()
0xffff84c8: 29 40                         #             movd    %r2, %r0            ; stash direc somewhere that skip_whitespace won't clobber it
0xffff84ca: b3 f4                         #             call    skip_whitespace     ; skip_whitespace()
0xffff84cc: 29 08                         #             movd    %r0, %r2            ; arg 0 = direc
0xffff84ce: 2c 58                         #             popd    %r2                 ; arg 2 = &static_data, popping off our stack so that
0xffff84d0: b3 34                         #             call    asm_directive       ; tail-call asm_directive. It returns to our caller.
0xffff84d2:                               # fpsm_1:                                 ; switch case 1
0xffff84d2: b7 74                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0xffff84d4: 47 1f                         #             testh   %r0, -1             ; test result
0xffff84d6: 81 1a                         #             jnz     fpsm_1_accept       ; accept if is_eol(cur)
0xffff84d8: 58 01 5c 0e                   #             mov     %r0, 46             ; setup '.' for comparison
0xffff84dc: 03 a0                         #             cmph    %r5, %r0            ; cur ==? '.'
0xffff84de: 90 e6                         #             je      fpsm_process_directive ; if equal, process a directive instead.
0xffff84e0: b5 de                         #             call    read_opcode         ; r0 = rop.opcode, r1 = rop.state
0xffff84e2: 09 80                         #             movh    %r4, %r0            ; temporarily save the opcode in r4
0xffff84e4: 09 64                         #             movh    %r3, %r1            ; temporarily save the target state in r3
0xffff84e6: b3 fe                         #             call    read_size           ; r0 = size_bits
0xffff84e8: 2d c0                         #             pushd   %r0                 ; put size_bits in their stack slot
0xffff84ea: 2d d0                         #             pushd   %r4                 ; put opcode into its stack slot
0xffff84ec: 09 2c                         #             movh    %r1, %r3            ; re-place the state in r1
0xffff84ee: 8e 86                         #             jmp     fpsm_iterate        ; break
0xffff84f0:                               # fpsm_1_accept:
0xffff84f0: 2c 98                         #             popd    %r4                 ; restore static_data pointer
0xffff84f2: 60 88                         #             addd    %r4, EOL_CHAR_OFS   ; &static_data.eol_char
0xffff84f4: 0b b0                         #             sth     %r5, %r4            ; static_data->eol_char = cur
0xffff84f6: 61 88                         #             subd    %r4, EOL_CHAR_OFS   ; undo offset
0xffff84f8: 29 b0                         #             movd    %r5, %r4            ; move pointer back where it belongs
0xffff84fa: 2c f8                         #             popd    %ln
0xffff84fc: af ee                         #             ret
0xffff84fe:                               # fpsm_2:
0xffff84fe: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8502: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8504: 81 0a                         #             jne     fpsm_2_imm          ; if not equal, try checking immediate
0xffff8506: b5 8a                         #             call    read_register       ; if yes equal, read a register
0xffff8508: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff850a: 59 2c                         #             mov     %r1, 12             ; state = 12
0xffff850c: 8e 68                         #             jmp     fpsm_iterate        ; break
0xffff850e:                               # fpsm_2_imm:
0xffff850e: b7 06                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0xffff8510: 47 1f                         #             testh   %r0, -1             ; test is_imm_start(cur)
0xffff8512: 80 5a                         #             jz      fpsm_reject         ; if !is_imm_start(cur), this state rejects
0xffff8514: b4 0a                         #             call    read_immediate      ; otherwise, read the immediate
0xffff8516: 58 3f                         #             movz    %r1, 31             ; validate_u5 in %r0; see 'validate_u5' below
0xffff8518: 23 04                         #             cmpd    %r0, %r1            ; set 'be' condition if imm is valid
0xffff851a: 89 56                         #             ja      fpsm_invalid_imm    ; if not 'be' condition, imm is invalid. Die.
0xffff851c: 19 60                         #             movx    %r3, %r0            ; imm = read & validated immediate
0xffff851e: 59 2d                         #             mov     %r1, 13             ; state = 13
0xffff8520: 8e 54                         #             jmp     fpsm_iterate        ; break
0xffff8522:                               # fpsm_3:
0xffff8522: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8526: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8528: 81 0a                         #             jne     fpsm_3_label        ; if not equal, try checking label
0xffff852a: b5 66                         #             call    read_register       ; if yes equal, read a register
0xffff852c: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff852e: 59 2e                         #             mov     %r1, 14             ; state = 14
0xffff8530: 8e 44                         #             jmp     fpsm_iterate        ; break
0xffff8532:                               # fpsm_3_label:
0xffff8532: b6 b4                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff8534: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff8536: 80 36                         #             jz      fpsm_reject         ; if !is_alpha(cur), this state rejects
0xffff8538: b4 5c                         #             call    read_name           ; r0 = read_name()
0xffff853a: 29 80                         #             movd    %r4, %r0            ; symbolptr = read_name()
0xffff853c: 59 2f                         #             mov     %r1, 15             ; state = 15
0xffff853e: 8e 36                         #             jmp     fpsm_iterate        ; break
0xffff8540:                               # fpsm_4:
0xffff8540: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8544: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8546: 81 26                         #             jne     fpsm_reject         ; if not a register, this state rejects
0xffff8548: b5 48                         #             call    read_register       ; r0 = read_register()
0xffff854a: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff854c: 59 2c                         #             mov     %r1, 12             ; state = 12
0xffff854e: 8e 26                         #             jmp     fpsm_iterate        ; break
0xffff8550:                               # fpsm_5:
0xffff8550: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8554: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8556: 81 16                         #             jne     fpsm_reject         ; if not a register, this state rejects
0xffff8558: b5 38                         #             call    read_register       ; r0 = read_register()
0xffff855a: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff855c: 59 26                         #             mov     %r1, 6              ; state = 6
0xffff855e:                               # fpsm_scan_comma:
0xffff855e: b3 60                         #             call    skip_whitespace     ; skip whitespace between reg and comma
0xffff8560: 58 01 5c 0c                   #             mov     %r0, 44             ; r0 = ',' to check
0xffff8564: b5 54                         #             call    match               ; r0 = (cur != ',')
0xffff8566: 47 1f                         #             testh   %r0, -1             ; test (cur != ',')
0xffff8568: 81 04                         #             jnz     fpsm_reject         ; if it's not a comma, that's an error
0xffff856a: 8e 0a                         #             jmp     fpsm_iterate        ; break
0xffff856c:                               # fpsm_reject:
0xffff856c: 59 00                         #             mov     %r0, 0              ; r0 = INVALID_SYNTAX_CODE
0xffff856e: b6 fc                         #             call    die
0xffff8570:                               # fpsm_invalid_imm:
0xffff8570: 59 02                         #             mov     %r0, 2              ; r0 = INVALID_IMMEDIATE_CODE
0xffff8572: b6 f8                         #             call    die
0xffff8574:                               # fpsm_iterate:
0xffff8574: b3 4a                         #             call    skip_whitespace
0xffff8576: 43 2a                         #             cmph    %r1, 10             ; compare state to 10
0xffff8578: 89 e2                         #             ja      fpsm_eol            ; if bigger, go to the eol+accept check
0xffff857a: b0 16                         #             call    fpsm_iterate_2      ; put the address of the action table in r7
0xffff857c:                               # fpsm_action_table:
0xffff857c: 6c 85                         #             .word   fpsm_reject & 0xFFFF
0xffff857e: d2 84                         #             .word   fpsm_1 & 0xFFFF
0xffff8580: fe 84                         #             .word   fpsm_2 & 0xFFFF
0xffff8582: 22 85                         #             .word   fpsm_3 & 0xFFFF
0xffff8584: 40 85                         #             .word   fpsm_4 & 0xFFFF
0xffff8586: 50 85                         #             .word   fpsm_5 & 0xFFFF
0xffff8588: 9a 85                         #             .word   fpsm_6 & 0xFFFF
0xffff858a: ea 85                         #             .word   fpsm_7 & 0xFFFF
0xffff858c: 00 86                         #             .word   fpsm_8 & 0xFFFF
0xffff858e: 42 86                         #             .word   fpsm_9 & 0xFFFF
0xffff8590:                               # fpsm_iterate_2:
0xffff8590: 00 24                         #             addh    %r1, %r1            ; state *= sizeof(word)
0xffff8592: 20 3c                         #             addd    %r1, %r7            ; r1 = pointer to pointer switch case
0xffff8594: 1a 24                         #             ldx     %r1, %r1            ; r1 = pointer to switch case (16 bit)
0xffff8596: 19 24                         #             movsx   %r1, %r1            ; r1 = sext16(r1)
0xffff8598: af 2e                         #             jmp     %r1                 ; follow the yellow brick road
0xffff859a:                               # fpsm_6:
0xffff859a: 0a 98                         #             ldh     %r4, %sp            ; r4 = opc, bottom stack slot
0xffff859c: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff85a0: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff85a2: 81 0e                         #             jne     fpsm_6_imm          ; if not a register, try checking immediate
0xffff85a4: 43 8c                         #             cmph    %r4, 12             ; opc == OPC_SLO?
0xffff85a6: 90 c6                         #             je      fpsm_reject         ; this state rejects OPC_SLO
0xffff85a8: b4 e8                         #             call    read_register       ; r0 = read_register()
0xffff85aa: 09 60                         #             movh    %r3, %r0            ; regR = read_register()
0xffff85ac: 58 30                         #             mov     %r1, 16             ; state = 16
0xffff85ae: 9e c6                         #             jmp     fpsm_iterate        ; break
0xffff85b0:                               # fpsm_6_imm:
0xffff85b0: b6 64                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0xffff85b2: 57 1f                         #             test    %r0, -1             ; test is_imm_start(cur)
0xffff85b4: 80 1e                         #             jz      fpsm_6_symbol       ; if not, we still must check for .set symbols
0xffff85b6: b3 68                         #             call    read_immediate      ; r0 = read_immediate()
0xffff85b8:                               # fpsm_6_validate_imm:
0xffff85b8: 43 8a                         #             cmph    %r4, 10             ; opc >= 10?
0xffff85ba: 85 0c                         #             jae     fpsm_6_u5           ; if yes, validate unsigned
0xffff85bc: 43 88                         #             cmph    %r4, 8              ; opc == 8?
0xffff85be: 80 08                         #             je      fpsm_6_u5           ; if yes, validate unsigned
0xffff85c0:                               # fpsm_6_s5:
0xffff85c0: b6 14                         #             call    validate_s5         ; r0 unchanged, flags set 'b' if valid
0xffff85c2: 95 ae                         #             jae     fpsm_invalid_imm    ; if not 'b' condition, imm is invalid. Die.
0xffff85c4: 8e 08                         #             jmp     fpsm_6_end          ; clean up
0xffff85c6:                               # fpsm_6_u5:
0xffff85c6: 58 3f                         #             movz    %r1, 31             ; validate_u5 in %r0; see 'validate_u5' below
0xffff85c8: 23 04                         #             cmpd    %r0, %r1            ; set 'be' condition if imm is valid
0xffff85ca: 99 a6                         #             ja      fpsm_invalid_imm    ; if not 'be' condition, imm is invalid. Die.
0xffff85cc:                               # fpsm_6_end:
0xffff85cc: 19 60                         #             movx    %r3, %r0            ; It's valid. Save it: imm = r0
0xffff85ce: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff85d0: 9e a4                         #             jmp     fpsm_iterate        ; break
0xffff85d2:                               # fpsm_6_symbol:
0xffff85d2: b6 14                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff85d4: 47 1f                         #             testh   %r0, -1             ; if it's not, this state is out of options and rejects
0xffff85d6: 90 96                         #             jz      fpsm_reject
0xffff85d8: b3 bc                         #             call    read_name           ; r0 = read_name()
0xffff85da: 09 94                         #             movh    %r4, %r5            ; hide cur in %r4
0xffff85dc: 59 a8                         #             mov     %r5, 8              ; offset of stack slot for &static_data
0xffff85de: 20 b8                         #             addd    %r5, %sp
0xffff85e0: 2a b4                         #             ldd     %r5, %r5            ; r5 = &static_data
0xffff85e2: bc 74                         #             call    fp_get_symbol       ; clobbers r1 and r3. nothing in r3 (yet). r2 has regL
0xffff85e4: 09 b0                         #             movh    %r5, %r4            ; return cur to %r5
0xffff85e6: bc b4                         #             call    sp_get_symbol       ; r0 = payload from entry if it's valid.
0xffff85e8: 9e d0                         #             jmp     fpsm_6_validate_imm ; validate that immediate.
0xffff85ea:                               # fpsm_7:
0xffff85ea: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff85ee: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff85f0: 91 7c                         #             jne     fpsm_reject         ; if not register, this state rejects
0xffff85f2: b3 d8                         #             call    read_any_register   ; r0 = read_any_register()
0xffff85f4: 09 40                         #             movh    %r2, %r0            ; regL = read_any_register()
0xffff85f6: 43 48                         #             cmph    %r2, 8              ; regL <? 8
0xffff85f8: 59 28                         #             mov     %r1, 8              ; state = 8
0xffff85fa: 94 64                         #             jb      fpsm_scan_comma     ; if regL < 8, scan comma
0xffff85fc: 59 29                         #             mov     %r1, 9              ; otherwise, state = 9
0xffff85fe: 9e 60                         #             jmp     fpsm_scan_comma     ; then scan comma
0xffff8600:                               # fpsm_8:
0xffff8600: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8604: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8606: 81 18                         #             jne     fpsm_8_imm          ; if not register, try immediate
0xffff8608: b3 c2                         #             call    read_any_register   ; r0 = read_any_register()
0xffff860a: 09 60                         #             movh    %r3, %r0            ; regR = read_any_register()
0xffff860c: 43 68                         #             cmph    %r3, 8              ; regR <? 8
0xffff860e: 8b 06                         #             jge     fpsm_8_ctrl_reg     ; if regR >= 8, it's a control reg
0xffff8610: 58 30                         #             mov     %r1, 16             ; state = 16
0xffff8612: 9e 62                         #             jmp     fpsm_iterate        ; break
0xffff8614:                               # fpsm_8_ctrl_reg:
0xffff8614: 41 68                         #             subh    %r3, 8              ; imm = regR - 8
0xffff8616: 60 c4                         #             addd    %sp, 4              ; pop opc off the stack
0xffff8618: 6d ce                         #             pushd   14                  ; overwrite opc with 14
0xffff861a: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff861c: 9e 58                         #             jmp     fpsm_iterate        ; break
0xffff861e:                               # fpsm_8_imm:
0xffff861e: b5 f6                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0xffff8620: 47 1f                         #             testh   %r0, -1             ; test is_imm_start(cur)
0xffff8622: 80 12                         #             jz      fpsm_8_label        ; if not an imm, try label
0xffff8624: b2 fa                         #             call    read_immediate      ; r0 = read_immediate()
0xffff8626: b5 ae                         #             call    validate_s5         ; set 'b' if r0 is a valid s5
0xffff8628: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff862a: 29 60                         #             movd    %r3, %r0            ; imm = read_immediate()
0xffff862c: 94 48                         #             jb      fpsm_iterate        ; break, if imm is a valid s5
0xffff862e: 59 80                         #             mov     %r4, 0              ; symbolptr = NULL
0xffff8630: 58 32                         #             mov     %r1, 18             ; state = 18
0xffff8632: 9e 42                         #             jmp     fpsm_iterate        ; break
0xffff8634:                               # fpsm_8_label:
0xffff8634: b5 b2                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff8636: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff8638: 90 34                         #             jz      fpsm_reject         ; if !is_alpha(cur), finally this state rejects.
0xffff863a: b3 5a                         #             call    read_name           ; r0 = read_name()
0xffff863c: 29 80                         #             movd    %r4, %r0            ; symbolptr = read_name()
0xffff863e: 58 32                         #             mov     %r1, 18             ; state = 18
0xffff8640: 9e 34                         #             jmp     fpsm_iterate        ; break
0xffff8642:                               # fpsm_9:
0xffff8642: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8646: 03 a0                         #             cmph    %r5, %r0            ; r0 == '%'?
0xffff8648: 91 24                         #             jne     fpsm_reject         ; if not a register, this state rejects
0xffff864a: 09 68                         #             movh    %r3, %r2            ; imm = regL
0xffff864c: 41 68                         #             subh    %r3, 8              ; imm -= 8
0xffff864e: b4 42                         #             call    read_register       ; r0 = read_register()
0xffff8650: 09 40                         #             movh    %r2, %r0            ; r2 = read_register()
0xffff8652: 60 c4                         #             addd    %sp, 4              ; pop opc off the stack
0xffff8654: 6d cf                         #             pushd   15                  ; overwrite opc with 15
0xffff8656: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff8658: 9e 1c                         #             jmp     fpsm_iterate
0xffff865a:                               # fpsm_eol:
0xffff865a: b5 ec                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0xffff865c: 47 1f                         #             testh   %r0, -1             ; test is_eol(cur)
0xffff865e: 90 0e                         #             jz      fpsm_reject         ; if it's not eol (somehow?) reject!
0xffff8660:                               # fpsm_accept:
0xffff8660: 59 e8                         #             mov     %r7, 8              ; offset of &static_data on the stack
0xffff8662: 20 f8                         #             addd    %r7, %sp            ; point at stack slot of &static_data
0xffff8664: 2a fc                         #             ldd     %r7, %r7            ; r7 = &static_data
0xffff8666: 60 e8                         #             addd    %r7, EOL_CHAR_OFS   ; r7 = &static_data.eol_char
0xffff8668: 0b bc                         #             sth     %r5, %r7            ; static_data->eol_char = cur
0xffff866a: 09 a4                         #             movh    %r5, %r1            ; r5 = state, temporarily
0xffff866c: 09 08                         #             movh    %r0, %r2            ; arg 0 = regL
0xffff866e: 19 2c                         #             movx    %r1, %r3            ; arg 1 = regR/imm
0xffff8670: 2c 58                         #             popd    %r2                 ; arg 2 = opcode
0xffff8672: 2c 78                         #             popd    %r3                 ; arg 3 = size_bits
0xffff8674: b0 12                         #             call    fpsm_accept_exit    ; get the address of the table into r7
0xffff8676:                               # fpsm_accept_jump_table:
0xffff8676: b2 82                         #             .word   fp_0  & 0xFFFF
0xffff8678: 5e 83                         #             .word   fp_R  & 0xFFFF
0xffff867a: 6c 83                         #             .word   fp_I  & 0xFFFF
0xffff867c: c8 82                         #             .word   fp_RJ & 0xFFFF
0xffff867e: 9e 83                         #             .word   fp_LJ & 0xFFFF
0xffff8680: 26 83                         #             .word   fp_RR & 0xFFFF
0xffff8682: 40 83                         #             .word   fp_RI & 0xFFFF
0xffff8684: 70 83                         #             .word   fp_LM & 0xFFFF
0xffff8686:                               # fpsm_accept_exit:
0xffff8686: 41 ab                         #             subh    %r5, 11             ; offset = state - 11
0xffff8688: 00 b4                         #             addh    %r5, %r5            ; offset *= sizeof(word)
0xffff868a: 20 f4                         #             addd    %r7, %r5            ; r7 = pointer to address to jump to
0xffff868c: 1a fc                         #             ldx     %r7, %r7            ; r7 = address to jump to (16 bit)
0xffff868e: 19 fc                         #             movsx   %r7, %r7            ; r7 = full address to jump to (32-bit)
0xffff8690: 2c b8                         #             popd    %r5                 ; r5 = &static_data. Hooray!
0xffff8692: af ee                         #             jmp     %r7                 ; tail-call the assembling function
0xffff8694:                               # die_out_of_range:
0xffff8694: 59 03                         #             mov     %r0, 3              ; OUT_OF_RANGE_CODE
0xffff8696: b5 d4                         #             call    die
0xffff8698:                               # die_missing_feature:
0xffff8698: 59 05                         #             mov     %r0, 5              ; missing feature code
0xffff869a: b5 d0                         #             call    die
0xffff869c:                               # die_unknown_symbol:
0xffff869c: 59 06                         #             mov     %r0, 6              ; unknown symbol code
0xffff869e: b5 cc                         #             call    die
0xffff86a0:                               # strncmp:
0xffff86a0: 2d cc                         #             pushd   %r3             ; wind stack, giving two free registers
0xffff86a2: 2d d0                         #             pushd   %r4             ; which we will use to hold *a and *b
0xffff86a4:                               # strncmp_L1:                         ; top of loop
0xffff86a4: 0a 60                         #             ldh     %r3, %r0        ; r3 = *a
0xffff86a6: 0a 84                         #             ldh     %r4, %r1        ; r4 = *b
0xffff86a8: 01 8c                         #             subh    %r4, %r3        ; subtract *a from *b
0xffff86aa: 81 0e                         #             jne     strncmp_L2      ; return if *a != *b
0xffff86ac: 47 7f                         #             testh   %r3, -1         ; test *a
0xffff86ae: 80 0a                         #             jz      strncmp_L2      ; also return if *a == 0 (note *b - *a still in %r4)
0xffff86b0: 60 01                         #             addd    %r0, 1          ; ++a
0xffff86b2: 60 21                         #             addd    %r1, 1          ; ++b
0xffff86b4: 61 41                         #             subd    %r2, 1          ; --n
0xffff86b6: 99 ee                         #             ja      strncmp_L1      ; if n is > 0 (unsigned), loop
0xffff86b8:                               # strncmp_L2:                         ; return label
0xffff86b8: 09 10                         #             movh    %r0, %r4        ; return value is *b - *a
0xffff86ba: 2c 98                         #             popd    %r4             ; unwind stack
0xffff86bc: 2c 78                         #             popd    %r3
0xffff86be: af ee                         #             ret
0xffff86c0:                               # encode_value:
0xffff86c0: 2d dc                         #             pushd   %ln
0xffff86c2:                               # encode_value_stkret:
0xffff86c2: 2a e8                         #             ldd     %ln, %r2            ; iloc = static_data->asm_ip
0xffff86c4: 2d c0                         #             pushd   %r0                 ; put value on the stack so we can pop one byte at a time
0xffff86c6:                               # encode_value_loop:
0xffff86c6: 0c 18                         #             poph    %r0                 ; pop 1 byte of the value
0xffff86c8: 0b 1c                         #             sth     %r0, %ln            ; *iloc = *val
0xffff86ca: 60 e1                         #             addd    %ln, 1              ; iloc++
0xffff86cc: 41 21                         #             subh    %r1, 1              ; numbytes--
0xffff86ce: 91 f8                         #             jnz     encode_value_loop   ; if numbytes is now 0, we're done. Owise loop
0xffff86d0: 60 c3                         #             addd    %sp, 3
0xffff86d2: 66 dc                         #             andd    %sp, -4             ; re-align the stack pointer
0xffff86d4: 2b e8                         #             std     %ln, %r2            ; static_data->asm_ip = iloc
0xffff86d6: 2c f8                         #             popd    %ln
0xffff86d8: af ee                         #             ret
0xffff86da:                               # set_directive:
0xffff86da: 2d dc                         #             pushd   %ln
0xffff86dc: 2d c0                         #             pushd   %r0                 ; skip_whitespace clobbers this
0xffff86de: 2d c4                         #             pushd   %r1                 ; is_alpha clobbers this
0xffff86e0: 2d c8                         #             pushd   %r2                 ; ste_attach_payload clobbers this
0xffff86e2: 2d cc                         #             pushd   %r3                 ; ste_attach_payload clobbers this
0xffff86e4: b5 02                         #             call    cur_is_alpha        ; r0 = boolean cur is alpha?
0xffff86e6: 47 1f                         #             testh   %r0, -1             ; if it is not (r0 == 0), reject
0xffff86e8: 80 2c                         #             jz      set_directive_reject
0xffff86ea: b2 a6                         #             call    read_name_with_sd   ; read a name, &static_data is still in r2
0xffff86ec: 2d c0                         #             pushd   %r0                 ; and immediately save it on the stack
0xffff86ee: b1 d0                         #             call    skip_whitespace     ; skip whitespace between name and value
0xffff86f0: b5 24                         #             call    cur_is_imm_start    ; check syntax: next character starts imm?
0xffff86f2: 47 1f                         #             testh   %r0, -1             ; if it's not (r0 == 0), reject
0xffff86f4: 80 20                         #             jz      set_directive_reject
0xffff86f6: b2 28                         #             call    read_immediate      ; read a number
0xffff86f8: 2d c0                         #             pushd   %r0                 ; and immediately save it on the stack
0xffff86fa: b1 c4                         #             call    skip_whitespace     ; read to end-of-line (hopefully)
0xffff86fc: b5 4a                         #             call    cur_is_eol          ; check syntax: at the end of line?
0xffff86fe: 47 1f                         #             testh   %r0, -1             ; if not, reject
0xffff8700: 80 14                         #             jz      set_directive_reject
0xffff8702: 2c 38                         #             popd    %r1                 ; pop the number we read to arg 1
0xffff8704: 2c 18                         #             popd    %r0                 ; pop the name we read to arg 0
0xffff8706: ba a8                         #             call    ste_attach_payload  ; attach the value to that name
0xffff8708: 2c 78                         #             popd    %r3
0xffff870a: 2c 58                         #             popd    %r2
0xffff870c: 2c 38                         #             popd    %r1
0xffff870e: 2c 18                         #             popd    %r0
0xffff8710: 2c f8                         #             popd    %ln
0xffff8712: af ee                         #             ret
0xffff8714:                               # set_directive_reject:
0xffff8714: be 58                         #             call    fpsm_reject
0xffff8716:                               # value_directive:
0xffff8716: 2d dc                         #             pushd   %ln
0xffff8718: 09 80                         #             movh    %r4, %r0            ; save byte_size in %r4, which nothing clobbers.
0xffff871a: 8e 04                         #             jmp value_directive_loop    ; enter loop without skipping whitespace
0xffff871c:                               # value_directive_skip_ws:
0xffff871c: b1 a2                         #             call    skip_whitespace
0xffff871e:                               # value_directive_loop:
0xffff871e: b4 f6                         #             call    cur_is_imm_start    ; can cur start an immediate?
0xffff8720: 47 1f                         #             testh   %r0, -1             ; check result
0xffff8722: 80 0a                         #             jz      value_directive_try_name ; if not, try reading a name
0xffff8724: b1 fa                         #             call    read_immediate      ; read an immediate into r0 = arg 0
0xffff8726: 09 30                         #             movh    %r1, %r4            ; arg 1 = byte_size
0xffff8728: bf 98                         #             call    encode_value        ; arg 2 is still static_data
0xffff872a: 9e f2                         #             jmp     value_directive_skip_ws
0xffff872c:                               # value_directive_try_name:
0xffff872c: b4 ba                         #             call    cur_is_alpha        ; can cur start a name?
0xffff872e: 47 1f                         #             testh   %r0, -1             ; check result
0xffff8730: 80 2a                         #             jz      value_directive_try_eol ; if not, ensure we're at EOL
0xffff8732: b2 5e                         #             call    read_name_with_sd   ; we do have &static_data in r2
0xffff8734: 2d d4                         #             pushd   %r5                 ; save cur, fp_get_symbol needs static data in r5
0xffff8736: 29 a8                         #             movd    %r5, %r2            ; setup for fp_get_symbol
0xffff8738: bb 1e                         #             call    fp_get_symbol       ; clobbers %r1 and %r3, which we're not using
0xffff873a: 67 1f                         #             testd   %r0, -1             ; is the entry NULL?
0xffff873c: 80 0e                         #             jz      value_directive_no_entry ; if yes, prepare the relocation.
0xffff873e: ba 86                         #             call    ste_get_payload     ; arg 0 = entry->payload
0xffff8740: 09 30                         #             movh    %r1, %r4            ; arg 1 = byte_size
0xffff8742: 29 54                         #             movd    %r2, %r5            ; arg 2 = &static_data
0xffff8744: 2c b8                         #             popd    %r5                 ; restore cur to r5
0xffff8746: bf 7a                         #             call    encode_value
0xffff8748: 9e d4                         #             jmp     value_directive_skip_ws
0xffff874a:                               # value_directive_no_entry:
0xffff874a: 09 10                         #             movh    %r0, %r4            ; r0 = byte_size
0xffff874c: 42 00                         #             rsubh   %r0, 0              ; arg 0 = 0 - byte_size
0xffff874e: 59 20                         #             mov     %r1, 0              ; arg 1 = 0 [according to the C code, this value shouldn't matter]
0xffff8750: 09 50                         #             movh    %r2, %r4            ; arg 2 = byte_size
0xffff8752: bb fa                         #             call    finalize_encoding_stdcall
0xffff8754: 29 54                         #             movd    %r2, %r5            ; return &static_data to r2
0xffff8756: 2c b8                         #             popd    %r5                 ; restore cur to r5 off the stack
0xffff8758: 9e c4                         #             jmp     value_directive_skip_ws
0xffff875a:                               # value_directive_try_eol:
0xffff875a: b4 ec                         #             call    cur_is_eol          ; is cur end-of-line?
0xffff875c: 47 1f                         #             testh   %r0, -1             ; check result
0xffff875e: 81 04                         #             jnz     value_directive_ret ; if yes, return. yay!
0xffff8760: be 0c                         #             call    fpsm_reject         ; otherwise reject the program.
0xffff8762:                               # value_directive_ret:
0xffff8762: 2c f8                         #             popd    %ln
0xffff8764: af ee                         #             ret
0xffff8766:                               # align_directive:
0xffff8766: 2d dc                         #             pushd   %ln
0xffff8768: b4 ba                         #             call    cur_is_num          ; can cur start a POSITIVE number?
0xffff876a: 47 1f                         #             testh   %r0, -1
0xffff876c: 80 1a                         #             jz      align_directive_reject ; if not, reject the program
0xffff876e: b1 b0                         #             call    read_immediate      ; r0 = byte_size from read_immediate
0xffff8770: 29 60                         #             movd    %r3, %r0            ; move it to r3. Move the full 32-bit value
0xffff8772: b1 4c                         #             call    skip_whitespace     ; skip whitespace after the number
0xffff8774: b4 d2                         #             call    cur_is_eol          ; are we at end-of-line?
0xffff8776: 47 1f                         #             testh   %r0, -1
0xffff8778: 80 0e                         #             jz      align_directive_reject ; if not, reject the program.
0xffff877a: 63 61                         #             cmpd    %r3, 1              ; is byte_size 1?
0xffff877c: 80 0c                         #             je      align_directive_ok  ; if yes, acceptable
0xffff877e: 63 62                         #             cmpd    %r3, 2
0xffff8780: 80 08                         #             je      align_directive_ok  ; 2 is also acceptable
0xffff8782: 63 64                         #             cmpd    %r3, 4
0xffff8784: 80 04                         #             je      align_directive_ok  ; and finally, so is 4.
0xffff8786:                               # align_directive_reject:
0xffff8786: bd e6                         #             call    fpsm_reject
0xffff8788:                               # align_directive_ok:
0xffff8788: 2a 08                         #             ldd     %r0, %r2            ; r0 = ip = static_data->asm_ip
0xffff878a: 20 0c                         #             addd    %r0, %r3            ; ip += byte_size
0xffff878c: 60 1f                         #             addd    %r0, -1             ; ip -= 1
0xffff878e: 42 60                         #             rsubh   %r3, 0              ; -byte_size
0xffff8790: 26 0c                         #             andd    %r0, %r3            ; ip &= -byte_size
0xffff8792: 2b 08                         #             std     %r0, %r2            ; static_data->asm_ip = ip
0xffff8794: 2c f8                         #             popd    %ln
0xffff8796: af ee                         #             ret
0xffff8798:                               # ascii_directive:
0xffff8798: 58 21 5c 22                   #             mov     %r1, 34             ; '"'
0xffff879c: 03 a4                         #             cmph    %r5, %r1            ; is cur '"' ?
0xffff879e: 81 54                         #             jne     ascii_directive_reject ; if not, reject the program
0xffff87a0: 2d dc                         #             pushd   %ln
0xffff87a2: 19 80                         #             mov     %r4, %r0            ; store add_terminator in r4 until we need to check it
0xffff87a4: 2a 68                         #             ldd     %r3, %r2            ; iloc = static_data->asm_ip
0xffff87a6: 8e 38                         #             jmp     ascii_directive_check ; enter the loop, don't assume that the string is empty.
0xffff87a8:                               # ascii_directive_loop:
0xffff87a8: b4 9e                         #             call    cur_is_eol          ; is cur an EOL ?
0xffff87aa: 47 1f                         #             testh   %r0, -1
0xffff87ac: 81 46                         #             jnz     ascii_directive_reject ; if YES, reject the program
0xffff87ae: 58 22 5c 3c                   #             mov     %r1, 92             ; '\'
0xffff87b2: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '\'
0xffff87b4: 81 26                         #             jne     ascii_directive_enc ; if not, encode it directly
0xffff87b6: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar();
0xffff87b8: 03 a4                         #             cmph    %r5, %r1            ; new cur == '\' too?
0xffff87ba: 80 20                         #             je      ascii_directive_enc ; if yes, encode a '\'
0xffff87bc: 58 23 5c 2e                   #             mov     %r1, 110            ; 'n'
0xffff87c0: 03 a4                         #             cmph    %r5, %r1            ; cur ==? 'n'
0xffff87c2: 81 06                         #             jne     ascii_directive_try_q ; if not, try a quote
0xffff87c4: 59 aa                         #             mov     %r5, 10             ; if yes, encode a '\n'
0xffff87c6: 8e 14                         #             jmp     ascii_directive_enc
0xffff87c8:                               # ascii_directive_try_q:
0xffff87c8: 58 21 5c 22                   #             mov     %r1, 34             ; '"'
0xffff87cc: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '"'
0xffff87ce: 80 0c                         #             je      ascii_directive_enc ; if yes, encode a '"'
0xffff87d0: 58 21 5c 30                   #             mov     %r1, 48             ; '0'
0xffff87d4: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '0'
0xffff87d6: 81 1c                         #             jne     ascii_directive_reject ; if it's not, unknown escape! reject the program.
0xffff87d8: 59 a0                         #             mov     %r5, 0              ; but if it is, encode a 0.
0xffff87da:                               # ascii_directive_enc:
0xffff87da: 0b ac                         #             sth     %r5, %r3            ; *iloc = encode
0xffff87dc: 60 61                         #             addd    %r3, 1              ; iloc++
0xffff87de:                               # ascii_directive_check:
0xffff87de: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff87e0: 58 21 5c 22                   #             mov     %r1, 34             ; '"'
0xffff87e4: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '"'
0xffff87e6: 91 c2                         #             jne     ascii_directive_loop ; if not, string is still going, loop.
0xffff87e8: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar(), advance past the closing "
0xffff87ea: b0 d4                         #             call    skip_whitespace     ; read (hopefully) to EOL
0xffff87ec: b4 5a                         #             call    cur_is_eol          ; is cur the EOL?
0xffff87ee: 47 1f                         #             testh   %r0, -1
0xffff87f0: 81 04                         #             jnz     ascii_directive_nul ; if yes, we can proceed to the terminator check
0xffff87f2:                               # ascii_directive_reject:                 ; but if not, reject the program.
0xffff87f2: bd 7a                         #             call    fpsm_reject
0xffff87f4:                               # ascii_directive_nul:
0xffff87f4: 47 9f                         #             testh   %r4, -1             ; should we add a terminator?
0xffff87f6: 80 08                         #             jz      ascii_directive_done; if not, we can clean up.
0xffff87f8: 59 20                         #             mov     %r1, 0
0xffff87fa: 0b 2c                         #             sth     %r1, %r3            ; *iloc = 0
0xffff87fc: 60 61                         #             addd    %r3, 1              ; iloc++
0xffff87fe:                               # ascii_directive_done:
0xffff87fe: 2b 68                         #             std     %r3, %r2            ; static_data->asm_ip = iloc
0xffff8800: 2c f8                         #             popd    %ln
0xffff8802: af ee                         #             ret
0xffff8804:                               # asm_directive:
0xffff8804: 2d c0                         #             pushd   %r0                 ; save directive_name. Easily retrieved with ldd
0xffff8806: 29 68                         #             movd    %r3, %r2            ; %r2 is needed for strncmp calls, save in r3
0xffff8808: b0 2a                         #             call    asm_directive_with_strings
0xffff880a: 73 65 74 00                   #             .asciiz  "set"
0xffff880e: 68 61 6c 66 00                #             .asciiz  "half"
0xffff8813: 77 6f 72 64 00                #             .asciiz  "word"
0xffff8818: 64 77 6f 72 64 00             #             .asciiz  "dword"
0xffff881e: 61 6c 69 67 6e 00             #             .asciiz  "align"
0xffff8824: 61 73 63 69 69 7a 00          #             .asciiz  "asciiz"
0xffff882b: 61 73 63 69 69 00             #             .asciiz  "ascii"
0xffff8831: 00                            # 
0xffff8832:                               # asm_directive_with_strings:
0xffff8832: 29 3c                         #             movd    %r1, %ln            ; now pointer to "set\0" is in r1
0xffff8834: 59 44                         #             mov     %r2, 4              ; compare 4 characters
0xffff8836: be 6a                         #             call    strncmp             ; r0 = 0 if strings are equal
0xffff8838: 81 08                         #             jne     asm_directive_half  ; if unequal, try half
0xffff883a: 29 4c                         #             movd    %r2, %r3            ; restore &static_data
0xffff883c: be 9e                         #             call    set_directive
0xffff883e: 8e 72                         #             jmp     asm_directive_end
0xffff8840:                               # asm_directive_half:
0xffff8840: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8842: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "half\0"
0xffff8844: 59 45                         #             mov     %r2, 5              ; compare 5 characters
0xffff8846: be 5a                         #             call    strncmp
0xffff8848: 81 0a                         #             jne     asm_directive_word  ; if unequal, try word
0xffff884a: 29 4c                         #             movd    %r2, %r3
0xffff884c: 59 01                         #             mov     %r0, 1
0xffff884e: be c8                         #             call    value_directive
0xffff8850: 8e 60                         #             jmp     asm_directive_end
0xffff8852:                               # asm_directive_word:
0xffff8852: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8854: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "word\0"
0xffff8856: 59 45                         #             mov     %r2, 5              ; compare 5 characters
0xffff8858: be 48                         #             call    strncmp
0xffff885a: 81 0a                         #             jne     asm_directive_dword ; if unequal, try dword
0xffff885c: 29 4c                         #             movd    %r2, %r3
0xffff885e: 59 02                         #             mov     %r0, 2
0xffff8860: be b6                         #             call    value_directive
0xffff8862: 8e 4e                         #             jmp     asm_directive_end
0xffff8864:                               # asm_directive_dword:
0xffff8864: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8866: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "dword\0"
0xffff8868: 59 46                         #             mov     %r2, 6              ; compare 6 characters
0xffff886a: be 36                         #             call    strncmp
0xffff886c: 81 0a                         #             jne     asm_directive_align ; if unequal, try align
0xffff886e: 29 4c                         #             movd    %r2, %r3
0xffff8870: 59 04                         #             mov     %r0, 4
0xffff8872: be a4                         #             call    value_directive
0xffff8874: 8e 3c                         #             jmp     asm_directive_end
0xffff8876:                               # asm_directive_align:
0xffff8876: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8878: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "align\0"
0xffff887a: 59 46                         #             mov     %r2, 6              ; compare 6 characters
0xffff887c: be 24                         #             call    strncmp
0xffff887e: 81 08                         #             jne     asm_directive_asciiz; if unequal, try asciiz
0xffff8880: 29 4c                         #             movd    %r2, %r3
0xffff8882: be e4                         #             call    align_directive
0xffff8884: 8e 2c                         #             jmp     asm_directive_end
0xffff8886:                               # asm_directive_asciiz:
0xffff8886: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8888: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "asciiz\0"
0xffff888a: 59 47                         #             mov     %r2, 7              ; compare 7 characters
0xffff888c: be 14                         #             call    strncmp
0xffff888e: 81 0a                         #             jne     asm_directive_ascii ; if unequal, try ascii
0xffff8890: 29 4c                         #             movd    %r2, %r3
0xffff8892: 59 01                         #             mov     %r0, 1              ; do include NUL terminator
0xffff8894: bf 04                         #             call    ascii_directive
0xffff8896: 8e 1a                         #             jmp     asm_directive_end
0xffff8898:                               # asm_directive_ascii:
0xffff8898: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff889a: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "ascii\0"
0xffff889c: 59 46                         #             mov     %r2, 6              ; compare 6 characters
0xffff889e: be 02                         #             call    strncmp
0xffff88a0: 81 0a                         #             jne     asm_directive_reject; if unequal, unknown directive. reject
0xffff88a2: 29 4c                         #             movd    %r2, %r3
0xffff88a4: 59 00                         #             mov     %r0, 0              ; do not include NUL terminator
0xffff88a6: be f2                         #             call    ascii_directive
0xffff88a8: 8e 08                         #             jmp     asm_directive_end
0xffff88aa:                               # asm_directive_reject:
0xffff88aa: 59 07                         #             mov     %r0, 7              ; arg 0 = UNKNOWN_DIRECTIVE
0xffff88ac: 2a 38                         #             ldd     %r1, %sp            ; arg 1 = directive_name
0xffff88ae: b3 bc                         #             call    die                 ; die unknown directive
0xffff88b0:                               # asm_directive_end:
0xffff88b0: 29 08                         #             movd    %r0, %r2            ; &static_data
0xffff88b2: 60 08                         #             addd    %r0, EOL_CHAR_OFS   ; &static_data->eol_char
0xffff88b4: 0b a0                         #             sth     %r5, %r0            ; static_data->eol_char = cur
0xffff88b6: 29 a8                         #             movd    %r5, %r2            ; return &static_data to r5
0xffff88b8: 60 c4                         #             addd    %sp, 4              ; pop directive_name
0xffff88ba: 2c f8                         #             popd    %ln
0xffff88bc: af ee                         #             ret
0xffff88be:                               # skip_whitespace:
0xffff88be: 58 01 5c 00                   #             mov     %r0, 32             ; r0 = ' ' for comparison
0xffff88c2: 8e 04                         #             jmp     skip_whitespace_L2
0xffff88c4:                               # skip_whitespace_L1:
0xffff88c4: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff88c6:                               # skip_whitespace_L2:
0xffff88c6: 03 a0                         #             cmph    %r5, %r0            ; r5 ==? 32
0xffff88c8: 90 fc                         #             je      skip_whitespace_L1
0xffff88ca: 43 a9                         #             cmph    %r5, 9              ; r5 ==? '\t'
0xffff88cc: 90 f8                         #             je      skip_whitespace_L1
0xffff88ce: 58 01 5c 1b                   #             mov     %r0, 59             ; r0 = ';'
0xffff88d2: 03 a0                         #             cmph    %r5, %r0
0xffff88d4: af e1                         #             retne                       ; return if cur != ';'
0xffff88d6: 2d dc                         #             pushd   %ln
0xffff88d8:                               # skip_whitespace_L3:
0xffff88d8: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff88da: b3 6c                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0xffff88dc: 47 1f                         #             testh   %r0, -1             ; test is_eol(cur)
0xffff88de: 90 fa                         #             jz      skip_whitespace_L3  ; loop as long as is_eol(cur) is false
0xffff88e0: 2c f8                         #             popd    %ln
0xffff88e2: af ee                         #             ret
0xffff88e4:                               # read_size:
0xffff88e4: 2d dc                         #             pushd   %ln
0xffff88e6: b3 00                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff88e8: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff88ea: 59 02                         #             mov     %r0, 2              ; set return value for if !is_alpha(cur)
0xffff88ec: 80 22                         #             jz      read_size_ret
0xffff88ee: 58 23 5c 38                   #             mov     %r1, 120            ; r1 = 'x'
0xffff88f2: 01 a4                         #             subh    %r5, %r1            ; cur = cur - 'x'
0xffff88f4: 80 0e                         #             je      read_size_guard
0xffff88f6: 41 b0                         #             subh    %r5, -16            ; cur = cur + ('x' - 'h')
0xffff88f8: 59 00                         #             mov     %r0, 0              ; set return value for cur == 'h'
0xffff88fa: 80 08                         #             je      read_size_guard
0xffff88fc: 40 a4                         #             addh    %r5, 4              ; cur = cur + ('h' - 'd')
0xffff88fe: 59 02                         #             mov     %r0, 2              ; set return value for cur == 'd'
0xffff8900: 81 12                         #             jne     read_size_kill      ; not valid suffix if cur != 'd' at this point
0xffff8902:                               # read_size_guard:
0xffff8902: 2d c0                         #             pushd   %r0                 ; spill return value
0xffff8904: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8906: b3 2a                         #             call    cur_is_alphanum     ; r0 = is_alphanum(cur)
0xffff8908: 47 1f                         #             testh   %r0, -1             ; test is_alphanum(cur)
0xffff890a: 81 08                         #             jnz     read_size_kill      ; crash if cur is alphanumeric
0xffff890c: 2c 18                         #             popd    %r0                 ; reload return value
0xffff890e:                               # read_size_ret:
0xffff890e: 2c f8                         #             popd    %ln
0xffff8910: af ee                         #             ret
0xffff8912:                               # read_size_kill:
0xffff8912: 59 00                         #             mov     %r0, 0              ; r0 = INVALID_SYNTAX_CODE
0xffff8914: b3 56                         #             call    die
0xffff8916:                               # shl_L1:
0xffff8916: 20 00                         #             addd    %r0, %r0        ; x <<= 1
0xffff8918:                               # shl:
0xffff8918: 41 21                         #             subh    %r1, 1          ; --shamt
0xffff891a: 93 fc                         #             jnn     shl_L1          ; exec loop if --shamt >= 0 === shamt > 0
0xffff891c: af ee                         #             ret
0xffff891e:                               # read_immediate:
0xffff891e: 2d c8                         #             pushd   %r2                 ; wind
0xffff8920: 58 01 5c 0d                   #             mov     %r0, 45             ; '-', this mov is 2 instructions
0xffff8924: 58 21 5c 30                   #             mov     %r1, 48             ; '0', this mov is also 2 instructions
0xffff8928: 02 14                         #             rsubh   %r0, %r5            ; r0 = r5 - 45
0xffff892a: 2d c0                         #             pushd   %r0                 ; save the result of this subtraction
0xffff892c: 81 04                         #             jne     read_immediate_radix; if cur was not '-', skip to hex check
0xffff892e: 4a a1                         #             ldh     %r5, STREAM         ; otherwise, read the first number.
0xffff8930:                               # read_immediate_radix:
0xffff8930: 09 14                         #             movh    %r0, %r5            ; imm = cur
0xffff8932: 01 04                         #             subh    %r0, %r1            ; imm -= 48 so imm = cur - '0'
0xffff8934: 4a a1                         #             ldh     %r5, STREAM         ; read next char
0xffff8936: 81 46                         #             jnz     read_immediate_dec_check ; if imm != 0, then old cur != '0', so we don't have hex.
0xffff8938: 58 43 5c 58                   #             mov     %r2, 120            ; 'x'
0xffff893c: 03 a8                         #             cmph    %r5, %r2            ; cur ==? 'x'
0xffff893e: 81 3e                         #             jne     read_immediate_dec_check ; if cur != 'x', we don't have hex.
0xffff8940: 19 44                         #             mov     %r2, %r1            ; hex loop needs r1 to be free, but still wants 48 around.
0xffff8942: 2d dc                         #             pushd   %ln                 ; the hex loop calls shl
0xffff8944: 8e 12                         #             jmp     read_immediate_hex_check 
0xffff8946:                               # read_immediate_hex_letter:
0xffff8946: 40 aa                         #             addh    %r5, 10             ; adjust for 'A' being hex 10
0xffff8948: 59 24                         #             mov     %r1, 4
0xffff894a: bf ce                         #             call    shl
0xffff894c: 20 14                         #             addd    %r0, %r5            ; imm += cur - 'A' + 10
0xffff894e: 8e 08                         #             jmp     read_immediate_hex_check ; continue            
0xffff8950:                               # read_immediate_hex_num:
0xffff8950: 59 24                         #             mov     %r1, 4              ; shift left 4 bits
0xffff8952: bf c6                         #             call    shl                 ; imm <<= 4
0xffff8954: 20 14                         #             addd    %r0, %r5            ; imm += cur - '0'
0xffff8956:                               # read_immediate_hex_check:
0xffff8956: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8958: 01 a8                         #             subh    %r5, %r2            ; cur -= 48
0xffff895a: 43 aa                         #             cmph    %r5, 10             ; cur - '0' <? 10
0xffff895c: 94 f4                         #             jb      read_immediate_hex_num ; if yes, we have a hex number
0xffff895e: 41 ac                         #             subh    %r5, 12             ; cur - 60
0xffff8960: 41 a5                         #             subh    %r5, 5              ; cur - 'A'
0xffff8962: 43 a6                         #             cmph    %r5, 6              ; cur - 'A' <? 6
0xffff8964: 94 e2                         #             jb      read_immediate_hex_letter ; if yes we have a hex letter
0xffff8966: 2c f8                         #             popd    %ln                 ; otherwise we're done. Recover %ln
0xffff8968: 58 22 5c 21                   #             mov     %r1, 65             ; Overwrite 48 with the amount to adjust cur by.
0xffff896c: 8e 16                         #             jmp     read_immediate_negate 
0xffff896e:                               # read_immediate_dec_loop:
0xffff896e: 20 00                         #             addd    %r0, %r0            ; imm *= 2
0xffff8970: 29 40                         #             movd    %r2, %r0            ; immx2 = imm
0xffff8972: 20 00                         #             addd    %r0, %r0            ; imm *= 2 (x4 cumulative)
0xffff8974: 20 00                         #             addd    %r0, %r0            ; imm *= 2 (x8 cumulative)
0xffff8976: 20 08                         #             addd    %r0, %r2            ; imm = imm + immx2 (x10 cumulative)
0xffff8978: 20 14                         #             addd    %r0, %r5            ; imm = imm + cur - 48
0xffff897a: 4a a1                         #             ldh     %r5, STREAM         ; r5 = getchar()
0xffff897c:                               # read_immediate_dec_check:
0xffff897c: 01 a4                         #             subh    %r5, %r1            ; r5 = cur - 48
0xffff897e: 43 aa                         #             cmph    %r5, 10             ; compare (cur - 48) to 10
0xffff8980: 94 ee                         #             jb      read_immediate_dec_loop ; loop if 0 <= (cur - 48) < 10
0xffff8982:                               # read_immediate_negate:
0xffff8982: 00 a4                         #             addh    %r5, %r1            ; r5 = cur (previously, r5 was adjusted and r1 held the adjustment)
0xffff8984: 2c 38                         #             popd    %r1                 ; retrieve the comparison of initial cur to '-'
0xffff8986: 2c 58                         #             popd    %r2                 ; unwind stack
0xffff8988: 47 3f                         #             testh   %r1, -1             ; test the result of that comparison, zero means equal
0xffff898a: af e1                         #             retnz                       ; if it wasn't equal, we're done
0xffff898c: 62 00                         #             rsubd   %r0, 0              ; otherwise, imm = -imm
0xffff898e: af ee                         #             ret                         ; and now we're done.
0xffff8990:                               # read_name_with_sd:
0xffff8990: 2d c8                         #             pushd   %r2
0xffff8992: 8e 12                         #             jmp     read_name_have_sd
0xffff8994:                               # read_name:
0xffff8994: 2d c8                         #             pushd   %r2
0xffff8996: 69 5e 6c 40 6c 40 6c 40 6c 40 6c 40 6c 4c#             mov     %r2, STATIC_DATA_PTR
0xffff89a4:                               # read_name_have_sd:
0xffff89a4: 2d dc                         #             pushd   %ln
0xffff89a6: 2d cc                         #             pushd   %r3                 ; get a free register so we can save original buffer
0xffff89a8: 60 44                         #             addd    %r2, HEAP_LIMIT_OFS ; &static_data->heap_limit
0xffff89aa: 2a 48                         #             ldd     %r2, %r2            ; static_data->heap_limit
0xffff89ac: 60 48                         #             addd    %r2, 8              ; static_data->heap_limit + offsetof(table_entry_t, symbol)
0xffff89ae: 29 68                         #             movd    %r3, %r2            ; save original buffer
0xffff89b0:                               # read_name_L1:
0xffff89b0: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0xffff89b2: 60 41                         #             addd    %r2, 1              ; buffer++
0xffff89b4: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff89b6: b2 7a                         #             call    cur_is_name_char    ; r0 = is cur a valid name char?
0xffff89b8: 57 1f                         #             test    %r0, -1             ; check result
0xffff89ba: 91 f6                         #             jnz     read_name_L1        ; if cur is valid, loop
0xffff89bc: 59 00                         #             mov     %r0, 0              ; r0 = \NUL
0xffff89be: 0b 08                         #             sth     %r0, %r2            ; *buffer = \NUL
0xffff89c0: 29 0c                         #             movd    %r0, %r3            ; restore original buffer
0xffff89c2: 2c 78                         #             popd    %r3
0xffff89c4: 2c f8                         #             popd    %ln
0xffff89c6: 2c 58                         #             popd    %r2                 ; we wound in a weird order, undo that
0xffff89c8: af ee                         #             ret
0xffff89ca:                               # read_any_register:
0xffff89ca: 2d dc                         #             pushd   %ln
0xffff89cc: b0 74                         #             call    read_any_register_actual ; put &register_table in %ln
0xffff89ce:                               # register_table:
0xffff89ce: 61 30                         #             .ascii  "a0"
0xffff89d0: 00 00 f0 8d                   #             .word   0 empty_str&0xFFFF
0xffff89d4: 61 31                         #             .ascii  "a1"
0xffff89d6: 01 00 f0 8d                   #             .word   1 empty_str&0xFFFF
0xffff89da: 61 32                         #             .ascii  "a2"
0xffff89dc: 02 00 f0 8d                   #             .word   2 empty_str&0xFFFF
0xffff89e0: 73 30                         #             .ascii  "s0"
0xffff89e2: 03 00 f0 8d                   #             .word   3 empty_str&0xFFFF
0xffff89e6: 73 31                         #             .ascii  "s1"
0xffff89e8: 04 00 f0 8d                   #             .word   4 empty_str&0xFFFF
0xffff89ec: 62 70                         #             .ascii  "bp"
0xffff89ee: 05 00 f0 8d                   #             .word   5 empty_str&0xFFFF
0xffff89f2: 73 70                         #             .ascii  "sp"
0xffff89f4: 06 00 f0 8d                   #             .word   6 empty_str&0xFFFF
0xffff89f8: 6c 6e                         #             .ascii  "ln"
0xffff89fa: 07 00 f0 8d                   #             .word   7 empty_str&0xFFFF
0xffff89fe: 72 30                         #             .ascii  "r0"
0xffff8a00: 00 00 f0 8d                   #             .word   0 empty_str&0xFFFF
0xffff8a04: 72 31                         #             .ascii  "r1"
0xffff8a06: 01 00 f0 8d                   #             .word   1 empty_str&0xFFFF
0xffff8a0a: 72 32                         #             .ascii  "r2"
0xffff8a0c: 02 00 f0 8d                   #             .word   2 empty_str&0xFFFF
0xffff8a10: 72 33                         #             .ascii  "r3"
0xffff8a12: 03 00 f0 8d                   #             .word   3 empty_str&0xFFFF
0xffff8a16: 72 34                         #             .ascii  "r4"
0xffff8a18: 04 00 f0 8d                   #             .word   4 empty_str&0xFFFF
0xffff8a1c: 72 35                         #             .ascii  "r5"
0xffff8a1e: 05 00 f0 8d                   #             .word   5 empty_str&0xFFFF
0xffff8a22: 72 36                         #             .ascii  "r6"
0xffff8a24: 06 00 f0 8d                   #             .word   6 empty_str&0xFFFF
0xffff8a28: 72 37                         #             .ascii  "r7"
0xffff8a2a: 07 00 f0 8d                   #             .word   7 empty_str&0xFFFF
0xffff8a2e: 63 31                         #             .ascii  "c1"
0xffff8a30: 08 00 80 8e                   #             .word   8 id_str&0xFFFF
0xffff8a34: 63 32                         #             .ascii  "c2"
0xffff8a36: 09 00 80 8e                   #             .word   9 id_str&0xFFFF
0xffff8a3a: 66 65                         #             .ascii  "fe"
0xffff8a3c: 0a 00 83 8e                   #             .word   10 at_str&0xFFFF
0xffff8a40:                               # read_any_register_actual:
0xffff8a40: 2d c8                         #             pushd   %r2
0xffff8a42: 2d cc                         #             pushd   %r3
0xffff8a44: 2d d0                         #             pushd   %r4                 ; wind the stack (%ln already pushed)
0xffff8a46: 58 61 5c 60                   #             mov     %r3, BUFFER_PTR     ; r3 = buffer
0xffff8a4a: 4a 01                         #             ldh     %r0, STREAM
0xffff8a4c: 0b 0c                         #             sth     %r0, %r3            ; *buffer = getchar()
0xffff8a4e: 60 61                         #             addd    %r3, 1
0xffff8a50: 4a 01                         #             ldh     %r0, STREAM
0xffff8a52: 0b 0c                         #             sth     %r0, %r3            ; *(buffer + 1) = getchar()
0xffff8a54: 61 61                         #             subd    %r3, 1              ; r3 = buffer, once again
0xffff8a56: 58 b2                         #             movz    %r5, 18             ; i = 18
0xffff8a58: 29 9c                         #             movd    %r4, %r7            ; r7 previously held &register_table
0xffff8a5a:                               # read_any_register_L1:
0xffff8a5a: 29 0c                         #             movd    %r0, %r3            ; arg0 = buffer
0xffff8a5c: 29 30                         #             movd    %r1, %r4            ; arg1 = register_table[18-i].name
0xffff8a5e: 69 42                         #             movd    %r2, 2              ; arg2 = 2
0xffff8a60: bc 40                         #             call    strncmp             ; r0 = 0 iff string at buffer == string at name
0xffff8a62: 47 1f                         #             testh   %r0, -1             ; is r0 == 0?
0xffff8a64: 80 0c                         #             jz      read_any_register_L3; found match! break out of loop
0xffff8a66: 60 86                         #             addd    %r4, 6              ; point r4 at next register table entry
0xffff8a68: 41 a1                         #             subh    %r5, 1              ; --i
0xffff8a6a: 9b f0                         #             jge     read_any_register_L1; loop as long as i is still >= 0
0xffff8a6c:                               # read_any_register_L2:                   ; but if i < 0, there were no matches. Die.
0xffff8a6c: 59 01                         #             mov     %r0, 1              ; r0 = INVALID_REGISTER_CODE
0xffff8a6e: b1 fc                         #             call    die
0xffff8a70:                               # read_any_register_L3:
0xffff8a70: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar() [in the C code, this is above the loop]
0xffff8a72: 60 84                         #             addd    %r4, 4              ; point r4 at entry.remainder_to_consume
0xffff8a74: 1a 30                         #             ldx     %r1, %r4            ; r1 = entry->remainder_to_consume
0xffff8a76: b0 3a                         #             call    consume             ; r0 = 0 iff consume succeeds
0xffff8a78: 47 1f                         #             testh   %r0, -1             ; is r0 == 0?
0xffff8a7a: 91 f2                         #             jnz     read_any_register_L2; call die(INVALID_REGISTER) if consume failed
0xffff8a7c: b1 b4                         #             call    cur_is_alphanum     ; r0 = is_alphanum(cur)
0xffff8a7e: 47 1f                         #             testh   %r0, -1             ; is r0 != 0?
0xffff8a80: 91 ec                         #             jnz     read_any_register_L2; call die(INVALID_REGISTER) if is_alphanum(cur)
0xffff8a82: 61 82                         #             subd    %r4, 2              ; point r4 at entry.number
0xffff8a84: 1a 10                         #             ldx     %r0, %r4            ; return = entry->number
0xffff8a86: 2c 98                         #             popd    %r4
0xffff8a88: 2c 78                         #             popd    %r3
0xffff8a8a: 2c 58                         #             popd    %r2                 ; unwind
0xffff8a8c: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8a8e: af ee                         #             ret
0xffff8a90:                               # read_register:
0xffff8a90: 2d dc                         #             pushd   %ln
0xffff8a92: bf 38                         #             call    read_any_register
0xffff8a94: 2c f8                         #             popd    %ln
0xffff8a96: 43 08                         #             cmph    %r0, 8
0xffff8a98: af ea                         #             retl                        ; return reg if it's < 8
0xffff8a9a: 9e d2                         #             jmp     read_any_register_L2; otherwise, call die(INVALID_REGISTER)
0xffff8a9c:                               # read_ctrl_register:
0xffff8a9c: 2d dc                         #             pushd   %ln
0xffff8a9e: bf 2c                         #             call    read_any_register
0xffff8aa0: 2c f8                         #             popd    %ln
0xffff8aa2: 43 08                         #             cmph    %r0, 8
0xffff8aa4: af eb                         #             retge                       ; return reg if it's >= 8
0xffff8aa6: 9e c6                         #             jmp     read_any_register_L2; otherwise, call die as above
0xffff8aa8:                               # consume_L1:
0xffff8aa8: 02 14                         #             rsubh   %r0, %r5            ; r0 = *check - cur
0xffff8aaa: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8aac: af e1                         #             retnz                       ; if match failed, return result
0xffff8aae: 60 21                         #             addd    %r1, 1              ; ++check
0xffff8ab0:                               # consume:
0xffff8ab0: 0a 04                         #             ldh     %r0, %r1            ; r0 = *check
0xffff8ab2: 47 1f                         #             testh   %r0, -1             ; *check == 0?
0xffff8ab4: 91 f4                         #             jnz     consume_L1          ; loop if *check != 0
0xffff8ab6: af ee                         #             ret                         ; otherwise, return *check === 0
0xffff8ab8:                               # match:
0xffff8ab8: 02 14                         #     rsubh   %r0, %r5                    ; r0 = cur - c
0xffff8aba: 4a a1                         #     ldh     %r5, STREAM                 ; cur = getchar()
0xffff8abc: af ee                         #     ret
0xffff8abe:                               # read_opcode:
0xffff8abe: 2d dc                         #             pushd   %ln
0xffff8ac0: 2d c8                         #             pushd   %r2
0xffff8ac2: 2d cc                         #             pushd   %r3
0xffff8ac4: 2d d0                         #             pushd   %r4
0xffff8ac6: 59 00                         #             mov     %r0, 0              ; r.opcode = 0
0xffff8ac8: 59 23                         #             mov     %r1, 3              ; r.state = STATE_TX
0xffff8aca: 58 41 5c 40                   #             mov     %r2, BUFFER_PTR     ; r2 = buffer
0xffff8ace: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0xffff8ad0: 09 74                         #             movh    %r3, %r5            ; temporarily stash cur in r3
0xffff8ad2: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8ad4: 60 41                         #             addd    %r2, 1              ; ++buffer
0xffff8ad6: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0xffff8ad8: 58 83 5c 8a                   #             mov     %r4, 106            ; r4 = 'j' === 106
0xffff8adc: 03 70                         #             cmph    %r3, %r4            ; check if original cur was 'j'
0xffff8ade: 59 80                         #             mov     %r4, 0              ; trigger = HIT_J === 0
0xffff8ae0: 80 96                         #             je      read_opcode_cond    ; jump to the cond part if so
0xffff8ae2: 59 62                         #             mov     %r3, 2              ; size = 2
0xffff8ae4: 59 82                         #             mov     %r4, 2              ; count = 2
0xffff8ae6: 69 bf 6c a3 6c b4 6c a7       #             mov     %r5, opcode_tables  ; r5 = pointer to opcode tables
0xffff8aee:                               # read_opcode_sloop:
0xffff8aee: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buffer
0xffff8af2: 29 34                         #             movd    %r1, %r5            ; arg 1 = &table{2/3}[ix].name
0xffff8af4: 19 4c                         #             mov     %r2, %r3            ; arg 2 = size
0xffff8af6: bb aa                         #             call    strncmp             ; r0 = (0 iff hit table)
0xffff8af8: 47 1f                         #             testh   %r0, -1             ; test for hit
0xffff8afa: 81 0c                         #             jnz     read_opcode_sstep   ; if not a hit, go to next step
0xffff8afc: 61 a1                         #             subd    %r5, 1              ; r5 = &table{2/3}[ix].opcode
0xffff8afe: 0a 14                         #             ldh     %r0, %r5            ; r.opcode = table{2/3}[ix].opcode
0xffff8b00: 59 25                         #             mov     %r1, 5              ; r.state = STATE_COMP
0xffff8b02: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8b04: 8e c6                         #             jmp     read_opcode_unwind  ; return
0xffff8b06:                               # read_opcode_sstep:
0xffff8b06: 20 ac                         #             addd    %r5, %r3            ; tableptr += size
0xffff8b08: 60 a1                         #             addd    %r5, 1              ; tableptr += 1 [shift past next opcode]
0xffff8b0a: 41 81                         #             subh    %r4, 1              ; --count
0xffff8b0c: 9b e2                         #             jge     read_opcode_sloop   ; loop if count still >= 0
0xffff8b0e: 43 62                         #             cmph    %r3, 2              ; check if size was 2 on that iteration
0xffff8b10: 59 84                         #             mov     %r4, 4              ; count = 4, size is "still" 3 (it's from the future)
0xffff8b12: 81 30                         #             jne     read_opcode_big     ; if not, stop the short loop
0xffff8b14: 59 63                         #             mov     %r3, 3              ; size = 3
0xffff8b16: 59 85                         #             mov     %r4, 5              ; count = 5
0xffff8b18: 58 01 5c 02                   #             mov     %r0, BUFFER_PTR+2   ; r0 = buffer + 2 (probably 34, if trying to self-host)
0xffff8b1c: 4a 41                         #             ldh     %r2, STREAM         ; r2 = getchar()
0xffff8b1e: 0b 40                         #             sth     %r2, %r0            ; *(buffer + 2) = r2
0xffff8b20: 9e ce                         #             jmp     read_opcode_sloop   ; continue checking short opcodes
0xffff8b22:                               # read_opcode_bstep:
0xffff8b22: 20 ac                         #             addd    %r5, %r3            ; tableptr += size
0xffff8b24: 60 a3                         #             addd    %r5, 3              ; tableptr += 3 [shift past opcode,state,trigger]
0xffff8b26: 41 81                         #             subh    %r4, 1              ; --count
0xffff8b28: 8b 20                         #             jge     read_opcode_bloop   ; loop now, if count still >= 0
0xffff8b2a: 2c 58                         #             popd    %r2                 ; reload spilled cur into %r2
0xffff8b2c: 43 63                         #             cmph    %r3, 3              ; was size still 3 on that iteration?
0xffff8b2e: 81 8e                         #             jne     read_opcode_die     ; if not, we're out of things to check. Die.
0xffff8b30:                               # read_opcode_try4:
0xffff8b30: 58 01 5c 03                   #             mov     %r0, BUFFER_PTR+3   ; r0 = buffer + 3 (probably 35, if trying to self-host)
0xffff8b34: 0b 40                         #             sth     %r2, %r0            ; *(buffer + 3) = cur
0xffff8b36: 59 64                         #             mov     %r3, 4              ; size = 4
0xffff8b38: 59 85                         #             mov     %r4, 5              ; count = 5
0xffff8b3a: 69 bf 6c a3 6c b6 6c a6       #             mov     %r5, opcode_table4_state
0xffff8b42:                               # read_opcode_big:                        ; before jumping here, count was set to {4/5}
0xffff8b42: 4a 41                         #             ldh     %r2, STREAM         ; get another character...
0xffff8b44: 2d c8                         #             pushd   %r2                 ; and spill it, because we still need the table
0xffff8b46: 60 a2                         #             addd    %r5, 2              ; was pointed at state, move it to name
0xffff8b48:                               # read_opcode_bloop:
0xffff8b48: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buffer
0xffff8b4c: 29 34                         #             movd    %r1, %r5            ; arg 1 = &table{3/4}[ix].name
0xffff8b4e: 19 4c                         #             mov     %r2, %r3            ; arg 2 = size
0xffff8b50: bb 50                         #             call    strncmp             ; r0 = (0 iff hit table)
0xffff8b52: 47 1f                         #             testh   %r0, -1             ; test for hit
0xffff8b54: 91 ce                         #             jnz     read_opcode_bstep   ; if no hit, go to next iteration
0xffff8b56: 2c 58                         #             popd    %r2                 ; retrieve cur, which we spilled
0xffff8b58: 61 a1                         #             subd    %r5, 1              ; move pointer to trigger
0xffff8b5a: 0a 94                         #             ldh     %r4, %r5            ; trigger = table[ix].trigger
0xffff8b5c: 43 82                         #             cmph    %r4, 2              ; trigger == HIT_MOV?
0xffff8b5e: 81 0a                         #             jne     read_opcode_chkcond ; if it's not, try checking if it's HIT_COND
0xffff8b60: 09 08                         #             movh    %r0, %r2            ; but if it is, check cur (which we reloaded to r2)
0xffff8b62: b0 f2                         #             call    is_not_opcode_suffix
0xffff8b64: 47 1f                         #             testh   %r0, -1             ; test !is_opcode_suffix(cur)
0xffff8b66: 91 ca                         #             jnz     read_opcode_try4    ; if holds, skip to trying length-4 names
0xffff8b68:                               # read_opcode_chkcond:
0xffff8b68: 61 a2                         #             subd    %r5, 2              ; move pointer from trigger to opcode
0xffff8b6a: 0a 14                         #             ldh     %r0, %r5            ; r.opcode = table[ix].opcode
0xffff8b6c: 60 a1                         #             addd    %r5, 1              ; move pointer from opcode to state
0xffff8b6e: 0a 34                         #             ldh     %r1, %r5            ; r.state  = table[ix].state
0xffff8b70: 09 a8                         #             movh    %r5, %r2            ; restore cur to r5 from r2 (where it was reloaded)
0xffff8b72: 43 81                         #             cmph    %r4, 1              ; trigger == HIT_COND?
0xffff8b74: 81 56                         #             jne     read_opcode_unwind  ; if no, go to stack unwind and return
0xffff8b76:                               # read_opcode_cond:
0xffff8b76: 1d c4                         #             pushx   %r1                 ; spill r.state  (two spills, so x is fine)
0xffff8b78: 1d c0                         #             pushx   %r0                 ; spill r.opcode
0xffff8b7a: 59 42                         #             mov     %r2, 2              ; i = 2
0xffff8b7c: 58 61 5c 60                   #             mov     %r3, BUFFER_PTR     ; r3 = buffer
0xffff8b80:                               # read_opcode_bfrcond:
0xffff8b80: b0 d2                         #             call    cur_is_not_opcode_suffix
0xffff8b82: 47 1f                         #             testh   %r0, -1             ; test !is_opcode_suffix(cur)
0xffff8b84: 80 0c                         #             jz      read_opcode_condtbl ; if it doesn't hold (cur is an opcode suffix)
0xffff8b86: 0b ac                         #             sth     %r5, %r3            ; *buffer = cur
0xffff8b88: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8b8a: 60 61                         #             addd    %r3, 1              ; ++buffer
0xffff8b8c: 41 41                         #             subh    %r2, 1              ; --i
0xffff8b8e: 9d f2                         #             jg      read_opcode_bfrcond ; continue buffering if i > 0
0xffff8b90:                               # read_opcode_condtbl:
0xffff8b90: 59 40                         #             mov     %r2, 0              ; clear r2
0xffff8b92: 0b 4c                         #             sth     %r2, %r3            ; *buffer = 0
0xffff8b94: 69 7f 6c 63 6c 77 6c 70       #             mov     %r3, cond_table_name ; get pointer to cond_table[0].name in r3
0xffff8b9c: 19 50                         #             mov     %r2, %r4            ; r2 = trigger
0xffff8b9e: 00 48                         #             addh    %r2, %r2            ; r2 = trigger * 2
0xffff8ba0: 00 48                         #             addh    %r2, %r2            ; r2 = trigger * 4
0xffff8ba2: 20 68                         #             addd    %r3, %r2            ; r3 = cond_table[trigger].name
0xffff8ba4: 58 54                         #             movz    %r2, 20
0xffff8ba6: 02 88                         #             rsubh   %r4, %r2            ; trigger = 20 - trigger
0xffff8ba8:                               # read_opcode_cndloop:
0xffff8ba8: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buffer
0xffff8bac: 29 2c                         #             movd    %r1, %r3            ; arg 1 = cond_table[ix].name
0xffff8bae: 59 43                         #             mov     %r2, 3              ; arg 2 = 3
0xffff8bb0: ba f0                         #             call    strncmp             ; r0 = (0 iff hit table)
0xffff8bb2: 47 1f                         #             testh   %r0, -1             ; test if hit
0xffff8bb4: 80 0c                         #             jz      read_opcode_hitcond ; if we hit, go leave (finally)
0xffff8bb6: 60 64                         #             addd    %r3, 4              ; otherwise, move to next cond table entry
0xffff8bb8: 41 81                         #             subh    %r4, 1              ; --trigger
0xffff8bba: 9d ee                         #             jg      read_opcode_cndloop ; continue looping if trigger > 0
0xffff8bbc:                               # read_opcode_die:
0xffff8bbc: 59 00                         #             mov     %r0, 0
0xffff8bbe: b0 ac                         #             call    die                 ; otherwise, we are out of options. Die.
0xffff8bc0:                               # read_opcode_hitcond:
0xffff8bc0: 1c 18                         #             popx    %r0                 ; reload r.opcode (two spills, both pushx)
0xffff8bc2: 1c 38                         #             popx    %r1                 ; reload r.state
0xffff8bc4: 61 61                         #             subd    %r3, 1              ; move back from name to opcode
0xffff8bc6: 0a 6c                         #             ldh     %r3, %r3            ; read in the opcode
0xffff8bc8: 00 0c                         #             addh    %r0, %r3            ; r.opcode += cond_table[hit].opcode
0xffff8bca:                               # read_opcode_unwind:
0xffff8bca: 2c 98                         #             popd    %r4
0xffff8bcc: 2c 78                         #             popd    %r3
0xffff8bce: 2c 58                         #             popd    %r2
0xffff8bd0: 2c f8                         #             popd    %ln
0xffff8bd2: af ee                         #             ret
0xffff8bd4:                               # validate_s5:
0xffff8bd4: 2d c0                         #             pushd   %r0
0xffff8bd6: 2d c4                         #             pushd   %r1
0xffff8bd8: 58 30                         #             movz    %r1, 16
0xffff8bda: 20 04                         #             addd    %r0, %r1            ; imm + 16
0xffff8bdc: 10 24                         #             addx    %r1, %r1            ; r1 = 32
0xffff8bde: 23 04                         #             cmpd    %r0, %r1            ; compare (imm + 16) against 32
0xffff8be0: 2c 38                         #             popd    %r1                 ; if 0 <= (imm + 16) < 32, then imm
0xffff8be2: 2c 18                         #             popd    %r0                 ; is a valid s5 immediate. The compare
0xffff8be4: af ee                         #             ret                         ; will set the 'b' condition if so.
0xffff8be6:                               # cur_is_alpha:
0xffff8be6: 19 14                         #             mov     %r0, %r5
0xffff8be8:                               # is_alpha:
0xffff8be8: 58 22 5c 21                   #             mov     %r1, 65             ; r1 = 'A'
0xffff8bec: 03 04                         #             cmph    %r0, %r1
0xffff8bee: 84 1e                         #             jb      is_alpha_ret_false  ; return false if r0 < 'A'
0xffff8bf0: 40 2f                         #             addh    %r1, 15
0xffff8bf2: 40 2a                         #             addh    %r1, 10             ; r1 = 'Z'
0xffff8bf4: 03 04                         #             cmph    %r0, %r1            ; c <=? 'Z'
0xffff8bf6: 88 1a                         #             jbe     is_alpha_ret_true
0xffff8bf8: 40 25                         #             addh    %r1, 5              ; r1 = '_'
0xffff8bfa: 03 04                         #             cmph    %r0, %r1            ; c ==? '_'
0xffff8bfc: 80 14                         #             je      is_alpha_ret_true
0xffff8bfe: 40 22                         #             addh    %r1, 2              ; r1 = 'a'
0xffff8c00: 03 04                         #             cmph    %r0, %r1            ; c <? 'a'
0xffff8c02: 84 0a                         #             jb      is_alpha_ret_false
0xffff8c04: 40 2f                         #             addh    %r1, 15
0xffff8c06: 40 2a                         #             addh    %r1, 10             ; r1 = 'z'
0xffff8c08: 03 04                         #             cmph    %r0, %r1            ; c <=? 'z'
0xffff8c0a: 88 06                         #             jbe     is_alpha_ret_true   ; fall through to ret_true otherwise
0xffff8c0c:                               # is_eol_ret_false:
0xffff8c0c:                               # is_num_ret_false:
0xffff8c0c:                               # is_alpha_ret_false:
0xffff8c0c: 59 00                         #             mov     %r0, 0
0xffff8c0e: af ee                         #             ret
0xffff8c10:                               # is_eol_ret_true:
0xffff8c10:                               # is_num_ret_true:
0xffff8c10:                               # is_alpha_ret_true:
0xffff8c10:                               # is_imm_start_ret_true:
0xffff8c10: 59 01                         #             mov     %r0, 1
0xffff8c12: af ee                         #             ret
0xffff8c14:                               # cur_is_imm_start:
0xffff8c14: 19 14                         #             mov     %r0, %r5
0xffff8c16:                               # is_imm_start:
0xffff8c16: 58 21 5c 2d                   #             mov     %r1, 45             ; '-' for comparison
0xffff8c1a: 03 04                         #             cmph    %r0, %r1            ; c ==? '-'
0xffff8c1c: 90 f4                         #             je      is_imm_start_ret_true
0xffff8c1e: 40 23                         #             addh    %r1, 3              ; r1 = '0'
0xffff8c20: 8e 08                         #             jmp     is_num_have_48      ; this entrypoint is less common
0xffff8c22:                               # cur_is_num:
0xffff8c22: 19 14                         #             mov     %r0, %r5
0xffff8c24:                               # is_num:
0xffff8c24: 58 21 5c 30                   #             mov     %r1, 48             ; '0' prep going in
0xffff8c28:                               # is_num_have_48:
0xffff8c28: 01 04                         #             subh    %r0, %r1            ; c = c - '0'
0xffff8c2a: 43 0a                         #             cmph    %r0, 10             ; c <? '9'+1
0xffff8c2c: 94 e4                         #             jb      is_num_ret_true
0xffff8c2e: 9e de                         #             jmp     is_num_ret_false
0xffff8c30:                               # cur_is_alphanum:
0xffff8c30:                               # cur_is_name_char:
0xffff8c30: 19 14                         #             mov     %r0, %r5
0xffff8c32:                               # is_alphanum:
0xffff8c32:                               # is_name_char:
0xffff8c32: 2d dc                         #             pushd   %ln                 ; we call functions, save %ln
0xffff8c34: 2d c0                         #             pushd   %r0                 ; save c
0xffff8c36: bf b2                         #             call    is_alpha            ; r0 = is_alpha(c)
0xffff8c38: 47 01                         #             testh   %r0, 1              ; test is_alpha(c)
0xffff8c3a: 2c 38                         #             popd    %r1                 ; r1 = c
0xffff8c3c: 81 06                         #             jnz     is_name_char_ret    ; return if is_alpha(c)
0xffff8c3e: 09 04                         #             movh    %r0, %r1            ; r0 = c
0xffff8c40: bf e4                         #             call    is_num              ; r0 = is_num(c)
0xffff8c42:                               # is_name_char_ret:
0xffff8c42: 2c f8                         #             popd    %ln
0xffff8c44: af ee                         #             ret
0xffff8c46:                               # cur_is_eol:
0xffff8c46: 19 14                         #             mov     %r0, %r5
0xffff8c48:                               # is_eol:
0xffff8c48: 43 0a                         #             cmph    %r0, 10             ; c ==? '\n'
0xffff8c4a: 90 c6                         #             je      is_eol_ret_true
0xffff8c4c: 43 00                         #             cmph    %r0, 0              ; c ==? '\0'
0xffff8c4e: 90 c2                         #             je      is_eol_ret_true
0xffff8c50: 9e bc                         #             jmp     is_eol_ret_false
0xffff8c52:                               # cur_is_not_opcode_suffix:
0xffff8c52: 19 14                         #             mov     %r0, %r5
0xffff8c54:                               # is_not_opcode_suffix:
0xffff8c54: 19 20                         #             mov     %r1, %r0            ; swap registers
0xffff8c56: 58 03 5c 18                   #             mov     %r0, 120            ; r0 = 'x' = 120
0xffff8c5a: 02 04                         #             rsubh   %r0, %r1            ; r0 = c - 'x'
0xffff8c5c: af e0                         #             retz                        ; if 0, c == 'x' which is valid, return 0
0xffff8c5e: 41 10                         #             subh    %r0, -16            ; r0 = (c - 'x') - ('h' - 'x') === c - 'h'
0xffff8c60: af e0                         #             retz                        ; same, but == 'h'
0xffff8c62: 40 04                         #             addh    %r0, 4              ; r0 = (c - 'h') + ('h' - 'd') === c - 'd'
0xffff8c64: af e0                         #             retz                        ; same, but == 'd'
0xffff8c66: 19 04                         #             mov     %r0, %r1            ; r0 = c
0xffff8c68: 9e 80                         #             jmp     is_alpha            ; tail-call is_alpha. Our return sense is inverted,
0xffff8c6a:                               # die:
0xffff8c6a: b0 22                         #             call    die_actual          ; %r7 = &msg_header
0xffff8c6c:                               # msg_header:                             ; char **msg_header
0xffff8c6c: e8 8d                         #             .word   invalid_msg &0xFFFF
0xffff8c6e: e8 8d                         #             .word   invalid_msg &0xFFFF
0xffff8c70: e8 8d                         #             .word   invalid_msg &0xFFFF
0xffff8c72: f1 8d                         #             .word   out_of_msg  &0xFFFF
0xffff8c74: f1 8d                         #             .word   out_of_msg  &0xFFFF
0xffff8c76: f0 8d                         #             .word   empty_msg   &0xFFFF
0xffff8c78: 20 8e                         #             .word   unknown_msg &0xFFFF
0xffff8c7a: 20 8e                         #             .word   unknown_msg &0xFFFF
0xffff8c7c:                               # msg_body:                               ; char **msg_body
0xffff8c7c: f9 8d                         #             .word   syntax_msg    &0xFFFF
0xffff8c7e: 00 8e                         #             .word   register_msg  &0xFFFF
0xffff8c80: 09 8e                         #             .word   immediate_msg &0xFFFF
0xffff8c82: 13 8e                         #             .word   range_msg     &0xFFFF
0xffff8c84: 19 8e                         #             .word   memory_msg    &0xFFFF
0xffff8c86: 3c 8e                         #             .word   missing_features_msg &0xFFFF
0xffff8c88: 29 8e                         #             .word   symbol_msg    &0xFFFF
0xffff8c8a: 31 8e                         #             .word   directive_msg &0xFFFF
0xffff8c8c:                               # die_actual:
0xffff8c8c: 29 44                         #             movd    %r2, %r1            ; save name in r2 which is stable (r1 is not)
0xffff8c8e: 29 bc                         #             movd    %r5, %r7            ; save &msg_header
0xffff8c90: 00 00                         #             addh    %r0, %r0            ; ofs = code << 1
0xffff8c92: 20 1c                         #             addd    %r0, %r7            ; r0 = &(msg_header[code])
0xffff8c94: 29 60                         #             movd    %r3, %r0            ; save &(msg_header[code]) for later
0xffff8c96: 1a 00                         #             ldx     %r0, %r0            ; r0 = msg_header[code] (ldx sign-extends so we get the right ptr)
0xffff8c98: b0 a8                         #             call    puts                ; puts(msg_header[code])
0xffff8c9a: 29 0c                         #             movd    %r0, %r3            ; retrieve &msg_header[code]
0xffff8c9c: 60 08                         #             addd    %r0, 8              ; r0 = &msg_body[code]
0xffff8c9e: 60 08                         #             addd    %r0, 8              ; which is &msg_header[code] + 16
0xffff8ca0: 1a 00                         #             ldx     %r0, %r0            ; r0 = msg_body[code]   (ldx sign-extends so we get the right ptr)
0xffff8ca2: b0 9e                         #             call    puts                ; puts(msg_body[code])   additionally r1 = 0
0xffff8ca4: 21 74                         #             subd    %r3, %r5            ; r3 = &msg_header[code] - msg_header, eqv. 2*code
0xffff8ca6: 53 6a                         #             cmpx    %r3, 10             ; compare 2*code against 10
0xffff8ca8: 8c 06                         #             jle     die_line            ; if 2*code <= 10, we're done and can print line and halt
0xffff8caa: 29 08                         #             movd    %r0, %r2            ; move name to argument 0 (it was saved in r2 and is untouched)
0xffff8cac: b0 94                         #             call    puts                ; puts(name)
0xffff8cae:                               # die_line:
0xffff8cae: b0 0c                         #             call    die_line_with_msg
0xffff8cb0: 20 61 74 20 6c 69 6e 65 20 00 #             .asciiz " at line "
0xffff8cba:                               # die_line_with_msg:
0xffff8cba: 29 1c                         #             movd    %r0, %ln
0xffff8cbc: b0 84                         #             call    puts                ; print " at line "
0xffff8cbe: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buf
0xffff8cc2: 59 50 5c 40 5c 4a             #             mov     %r2, 0xC00A         ; &static_data.src_lineno
0xffff8cc8: 1a 48                         #             ldx     %r2, %r2            ; arg 2 = static_data->src_lineno
0xffff8cca: b0 38                         #             call    utoa                ; convert lineno to string in buffer
0xffff8ccc: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buf, again
0xffff8cd0: b0 70                         #             call    puts                ; print the line number
0xffff8cd2: 8e 00                         #             hlt                         ; crash the kernel.
0xffff8cd4:                               # udiv16:
0xffff8cd4: 2d cc                         #             pushd   %r3                 ; save r3
0xffff8cd6: 59 20                         #             mov     %r1, 0              ; initial partial remainder is 0
0xffff8cd8: 58 70                         #             mov     %r3, 16             ; number of iterations to perform
0xffff8cda:                               # udiv16_loop:
0xffff8cda: 10 24                         #             addx    %r1, %r1            ; shift the partial remainder one bit left
0xffff8cdc: 10 00                         #             addx    %r0, %r0            ; shift dividend left one bit thru carry
0xffff8cde: 85 04                         #             jnc     udiv16_no_qbit      ; if no carry, skip moving bit into partial rem
0xffff8ce0: 54 21                         #             orx     %r1, 1              ; move carry into bottom bit of shifted partial rem
0xffff8ce2:                               # udiv16_no_qbit:
0xffff8ce2: 11 28                         #             sub     %r1, %r2            ; attempt subtraction from partial remainder
0xffff8ce4: 85 06                         #             jnc     udiv16_no_borrow    ; if that subtraction succeeded, set bit of quotient
0xffff8ce6: 10 28                         #             add     %r1, %r2            ; otherwise, restore partial remainder
0xffff8ce8: 8e 04                         #             jmp     udiv16_step         ; and skip setting quotient bit
0xffff8cea:                               # udiv16_no_borrow:
0xffff8cea: 54 01                         #             orx     %r0, 1              ; set bottom bit of the dividend (growing quotient)
0xffff8cec:                               # udiv16_step:
0xffff8cec: 41 61                         #             subh    %r3, 1              ; decrement counter
0xffff8cee: 99 ec                         #             ja      udiv16_loop         ; continue as long as counter remains > 0
0xffff8cf0: 2c 78                         #             popd    %r3                 ; otherwise we're done. Restore r3
0xffff8cf2: af ee                         #             ret
0xffff8cf4:                               # itoa:
0xffff8cf4: 57 5f                         #             testx   %r2, -1             ; test the input number for sign
0xffff8cf6: 83 0c                         #             jnn     utoa                ; if it's already positive, go straight to utoa
0xffff8cf8: 58 21 5c 2d                   #             mov     %r1, 45             ; otherwise, prepare a minus sign '-'
0xffff8cfc: 0b 20                         #             sth     %r1, %r0            ; to put in the buffer
0xffff8cfe: 60 01                         #             addd    %r0, 1              ; buf++
0xffff8d00: 52 40                         #             rsubx   %r2, 0              ; d = -d
0xffff8d02:                               # utoa:
0xffff8d02: 2d dc                         #             pushd   %ln
0xffff8d04: 2d d0                         #             pushd   %r4                 ; wind
0xffff8d06: 2d c0                         #             pushd   %r0                 ; save original value of buffer
0xffff8d08: 58 81 5c 90                   #             mov     %r4, 48             ; stash '0' for quick access
0xffff8d0c: 29 60                         #             movd    %r3, %r0            ; p = buf
0xffff8d0e: 19 08                         #             mov     %r0, %r2            ; dividend = d
0xffff8d10: 59 4a                         #             mov     %r2, 10             ; divisor = base = 10
0xffff8d12:                               # itoa_loop:
0xffff8d12: bf c2                         #             call    udiv16              ; r0 = quotient, r1 = remainder, r2 still 10
0xffff8d14: 00 30                         #             addh    %r1, %r4            ; chr = remainder + '0'
0xffff8d16: 0b 2c                         #             sth     %r1, %r3            ; *p = chr
0xffff8d18: 60 61                         #             addd    %r3, 1              ; p++
0xffff8d1a: 57 1f                         #             testx   %r0, -1             ; test quotient for zero
0xffff8d1c: 91 f6                         #             jnz     itoa_loop           ; loop as long as quotient is not yet zero
0xffff8d1e: 0b 0c                         #             sth     %r0, %r3            ; *p = 0, terminate the string
0xffff8d20: 61 61                         #             subd    %r3, 1              ; p2 = p - 1
0xffff8d22: 2c 18                         #             popd    %r0                 ; p1 = buf
0xffff8d24: 2c 98                         #             popd    %r4
0xffff8d26: 2c f8                         #             popd    %ln                 ; fully unwind the stack to prepare for
0xffff8d28: 8e 0e                         #             jmp     itoa_rev_check      ; enter loop at check
0xffff8d2a:                               # itoa_rev_loop:
0xffff8d2a: 0a 40                         #             ldh     %r2, %r0            ; tmp = *p1
0xffff8d2c: 0a 2c                         #             ldh     %r1, %r3            ; r1 = *p2
0xffff8d2e: 0b 20                         #             sth     %r1, %r0            ; *p1 = *p2
0xffff8d30: 0b 4c                         #             sth     %r2, %r3            ; *p2 = tmp
0xffff8d32: 60 01                         #             addd    %r0, 1              ; p1++
0xffff8d34: 61 61                         #             subd    %r3, 1              ; p2--
0xffff8d36:                               # itoa_rev_check:
0xffff8d36: 23 0c                         #             cmpd    %r0, %r3            ; p1 <? p2
0xffff8d38: 94 f2                         #             jb      itoa_rev_loop       ; loop if yes
0xffff8d3a: af ee                         #             ret                         ; otherwise we're done, return.
0xffff8d3c:                               # puts_L1:
0xffff8d3c: 4b 23                         #             sth     %r1, OUTPUT         ; putchar(*str)
0xffff8d3e: 60 01                         #             addd    %r0, 1              ; ++str
0xffff8d40:                               # puts:
0xffff8d40: 0a 20                         #             ldh     %r1, %r0            ; r1 = *str
0xffff8d42: 47 3f                         #             testh   %r1, -1             ; test *str
0xffff8d44: 91 f8                         #             jnz     puts_L1             ; loop if *str != 0
0xffff8d46: af ee                         #             ret                         ; return if *str == 0
0xffff8d48:                               # syscall_exit:
0xffff8d48: 2d c4                         #             pushd   %r1                     ; save status
0xffff8d4a: b0 1e                         #             call    syscall_exit_with_msg   ; get msg into ln
0xffff8d4c: 50 72 6f 67 72 61 6d 20 65 78 69 74 65 64 20 77 69 74 68 20 73 74 61 74 75 73 20 00#             .asciiz "Program exited with status "
0xffff8d68:                               # syscall_exit_with_msg:
0xffff8d68: 29 1c                         #             movd    %r0, %r7            ; arg 0 = msg
0xffff8d6a: bf d6                         #             call    puts                ; print the msg
0xffff8d6c: 2c 58                         #             popd    %r2                 ; arg 2 = status
0xffff8d6e: 69 1e 6c 00 6c 00 6c 00 6c 00 6c 00 6c 14#             mov     %r0, RT_BUFFER_PTR  ; arg 0 = runtime buffer after kernel data
0xffff8d7c: 29 80                         #             movd    %r4, %r0            ; save buffer addr
0xffff8d7e: bf 84                         #             call    utoa                ; write str(code) into buffer
0xffff8d80: 29 10                         #             movd    %r0, %r4            ; arg 0 = buffer again
0xffff8d82: bf be                         #             call    puts                ; print the code
0xffff8d84: 8e 00                         #             hlt                         ; terminate
0xffff8d86:                               # syscall_putuint:
0xffff8d86:                               # syscall_putsint:
0xffff8d86: 2d c8                         #             pushd   %r2                 ; wind stack to save all user registers that we would clobber
0xffff8d88: 2d cc                         #             pushd   %r3
0xffff8d8a: 2d d0                         #             pushd   %r4
0xffff8d8c: 43 02                         #             cmph    %r0, 2              ; compare 2*service_no to 2. If it's 2, print unsigned.
0xffff8d8e: 19 44                         #             movx    %r2, %r1            ; arg 2 = number
0xffff8d90: 69 1e 6c 00 6c 00 6c 00 6c 00 6c 00 6c 14#             mov     %r0, RT_BUFFER_PTR  ; arg 0 = runtime buffer after kernel data
0xffff8d9e: 29 80                         #             movd    %r4, %r0            ; and save this address
0xffff8da0: 81 06                         #             jne     syscall_do_signed   ; if service no is not 2, use itoa
0xffff8da2: bf 60                         #             call    utoa                ; otherwise use utoa
0xffff8da4: 8e 04                         #             jmp     syscall_have_a
0xffff8da6:                               # syscall_do_signed:
0xffff8da6: bf 4e                         #             call    itoa
0xffff8da8:                               # syscall_have_a:                         ; now the buffer has the rep of the number to print
0xffff8da8: 29 10                         #             movd    %r0, %r4            ; get its address back
0xffff8daa: bf 96                         #             call    puts                ; and print the number
0xffff8dac: 2c 98                         #             popd    %r4
0xffff8dae: 2c 78                         #             popd    %r3
0xffff8db0: 2c 58                         #             popd    %r2                 ; unwind
0xffff8db2: 8e 22                         #             jmp     syscall_return
0xffff8db4:                               # syscall_puts:
0xffff8db4: 29 04                         #             movd    %r0, %r1            ; arg 0 = message
0xffff8db6: bf 8a                         #             call    puts                ; print it
0xffff8db8: 8e 1c                         #             jmp     syscall_return
0xffff8dba:                               # syscall_sbrk:
0xffff8dba: 69 fe 6c e0 6c e0 6c e0 6c e0 6c e0 6c ec#             mov     %r7, STATIC_DATA_PTR ; r7 = &static_data.break
0xffff8dc8: 2a 1c                         #             ldd     %r0, %r7            ; r0 = static_data->break
0xffff8dca: 20 20                         #             addd    %r1, %r0            ; r1 = static_data->break + numbytes
0xffff8dcc: 60 23                         #             addd    %r1, 3
0xffff8dce: 66 3c                         #             andd    %r1, -4             ; dword align the new break
0xffff8dd0: 2b 3c                         #             std     %r1, %r7            ; record the new break
0xffff8dd2: 8e 02                         #             jmp     syscall_return
0xffff8dd4:                               # syscall_return:
0xffff8dd4: 2c f8                         #             popd    %ln                 ; restore our return address
0xffff8dd6: 69 de 6c c0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %sp, 0x80000000     ; &static_data->user_sp
0xffff8de4: 2a d8                         #             ldd     %sp, %sp            ; %sp = static_data->user_sp
0xffff8de6: af ee                         #             ret
0xffff8de8:                               # invalid_msg:
0xffff8de8: 69 6e 76 61 6c 69 64 20       #             .ascii  "invalid "
0xffff8df0:                               # empty_str:
0xffff8df0:                               # empty_msg:                  ; share the NUL-terminator to get empty string
0xffff8df0: 00                            #             .half   0
0xffff8df1:                               # out_of_msg:
0xffff8df1: 6f 75 74 20 6f 66 20 00       #             .asciiz "out of "
0xffff8df9:                               # syntax_msg:
0xffff8df9: 73 79 6e 74 61 78 00          #             .asciiz "syntax"
0xffff8e00:                               # register_msg:
0xffff8e00: 72 65 67 69 73 74 65 72 00    #             .asciiz "register"
0xffff8e09:                               # immediate_msg:
0xffff8e09: 69 6d 6d 65 64 69 61 74 65 00 #             .asciiz "immediate"
0xffff8e13:                               # range_msg:
0xffff8e13: 72 61 6e 67 65 00             #             .asciiz "range"
0xffff8e19:                               # memory_msg:
0xffff8e19: 6d 65 6d 6f 72 79 00          #             .asciiz "memory"
0xffff8e20:                               # unknown_msg:
0xffff8e20: 75 6e 6b 6e 6f 77 6e 20 00    #             .asciiz "unknown "
0xffff8e29:                               # symbol_msg:
0xffff8e29: 73 79 6d 62 6f 6c 20 00       #             .asciiz "symbol "
0xffff8e31:                               # directive_msg:
0xffff8e31: 64 69 72 65 63 74 69 76 65 20 00#             .asciiz "directive "
0xffff8e3c:                               # missing_features_msg:
0xffff8e3c: 6d 69 73 73 69 6e 67 20 66 65 61 74 75 72 65 73 20 3a 28 00#             .asciiz "missing features :("
0xffff8e50:                               # completed_assembly_msg:
0xffff8e50: 61 73 73 65 6d 62 6c 79 20 63 6f 6d 70 6c 65 74 65 21 0a 00#             .asciiz "assembly complete!\n"
0xffff8e64:                               # exit_with_status_msg:
0xffff8e64: 70 72 6f 67 72 61 6d 20 65 78 69 74 65 64 20 77 69 74 68 20 73 74 61 74 75 73 20 00#             .asciiz "program exited with status "
0xffff8e80:                               # id_str:
0xffff8e80: 69 64 00                      #             .asciiz "id"
0xffff8e83:                               # at_str:
0xffff8e83: 61 74 00                      #             .asciiz "at"
0xffff8e86:                               # opcode_table2:
0xffff8e86: 04                            #             .half   4
0xffff8e87:                               # opcode_tables:                  ; pointer directly to 'name'
0xffff8e87: 6f 72                         #             .ascii  "or"
0xffff8e89: 0a                            #             .half   10
0xffff8e8a: 6c 64                         #             .ascii  "ld"
0xffff8e8c: 0b                            #             .half   11
0xffff8e8d: 73 74                         #             .ascii  "st"
0xffff8e8f:                               # opcode_table3short:
0xffff8e8f: 00                            #             .half   0
0xffff8e90: 61 64 64                      #             .ascii  "add"
0xffff8e93: 01                            #             .half   1
0xffff8e94: 73 75 62                      #             .ascii  "sub"
0xffff8e97: 03                            #             .half   3
0xffff8e98: 63 6d 70                      #             .ascii  "cmp"
0xffff8e9b: 05                            #             .half   5
0xffff8e9c: 78 6f 72                      #             .ascii  "xor"
0xffff8e9f: 06                            #             .half   6
0xffff8ea0: 61 6e 64                      #             .ascii  "and"
0xffff8ea3: 0c                            #             .half   12
0xffff8ea4: 73 6c 6f                      #             .ascii  "slo"
0xffff8ea7:                               # opcode_table3:
0xffff8ea7: 09 07 02                      #             .half   9   7   2
0xffff8eaa: 6d 6f 76                      #             .ascii  "mov"
0xffff8ead: 0c 04 03                      #             .half   12  4   3
0xffff8eb0: 70 6f 70                      #             .ascii  "pop"
0xffff8eb3: 0e 0b 03                      #             .half   14  11  3
0xffff8eb6: 68 6c 74                      #             .ascii  "hlt"
0xffff8eb9: 0f 0b 03                      #             .half   15  11  3
0xffff8ebc: 6e 6f 70                      #             .ascii  "nop"
0xffff8ebf: 10 0b 01                      #             .half   16  11  1
0xffff8ec2: 72 65 74                      #             .ascii  "ret"
0xffff8ec5:                               # opcode_table4:
0xffff8ec5: 02                            #             .half   2
0xffff8ec6:                               # opcode_table4_state:
0xffff8ec6: 05 03                         #             .half   5   3
0xffff8ec8: 72 73 75 62                   #             .ascii  "rsub"
0xffff8ecc: 07 05 03                      #             .half   7   5   3
0xffff8ecf: 74 65 73 74                   #             .ascii  "test"
0xffff8ed3: 08 05 03                      #             .half   8   5   3
0xffff8ed6: 6d 6f 76 7a                   #             .ascii  "movz"
0xffff8eda: 09 05 03                      #             .half   9   5   3
0xffff8edd: 6d 6f 76 73                   #             .ascii  "movs"
0xffff8ee1: 0d 02 03                      #             .half   13  2   3
0xffff8ee4: 70 75 73 68                   #             .ascii  "push"
0xffff8ee8: 10 03 01                      #             .half   16  3   1
0xffff8eeb: 63 61 6c 6c                   #             .ascii  "call"
0xffff8eef:                               # cond_table:
0xffff8eef: 0e                            #             .half   14
0xffff8ef0:                               # cond_table_name:
0xffff8ef0: 6d 70 00                      #             .asciiz "mp"
0xffff8ef3: 00                            #             .half   0
0xffff8ef4: 7a 00 00                      #             .asciiz "z\0"
0xffff8ef7: 00                            #             .half   0
0xffff8ef8: 65 00 00                      #             .asciiz "e\0"
0xffff8efb: 01                            #             .half   1
0xffff8efc: 6e 7a 00                      #             .asciiz "nz"
0xffff8eff: 01                            #             .half   1
0xffff8f00: 6e 65 00                      #             .asciiz "ne"
0xffff8f03: 02                            #             .half   2
0xffff8f04: 6e 00 00                      #             .asciiz "n\0"
0xffff8f07: 03                            #             .half   3
0xffff8f08: 6e 6e 00                      #             .asciiz "nn"
0xffff8f0b: 04                            #             .half   4
0xffff8f0c: 63 00 00                      #             .asciiz "c\0"
0xffff8f0f: 04                            #             .half   4
0xffff8f10: 62 00 00                      #             .asciiz "b\0"
0xffff8f13: 05                            #             .half   5
0xffff8f14: 6e 63 00                      #             .asciiz "nc"
0xffff8f17: 05                            #             .half   5
0xffff8f18: 61 65 00                      #             .asciiz "ae"
0xffff8f1b: 06                            #             .half   6
0xffff8f1c: 6f 00 00                      #             .asciiz "o\0"
0xffff8f1f: 07                            #             .half   7
0xffff8f20: 6e 6f 00                      #             .asciiz "no"
0xffff8f23: 08                            #             .half   8
0xffff8f24: 62 65 00                      #             .asciiz "be"
0xffff8f27: 09                            #             .half   9
0xffff8f28: 61 00 00                      #             .asciiz "a\0"
0xffff8f2b: 0a                            #             .half   10
0xffff8f2c: 6c 00 00                      #             .asciiz "l\0"
0xffff8f2f: 0b                            #             .half   11
0xffff8f30: 67 65 00                      #             .asciiz "ge"
0xffff8f33: 0c                            #             .half   12
0xffff8f34: 6c 65 00                      #             .asciiz "le"
0xffff8f37: 0d                            #             .half   13
0xffff8f38: 67 00 00                      #             .asciiz "g\0"
0xffff8f3b: 0e                            #             .half   14
0xffff8f3c: 00 00 00                      #             .asciiz "\0\0"
