0xffff8000:                               # .set STREAM 1
0xffff8000:                               # .set MODEQ 2
0xffff8000:                               # .set OUTPUT 3
0xffff8000:                               # .set SRCLINENO_OFS       -12
0xffff8000:                               # .set SYMTAB_HEAD_OFS     -8
0xffff8000:                               # .set RELOC_TAB_HEAD_OFS  -4
0xffff8000:                               # .set HEAP_LIMIT_OFS       4
0xffff8000:                               # .set EOL_CHAR_OFS         8
0xffff8000:                               # .set STATIC_DATA_PTR    0x8000000C
0xffff8000:                               # .set INIT_HEAP_LIMIT    0x80000018
0xffff8000:                               # .set INIT_STK_PTR       0xA0000000
0xffff8000:                               # .set INIT_OBJ_STK_PTR   0x20000000
0xffff8000:                               # .set RT_BUFFER_PTR      0x80000014   ; runtime buffer for itoa/utoa &c
0xffff8000:                               # .set BUFFER_PTR         0x00000020   ; small buffer for reading opcodes/registers etc
0xffff8000:                               # .set CODE_SEGMENT       0x00000030   ; we still use 0x20-0x30 as a buffer for non read_name lexing
0xffff8000: b0 5c                         #             call    _start
0xffff8002:                               # object_return_stub:
0xffff8002: 59 00                         #             mov     %r0, 0                  ; SYSCALL_EXIT
0xffff8004: 59 20                         #             mov     %r1, 0                  ; STATUS_OK
0xffff8006:                               # syscall:
0xffff8006: 43 04                         #             cmph    %r0, 4                  ; biggest known syscall is 4.
0xffff8008: 88 0a                         #             jbe     good_service_no         ; service <= 4? if yes, keep going. Otherwise, exit 140
0xffff800a: 59 00                         #             mov     %r0, 0
0xffff800c: 58 24 5c 2c                   #             mov     %r1, 140                ; exit code 140, SIGSYS
0xffff8010: 9e f6                         #             jmp     syscall
0xffff8012:                               # good_service_no:
0xffff8012: 57 c3                         #             testx   %sp, 3                  ; test the bottom 2 stack bits. The ABI requires that these
0xffff8014: 80 0c                         #             jz      aligned_stack           ; crash the program with code 139 (segfault) if it's on
0xffff8016: 66 de                         #             andd    %sp, -2                 ; align the stack so that we don't weirdloop
0xffff8018: 59 00                         #             mov     %r0, 0
0xffff801a: 58 24 5c 2b                   #             mov     %r1, 139
0xffff801e: 9e e8                         #             jmp syscall
0xffff8020:                               # aligned_stack:
0xffff8020: 2d dc                         #             pushd   %ln                     ; the stack is now guaranteed to be aligned. Save %ln.
0xffff8022: 60 c4                         #             addd    %sp, 4                  ; But without pushing, so that we save the right %sp.
0xffff8024: 69 fe 6c e0 6c e0 6c e0 6c e0 6c e0 6c e0#             mov     %ln, 0x80000000         ; &static_data->user_sp
0xffff8032: 2b dc                         #             std     %sp, %ln                ; static_data->user_sp = %sp
0xffff8034: 61 c4                         #             subd    %sp, 4                  ; go back to where we put our return address
0xffff8036: 2c f8                         #             popd    %ln                     ; restore our return address
0xffff8038: 69 de 6c d0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %sp, INIT_STK_PTR       ; initialize our own stack
0xffff8046: 2d dc                         #             pushd   %ln                     ; and save our return address there.
0xffff8048: b0 0c                         #             call    syscall_with_table      ; get the syscall table
0xffff804a: 44 8d                         #             .word   syscall_exit    &0xFFFF
0xffff804c: 82 8d                         #             .word   syscall_putuint &0xFFFF
0xffff804e: 82 8d                         #             .word   syscall_putsint &0xFFFF
0xffff8050: b0 8d                         #             .word   syscall_puts    &0xFFFF
0xffff8052: b6 8d                         #             .word   syscall_sbrk    &0xFFFF
0xffff8054:                               # syscall_with_table:
0xffff8054: 00 00                         #             addh    %r0, %r0                ; service_no *= sizeof(word)
0xffff8056: 20 e0                         #             addd    %ln, %r0                ; offset into the syscall table
0xffff8058: 1a fc                         #             ldx     %ln, %ln                ; load the system function to call, ldx will sign extend
0xffff805a: af ee                         #             jmp     %ln                     ; invoke it
0xffff805c:                               # _start:
0xffff805c: 5e 00                         #             mov     %r0, %cpuid1            ; get cpuid1 to check for S&F,8b,32b
0xffff805e: 58 30 5c 20 5c 20             #             mov     %r1, 0x4000             ; 32-bit operations
0xffff8064: 17 04                         #             testx   %r0, %r1
0xffff8066: 80 18                         #             jz      missing_feature
0xffff8068: 68 22 6c 30 6c 20 6c 2a       #             mov     %r1, 0x1400A            ; S&F,8b,32b,32p
0xffff8070: 26 04                         #             andd    %r0, %r1
0xffff8072: 23 04                         #             cmpd    %r0, %r1
0xffff8074: 81 0a                         #             jne     missing_feature
0xffff8076: 5e 02                         #             mov     %r0, %feat              ; get features to check for VN
0xffff8078: 57 01                         #             testx   %r0, 1                  ; VN
0xffff807a: 80 04                         #             jz      missing_feature
0xffff807c: 8e 04                         #             jmp     good_features
0xffff807e:                               # missing_feature:
0xffff807e: b6 16                         #             call    die_missing_feature
0xffff8080:                               # good_features:
0xffff8080: 59 02                         #             mov     %r0, 2                  ; 32-bit address mode
0xffff8082: 5f 11                         #             mov     %mode, %r0
0xffff8084: 69 be 6c a0 6c a0 6c a0 6c a0 6c a0 6c ac#             mov     %r5, STATIC_DATA_PTR
0xffff8092: 69 de 6c d0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %r6, INIT_STK_PTR
0xffff80a0: 29 14                         #             movd    %r0, %r5
0xffff80a2: 60 0c                         #             addd    %r0, 12                 ; INIT_HEAP_LIMIT is STATIC_DATA_PTR+12
0xffff80a4: 29 34                         #             movd    %r1, %r5
0xffff80a6: 60 24                         #             addd    %r1, HEAP_LIMIT_OFS     ; &static_data.heap_limit
0xffff80a8: 2b 04                         #             std     %r0, %r1                ; static_data->heap_limit = INIT_HEAP_LIMIT
0xffff80aa: 61 24                         #             subd    %r1, 4                  ; &static_data.asm_ip
0xffff80ac: 58 01 5c 10                   #             mov     %r0, CODE_SEGMENT       ; initial code segment ip
0xffff80b0: 2b 04                         #             std     %r0, %r1                ; static_data->asm_ip = CODE_SEGMENT
0xffff80b2: 61 24                         #             subd    %r1, 4                  ; &static_data.reloc_table_head
0xffff80b4: 59 00                         #             mov     %r0, 0                  ; NULL
0xffff80b6: 2b 04                         #             std     %r0, %r1                ; static_data->reloc_table_head = NULL
0xffff80b8: 61 24                         #             subd    %r1, 4                  ; &static_data.symtab_head
0xffff80ba: 2b 04                         #             std     %r0, %r1                ; static_data->symtab_head = NULL
0xffff80bc: 61 24                         #             subd    %r1, 4                  ; &static_data.src_lineno
0xffff80be: 59 01                         #             mov     %r0, 1                  ; initial line is line 1
0xffff80c0: 1b 04                         #             stx     %r0, %r1                ; static_data->src_lineno = 1
0xffff80c2: b1 04                         #             call    assemble_fp
0xffff80c4: b1 1e                         #             call    assemble_sp
0xffff80c6: b0 0a                         #             call    get_start_stub
0xffff80c8: 5f 73 74 61 72 74 00          #             .asciiz "_start"
0xffff80cf: 00                            # 
0xffff80d0:                               # get_start_stub:
0xffff80d0: 60 e3                         #             addd    %ln, 3
0xffff80d2: 66 fc                         #             andd    %ln, -4                 ; dword align %ln to get to the string
0xffff80d4: 29 1c                         #             movd    %r0, %ln                ; arg 0 = "_start"
0xffff80d6: b0 6c                         #             call    find_table_entry        ; find (or create, boo) a table entry for "_start"
0xffff80d8: b1 be                         #             call    sp_get_symbol           ; xlookup the address for _start
0xffff80da: 2d c0                         #             pushd   %r0                     ; stash that while we clean up
0xffff80dc: 69 1f 6c 03 6c 12 6c 0c       #             mov     %r0, completed_assembly_msg
0xffff80e4: 69 ff 6c e3 6c e9 6c fc       #             mov     %ln, puts
0xffff80ec: af fe                         #             call    %ln                     ; inform the user that their program is starting soon
0xffff80ee: 69 ff 6c e0 6c e0 6c e2       #             mov     %ln, object_return_stub
0xffff80f6: 59 04                         #             mov     %r0, 4                  ; syscall - object return stub
0xffff80f8: 20 1c                         #             addd    %r0, %ln                ; r0 = syscall
0xffff80fa: 2c 38                         #             popd    %r1                     ; reload address of _start to prepare transfer of control
0xffff80fc: 68 d0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %sp, INIT_OBJ_STK_PTR   ; initialize the object program stack pointer
0xffff8108: 59 40                         #             mov     %r2, 0
0xffff810a: 59 60                         #             mov     %r3, 0
0xffff810c: 59 80                         #             mov     %r4, 0
0xffff810e: 59 a0                         #             mov     %r5, 0
0xffff8110: af 2e                         #             jmp     %r1                     ; give control to the object program!
0xffff8112:                               # shr5:
0xffff8112: 2d c8                         #             pushd   %r2      ; having separated vaneers like this is fewer instructions
0xffff8114: 58 50                         #             movzx   %r2, 16  ; I have optimized for the placement of shr4 here.
0xffff8116: 10 48                         #             addx    %r2, %r2        ; 16 + 16 = 32
0xffff8118: 8e 06                         #             jmp     shr_L1
0xffff811a:                               # shr4:
0xffff811a: 2d c8                         #             pushd   %r2
0xffff811c: 58 50                         #             movzx   %r2, 16
0xffff811e:                               # shr_L1:
0xffff811e: 2d cc                         #             pushd   %r3
0xffff8120: 29 60                         #             movd    %r3, %r0        ; move x to r3
0xffff8122: 2d d0                         #             pushd   %r4
0xffff8124: 59 81                         #             mov     %r4, 1          ; b = 1
0xffff8126: 59 00                         #             mov     %r0, 0          ; clear r0 (it holds 'r')
0xffff8128:                               # shr_L2:                             ; top of shr loop
0xffff8128: 27 4c                         #             testd   %r2, %r3        ; test mask & x
0xffff812a: 80 04                         #             jz      shr_L3          ; don't set bit of r if !(mask & x)
0xffff812c: 24 10                         #             ord     %r0, %r4        ; r |= b if mask & x, shifts that bit over
0xffff812e:                               # shr_L3:
0xffff812e: 20 48                         #             addd    %r2, %r2        ; mask <<= 1
0xffff8130: 23 4c                         #             cmpd    %r2, %r3        ; mask >? x
0xffff8132: 89 08                         #             ja      shr_L4          ; if yes, further testds will fail and we can quit.
0xffff8134: 20 90                         #             addd    %r4, %r4        ; b <<= 1
0xffff8136: 41 21                         #             subh    %r1, 1          ; --width
0xffff8138: 91 f0                         #             jnz     shr_L2          ; loop if width != 0
0xffff813a:                               # shr_L4:
0xffff813a: 2c 98                         #             popd    %r4             ; now r0 has the result
0xffff813c: 2c 78                         #             popd    %r3             ; so we can unwind
0xffff813e: 2c 58                         #             popd    %r2
0xffff8140: af ee                         #             ret
0xffff8142:                               # find_table_entry:
0xffff8142: 2d dc                         #             pushd   %ln                 ; prologue, we call other functions
0xffff8144: 29 74                         #             movd    %r3, %r5            ; copy &static_data
0xffff8146: 60 78                         #             addd    %r3, SYMTAB_HEAD_OFS; re = &static_data.symtab_head
0xffff8148: 2a 2c                         #             ldd     %r1, %r3            ; r1 = static_data->symtab_head
0xffff814a: 8e 20                         #             jmp     find_table_entry_check
0xffff814c:                               # find_table_entry_loop:                  ; loop top
0xffff814c: 2d c0                         #             pushd   %r0                 ; save name
0xffff814e: 2d c4                         #             pushd   %r1                 ; save ste
0xffff8150: 60 28                         #             addd    %r1, 8              ; &ste->symbol
0xffff8152: 59 5f                         #             mov     %r2, -1             ; uint32_t_MAX
0xffff8154: b5 48                         #             call    strncmp             ; r0 = !(name `streq` ste->symbol)
0xffff8156: 57 1f                         #             test    %r0, -1             ; set Z if the strings were equal
0xffff8158: 81 0a                         #             jnz     find_table_entry_L2 ; skip return if we missed
0xffff815a: 2c 18                         #             popd    %r0                 ; restore ste to r0
0xffff815c: 60 c4                         #             addd    %sp, 4              ; pop name
0xffff815e: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8160: af ee                         #             ret
0xffff8162:                               # find_table_entry_L2:
0xffff8162: 2c 38                         #             popd    %r1                 ; restore ste to r1
0xffff8164: 2c 18                         #             popd    %r0                 ; restore name to r0
0xffff8166: 2a 24                         #             ldd     %r1, %r1            ; ste = ste->next
0xffff8168: 66 3e                         #             andd    %r1, -2             ; untag the pointer
0xffff816a:                               # find_table_entry_check:
0xffff816a: 67 3f                         #             testd   %r1, -1             ; is the pointer null?
0xffff816c: 91 e0                         #             jnz     find_table_entry_loop ; if not, loop
0xffff816e: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8170:                               # add_table_entry:
0xffff8170: 29 54                         #             movd    %r2, %r5            ; char *ptr = &static_data
0xffff8172: 60 44                         #             addd    %r2, HEAP_LIMIT_OFS ; ptr = &static_data.heap_limit
0xffff8174: 2a 48                         #             ldd     %r2, %r2            ; ptr = static_data->heap_limit
0xffff8176: 29 68                         #             movd    %r3, %r2            ; te = ptr
0xffff8178: 60 48                         #             addd    %r2, 8              ; ptr += offsetof(table_entry_t, symbol)
0xffff817a: 23 08                         #             cmpd    %r0, %r2            ; compare ptr to name
0xffff817c: 80 12                         #             je      add_table_entry_NCL ; jump to non-copying loop if not equal
0xffff817e:                               # add_table_entry_CL:                     ; otherwise fall through to copying loop
0xffff817e: 2a 20                         #             ldd     %r1, %r0            ; temp = *name, 32-bit transfer
0xffff8180: 2b 28                         #             std     %r1, %r2            ; *ptr = *name, 32-bit transfer
0xffff8182: 60 04                         #             addd    %r0, 4              ; name += 4
0xffff8184: 60 44                         #             addd    %r2, 4              ; ptr  += 4
0xffff8186: 0a 20                         #             ldh     %r1, %r0            ; temp = *name again
0xffff8188: 47 3f                         #             testh   %r1, -1             ; is *name zero?
0xffff818a: 91 f4                         #             jnz     add_table_entry_CL  ; if not, loop
0xffff818c: 8e 0a                         #             jmp     add_table_entry_done; otherwise go after the loops
0xffff818e:                               # add_table_entry_NCL:
0xffff818e: 60 44                         #             addd    %r2, 4              ; ptr  += 4
0xffff8190: 0a 28                         #             ldh     %r1, %r2            ; temp = *ptr
0xffff8192: 47 3f                         #             testh   %r1, -1             ; is *ptr zero?
0xffff8194: 91 fa                         #             jnz     add_table_entry_NCL ; if not, loop
0xffff8196:                               # add_table_entry_done:
0xffff8196: 60 44                         #             addd    %r2, 4              ; ptr += 4
0xffff8198: 29 34                         #             movd    %r1, %r5            ; copy &static_data
0xffff819a: 60 24                         #             addd    %r1, HEAP_LIMIT_OFS ; &static_data.heap_limit
0xffff819c: 2b 44                         #             std     %r2, %r1            ; static_data->heap_limit = ptr
0xffff819e: 60 34                         #             addd    %r1, -12            ; &static_data.symtab_head
0xffff81a0: 2a 04                         #             ldd     %r0, %r1            ; r0 = static_data->symtab_head
0xffff81a2: 2b 0c                         #             std     %r0, %r3            ; copy symtab_head to te->next
0xffff81a4: 2b 64                         #             std     %r3, %r1            ; static_data->symtab_head = te
0xffff81a6: 29 0c                         #             movd    %r0, %r3            ; copy te to return register
0xffff81a8: af ee                         #             ret
0xffff81aa:                               # ste_attach_payload:
0xffff81aa: 2d dc                         #             pushd   %ln                 ; save return address
0xffff81ac: 2d c4                         #             pushd   %r1                 ; save payload
0xffff81ae: bf 94                         #             call    find_table_entry    ; r0 = entry for 'name'
0xffff81b0: 2a 20                         #             ldd     %r1, %r0            ; r1 = entry->next
0xffff81b2: 64 21                         #             ord     %r1, 1              ; tag the entry as valid
0xffff81b4: 2b 20                         #             std     %r1, %r0            ; entry->next = tagged pointer
0xffff81b6: 60 04                         #             addd    %r0, 4              ; r0 = &entry.payload
0xffff81b8: 2c 38                         #             popd    %r1                 ; r1 = payload
0xffff81ba: 2b 20                         #             std     %r1, %r0            ; entry->payload = payload
0xffff81bc: 2c f8                         #             popd    %ln
0xffff81be: af ee                         #             ret
0xffff81c0:                               # ste_get_payload:
0xffff81c0: 60 04                         #             addd    %r0, 4
0xffff81c2: 2a 00                         #             ldd     %r0, %r0            ; entry->payload
0xffff81c4: af ee                         #             ret
0xffff81c6:                               # assemble_fp:
0xffff81c6: 2d dc                         #             pushd   %ln
0xffff81c8:                               # assemble_fp_L1:
0xffff81c8: b2 c8                         #             call    fpsm
0xffff81ca: 29 14                         #             movd    %r0, %bp            ; r0 = &static_data
0xffff81cc: 60 14                         #             addd    %r0, SRCLINENO_OFS  ; r0 = &static_data.src_lineno
0xffff81ce: 1a 20                         #             ldx     %r1, %r0            ; r1 = static_data->src_lineno
0xffff81d0: 50 21                         #             addx    %r1, 1
0xffff81d2: 1b 20                         #             stx     %r1, %r0            ; static_data->src_lineno++
0xffff81d4: 29 14                         #             movd    %r0, %bp            ; r0 = &static_data again
0xffff81d6: 60 08                         #             addd    %r0, EOL_CHAR_OFS   ; ro = &static_data.eol_char
0xffff81d8: 0a 00                         #             ldh     %r0, %r0            ; r0 = static_data->eol_char
0xffff81da: 47 1f                         #             testh   %r0, -1             ; test the char
0xffff81dc: 91 ec                         #             jnz     assemble_fp_L1      ; loop if it's not \NUL
0xffff81de: 2c f8                         #             popd    %ln                 ; if it's \NUL, we're done.
0xffff81e0: af ee                         #             ret
0xffff81e2:                               # assemble_sp:
0xffff81e2: 2d dc                         #             pushd   %ln
0xffff81e4: 2a 14                         #             ldd     %r0, %bp            ; r0 = static_data->asm_ip
0xffff81e6: 2d c0                         #             pushd   %r0                 ; save ip at end of program
0xffff81e8: 59 14                         #             mov     %r0, SRCLINENO_OFS
0xffff81ea: 20 14                         #             addd    %r0, %bp            ; r0 = &static_data.src_lineno
0xffff81ec: 1a 00                         #             ldx     %r0, %r0            ; r0 = static_data->src_lineno
0xffff81ee: 2d c0                         #             pushd   %r0                 ; save final lineno, in case can't find _start
0xffff81f0: 59 1c                         #             mov     %r0, RELOC_TAB_HEAD_OFS
0xffff81f2: 20 14                         #             addd    %r0, %bp            ; r0 = &static_data.reloc_tab_head
0xffff81f4: 2a 40                         #             ldd     %r2, %r0            ; r2 = reloc_entry = static_data->reloc_tab_head
0xffff81f6: 67 5f                         #             testd   %r2, -1             ; test the pointer to see if it's null
0xffff81f8: 80 22                         #             jz      assemble_sp_L2      ; skip the loop entirely if so
0xffff81fa:                               # assemble_sp_L1:
0xffff81fa: 2d c8                         #             pushd   %r2                 ; save original value of reloc_entry
0xffff81fc: 2a 28                         #             ldd     %r1, %r2            ; r1 = arg 1 = reloc_entry->asm_ip
0xffff81fe: 2b 34                         #             std     %r1, %bp            ; static_data->asm_ip = reloc_entry->asm_ip
0xffff8200: 60 4c                         #             addd    %r2, 12             ; &reloc_entry.src_lineno
0xffff8202: 1a 08                         #             ldx     %r0, %r2            ; r0 = reloc_entry->src_lineno
0xffff8204: 59 74                         #             mov     %r3, SRCLINENO_OFS
0xffff8206: 20 74                         #             addd    %r3, %bp            ; r3 = &static_data.src_lineno
0xffff8208: 1b 0c                         #             stx     %r0, %r3            ; static_data->src_lineno = reloc_entry->src_lineno
0xffff820a: 61 48                         #             subd    %r2, 8              ; &reloc_entry.entry
0xffff820c: 2a 08                         #             ldd     %r0, %r2            ; arg 0 = reloc_entry->entry
0xffff820e: b0 1c                         #             call    assemble_sp_visit   ; handle this reloc table entry
0xffff8210: 2c 58                         #             popd    %r2                 ; reload original value of reloc_entry
0xffff8212: 60 48                         #             addd    %r2, 8              ; &entry->next
0xffff8214: 2a 48                         #             ldd     %r2, %r2            ; entry = entry->next
0xffff8216: 67 5f                         #             testd   %r2, -1             ; is entry now NULL?
0xffff8218: 91 e2                         #             jnz     assemble_sp_L1      ; if entry is not NULL, it's a valid entry. Loop.
0xffff821a:                               # assemble_sp_L2:
0xffff821a: 2c 18                         #             popd    %r0                 ; restore final lineno
0xffff821c: 59 34                         #             mov     %r1, SRCLINENO_OFS
0xffff821e: 20 34                         #             addd    %r1, %bp            ; &static_data.src_lineno
0xffff8220: 1b 04                         #             stx     %r0, %r1            ; static_data->src_lineno = saved original lineno
0xffff8222: 2c 18                         #             popd    %r0                 ; restore ip at end of program
0xffff8224: 2b 14                         #             std     %r0, %bp            ; static_data->asm_ip = ip at end of program
0xffff8226: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8228: af ee                         #             ret
0xffff822a:                               # assemble_sp_visit:
0xffff822a: 2d dc                         #             pushd   %ln
0xffff822c: b0 6a                         #             call    sp_get_symbol       ; arg 0 = target = sp_get_symbol(ste)
0xffff822e: 0a 44                         #             ldh     %r2, %r1            ; opc = *asm_ip
0xffff8230: 43 5d                         #             cmph    %r2, -3             ; test if opc is -3
0xffff8232: 81 0e                         #             jne     assemble_sp_visit_L2; fall through if it is...
0xffff8234: 60 21                         #             addd    %r1, 1              ; asm_ip + 1
0xffff8236: 0a 44                         #             ldh     %r2, %r1            ; r2 = reg = *(asm_ip+1)
0xffff8238: 29 20                         #             movd    %r1, %r0            ; arg 1 = target
0xffff823a: 09 08                         #             movh    %r0, %r2            ; arg 0 = reg
0xffff823c: 49 41                         #             movh    %r2, 1              ; arg 2 = true [tell assemble_long_mov to use nops]
0xffff823e: b1 78                         #             call    assemble_long_mov   ; tail-call (it won't be returning here), it returns off stack
0xffff8240:                               # assemble_sp_visit_L2:
0xffff8240: 43 40                         #             cmph    %r2, 0              ; compare opc to 0
0xffff8242: 8b 0a                         #             jge     assemble_sp_visit_tx; if >= 0, it's a control transfer
0xffff8244: 09 28                         #             movh    %r1, %r2            ; prepare for arg 1 to have -opc
0xffff8246: 42 20                         #             rsubh   %r1, 0              ; arg1 = -opc
0xffff8248: 29 54                         #             movd    %r2, %r5            ; arg2 = &static_data (that's encode_value's cc)
0xffff824a: b4 74                         #             call    encode_value_stkret ; tail-call the encode_value entrypoint that wants %ln on the stack.
0xffff824c:                               # assemble_sp_visit_tx:
0xffff824c: 43 4f                         #             cmph    %r2, 15             ; opc >? 15
0xffff824e: 89 84                         #             ja      fp_call_L           ; if yes, this is a call
0xffff8250: 8e b0                         #             jmp     fp_jump_L           ; otherwise, it's a jump
0xffff8252:                               # fp_get_symbol:
0xffff8252: 2d dc                         #             pushd   %ln
0xffff8254: 2d c8                         #             pushd   %r2                 ; we promise to preserve this, so can't clobber
0xffff8256: be ec                         #             call    find_table_entry    ; r0 = entry = find_table_entry(name)
0xffff8258: 29 40                         #             movd    %r2, %r0            ; copy entry so we can check validity
0xffff825a: 2a 48                         #             ldd     %r2, %r2            ; entry->next, which is tagged with validity
0xffff825c: 47 41                         #             testh   %r2, 1              ; if that bit is on, the entry is valid
0xffff825e: 2c 58                         #             popd    %r2                 ; unwind the stack, we aren't calling more functions
0xffff8260: 2c f8                         #             popd    %ln                 ; final unwind
0xffff8262: af e1                         #             retnz                       ; if that bit was on, nz is set, entry is in r0, return!
0xffff8264: 59 64                         #             mov     %r3, HEAP_LIMIT_OFS
0xffff8266: 20 74                         #             addd    %r3, %r5            ; &static_data.heap_limit
0xffff8268: 2a 2c                         #             ldd     %r1, %r3            ; reloc_entry = static_data->heap_limit
0xffff826a: 60 24                         #             addd    %r1, 4              ; &reloc_entry->ste
0xffff826c: 2b 04                         #             std     %r0, %r1            ; reloc_entry->ste = entry
0xffff826e: 29 04                         #             movd    %r0, %r1            ; copy static_data->heap_limit+4
0xffff8270: 60 0c                         #             addd    %r0, 12             ; static_data->heap_limit+4 + 12
0xffff8272: 2b 0c                         #             std     %r0, %r3            ; static_data->heap_limit += 16
0xffff8274: 60 3c                         #             addd    %r1, -4             ; &reloc_entry->inst
0xffff8276: 2a 14                         #             ldd     %r0, %r5            ; r0 <- static_data->asm_ip
0xffff8278: 2b 04                         #             std     %r0, %r1            ; reloc_entry->inst = static_data->asm_ip
0xffff827a: 60 28                         #             addd    %r1, 8              ; &reloc_entry->next
0xffff827c: 59 1c                         #             mov     %r0, RELOC_TAB_HEAD_OFS
0xffff827e: 20 14                         #             addd    %r0, %r5            ; &static_data->reloc_tab_head
0xffff8280: 2a 60                         #             ldd     %r3, %r0            ; static_data->reloc_tab_head
0xffff8282: 2b 64                         #             std     %r3, %r1            ; reloc_entry->next = static_data->reloc_tab_head
0xffff8284: 60 38                         #             addd    %r1, -8             ; recover pointer to reloc_entry
0xffff8286: 2b 20                         #             std     %r1, %r0            ; static_data->reloc_tab_head = reloc_entry
0xffff8288: 60 2c                         #             addd    %r1, 12             ; &reloc_entry->lineno
0xffff828a: 59 14                         #             mov     %r0, SRCLINENO_OFS
0xffff828c: 20 14                         #             addd    %r0, %r5            ; &static_data->src_lineno
0xffff828e: 1a 00                         #             ldx     %r0, %r0            ; static_data->src_lineno
0xffff8290: 1b 04                         #             stx     %r0, %r1            ; reloc_entry->lineno = static_data->src_lineno
0xffff8292: 59 00                         #             mov     %r0, 0
0xffff8294: af ee                         #             ret
0xffff8296:                               # sp_get_symbol:
0xffff8296: 2d dc                         #             pushd   %ln
0xffff8298: 2d c0                         #             pushd   %r0                 ; save entry
0xffff829a: 2a 00                         #             ldd     %r0, %r0            ; entry->next, tagged with validity
0xffff829c: 47 01                         #             testh   %r0, 1              ; if the tag bit is on, it's valid!
0xffff829e: 81 06                         #             jnz     sp_get_symbol_valid
0xffff82a0: 2c 38                         #             popd    %r1                 ; reload entry to arg1 = r1
0xffff82a2: b3 f6                         #             call    die_unknown_symbol  ; crash. Since we're crashing, no need to recover %ln.
0xffff82a4:                               # sp_get_symbol_valid:
0xffff82a4: 2c 18                         #             popd    %r0                 ; reload entry to return register
0xffff82a6: bf 1a                         #             call    ste_get_payload     ; r0 = entry->payload
0xffff82a8: 2c f8                         #             popd    %ln
0xffff82aa: af ee                         #             ret
0xffff82ac:                               # fp_die_out_range:
0xffff82ac: b3 e4                         #             call    die_out_of_range
0xffff82ae:                               # fp_0:
0xffff82ae: 43 4f                         #             cmph    %r2, 15             ; opc <=? 15
0xffff82b0: 89 0e                         #             ja      fp_0_encode_ret     ; if not, encode a return
0xffff82b2: 49 04                         #             movh    %r0, 4              ; otherwise, enc_fst = 4
0xffff82b4: 4c 00                         #             sloh    %r0, 0              ; enc_fst <<= 5
0xffff82b6: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0xffff82b8: 49 20                         #             movh    %r1, 0              ; enc_snd = 0
0xffff82ba: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff82bc: 8e 8e                         #             jmp     finalize_encoding   ; tail-call
0xffff82be:                               # fp_0_encode_ret:
0xffff82be: 59 07                         #             mov     %r0, 7              ; regL = 7
0xffff82c0: 46 4f                         #             andh    %r2, 15             ; opc &= 15
0xffff82c2: 8e 02                         #             jmp     fp_RJ               ; tail-call
0xffff82c4:                               # fp_RJ:
0xffff82c4: 09 20                         #             movh    %r1, %r0            ; enc_snd = reg
0xffff82c6: 4c 20                         #             sloh    %r1, 0              ; enc_snd <<= 5
0xffff82c8: 04 28                         #             orh     %r1, %r2            ; enc_snd |= opc
0xffff82ca: 49 05                         #             movh    %r0, 5              ; enc_fst = 5
0xffff82cc: 4c 0f                         #             sloh    %r0, 15             ; enc_fst = enc_fst << 5 | 15
0xffff82ce: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff82d0: 8e 7a                         #             jmp     finalize_encoding   ; tail-call
0xffff82d2:                               # fp_call_L:
0xffff82d2: 21 04                         #             subd    %r0, %r1            ; disp = tgt - here
0xffff82d4: 58 21 5c 3f 5c 3f             #             mov     %r1, 2047           ; get 2047 for comparison
0xffff82da: 23 04                         #             cmpd    %r0, %r1            ; disp >? 2047
0xffff82dc: 9d d0                         #             jg      fp_die_out_range    ; if yes, die
0xffff82de: 62 3f                         #             rsubd   %r1, -1             ; r1 = ~2047 = -2048
0xffff82e0: 23 04                         #             cmpd    %r0, %r1            ; disp <? -2048
0xffff82e2: 9a ca                         #             jl      fp_die_out_range
0xffff82e4: 19 60                         #             mov     %r3, %r0            ; save displacement in r3
0xffff82e6: 59 28                         #             mov     %r1, 8              ; arg 1 = 8
0xffff82e8: be 32                         #             call    shr4                ; imm = (imm >> 4) & 0xFF
0xffff82ea: 59 24                         #             mov     %r1, 4              ; arg 1 = 4
0xffff82ec: be 2e                         #             call    shr4                ; imm = (imm >> 4) & 0xF
0xffff82ee: 40 08                         #             addh    %r0, 8
0xffff82f0: 40 08                         #             addh    %r0, 8              ; imm += 16
0xffff82f2: 59 25                         #             mov     %r1, 5
0xffff82f4: 4c 20                         #             sloh    %r1, 0              ; r1 = 5 << 5
0xffff82f6: 04 04                         #             orh     %r0, %r1            ; enc_fst = imm | (5 << 5)
0xffff82f8: 19 2c                         #             mov     %r1, %r3            ; put displacement back in arg 1
0xffff82fa: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff82fc: 8e 4e                         #             jmp     finalize_encoding   ; tail-call
0xffff82fe:                               # fp_jump_L_stdcall:
0xffff82fe: 2d dc                         #             pushd   %ln
0xffff8300:                               # fp_jump_L:
0xffff8300: 22 20                         #             rsubd   %r1, %r0            ; disp = tgt - done
0xffff8302: 58 07 5c 1f                   #             mov     %r0, 255            ; get 255 for comparison
0xffff8306: 23 20                         #             cmpd    %r1, %r0            ; disp >? 255
0xffff8308: 9d a4                         #             jg      fp_die_out_range    ; if yes, die
0xffff830a: 62 1f                         #             rsubd   %r0, -1             ; r0 = ~255 = -256
0xffff830c: 23 20                         #             cmpd    %r1, %r0            ; disp <? -256
0xffff830e: 9a 9e                         #             jl      fp_die_out_range
0xffff8310: 53 20                         #             cmpx    %r1, 0              ; disp <? 0
0xffff8312: 8b 06                         #             jge     fp_jump_L_skip_inc  ; if not, don't adjust the opcode
0xffff8314: 50 48                         #             addx    %r2, 8
0xffff8316: 50 48                         #             addx    %r2, 8              ; opc += 16
0xffff8318:                               # fp_jump_L_skip_inc:
0xffff8318: 59 04                         #             mov     %r0, 4              ; enc_fst = 4
0xffff831a: 4c 00                         #             sloh    %r0, 0              ; enc_fst <<= 5
0xffff831c: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0xffff831e: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff8320: 8e 2a                         #             jmp     finalize_encoding   ; tail-call
0xffff8322:                               # fp_RR:
0xffff8322: 00 24                         #             addh    %r1, %r1            ; regR <<= 1
0xffff8324: 00 24                         #             addh    %r1, %r1            ; regR <<= 1
0xffff8326: 4c 00                         #             sloh    %r0, 0              ; regL <<= 5
0xffff8328: 04 20                         #             orh     %r1, %r0            ; enc_snd = regL (<< 5) | regR (<< 2)
0xffff832a:                               # fp_RX_shared:
0xffff832a: 00 6c                         #             addh    %r3, %r3            ; size_bits << 1
0xffff832c: 00 6c                         #             addh    %r3, %r3            ; size_bits << 2
0xffff832e: 00 6c                         #             addh    %r3, %r3            ; size_bits << 3
0xffff8330: 00 6c                         #             addh    %r3, %r3            ; size_bits << 4
0xffff8332: 09 0c                         #             movh    %r0, %r3            ; enc_fst = size_bits << 4
0xffff8334: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0xffff8336: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff8338: 8e 12                         #             jmp     finalize_encoding
0xffff833a:                               # fp_RI_stdcall:
0xffff833a: 2d dc                         #             pushd   %ln
0xffff833c:                               # fp_RI:
0xffff833c: 4c 00                         #             sloh    %r0, 0              ; regL <<= 5
0xffff833e: 58 ff                         #             movz    %r7, 31
0xffff8340: 06 3c                         #             andh    %r1, %r7            ; imm &= 31
0xffff8342: 04 20                         #             orh     %r1, %r0            ; enc_snd = regL (<< 5) | imm (& 31)
0xffff8344: 40 64                         #             addh    %r3, 4              ; size_bits += 4
0xffff8346: 9e e4                         #             jmp     fp_RX_shared        ; tail-call to setup enc_fst and numbytes
0xffff8348:                               # finalize_encoding_stdcall:
0xffff8348: 2d dc                         #             pushd   %ln
0xffff834a:                               # finalize_encoding:
0xffff834a: 2a f4                         #             ldd     %r7, %bp            ; r7 = iloc = static_data->asm_ip
0xffff834c: 20 5c                         #             addd    %r2, %r7            ; r2 = iloc + numbytes
0xffff834e: 2b 54                         #             std     %r2, %bp            ; static_data->asm_ip += numbytes
0xffff8350: 0b 1c                         #             sth     %r0, %r7            ; *iloc = first byte
0xffff8352: 60 e1                         #             addd    %r7, 1              ; iloc + 1
0xffff8354: 0b 3c                         #             sth     %r1, %r7            ; *(iloc + 1) = second byte
0xffff8356: 2c f8                         #             popd    %ln
0xffff8358: af ee                         #             ret
0xffff835a:                               # fp_R:
0xffff835a: 43 4c                         #             cmph    %r2, 12             ; opc == 12?
0xffff835c: 81 06                         #             jne     fp_R_push           ; if not, encode a push
0xffff835e: 49 26                         #             movh    %r1, 6              ; otherwise, encode a pop
0xffff8360: 9e c2                         #             jmp     fp_RR               ; tail-call
0xffff8362:                               # fp_R_push:
0xffff8362: 09 20                         #             movh    %r1, %r0            ; regR = regL
0xffff8364: 49 06                         #             movh    %r0, 6              ; regL = 6
0xffff8366: 9e bc                         #             jmp     fp_RR               ; tail-call
0xffff8368:                               # fp_I:
0xffff8368: 49 06                         #             movh    %r0, 6              ; regL = 6
0xffff836a: 9e d2                         #             jmp     fp_RI               ; tail-call
0xffff836c:                               # fp_LM:
0xffff836c: 67 9f                         #             testd   %r4, -1             ; test name
0xffff836e: 59 40                         #             mov     %r2, 0              ; arg 2 <- false [long_mov doesn't need nops]
0xffff8370: 80 46                         #             jz      assemble_long_mov   ; if it's null, dispatch immediately (tail call)
0xffff8372: 09 40                         #             movh    %r2, %r0            ; r2 = reg
0xffff8374: 29 10                         #             movd    %r0, %r4            ; arg 0 = name
0xffff8376: be dc                         #             call    fp_get_symbol       ; lookup the symtab entry for name
0xffff8378: 67 1f                         #             testd   %r0, -1             ; test it
0xffff837a: 81 0a                         #             jnz     fp_LM_have_entry    ; if it's not null, rearrange args and go
0xffff837c: 49 1d                         #             movh    %r0, -3             ; otherwise, set up to defer
0xffff837e: 09 28                         #             movh    %r1, %r2            ; arg 1 = reg
0xffff8380: 59 4e                         #             movx    %r2, 14             ; numbytes = 14
0xffff8382: 9e c8                         #             jmp     finalize_encoding   ; tail-call
0xffff8384:                               # fp_LM_have_entry:
0xffff8384: be 3c                         #             call    ste_get_payload     ; r0 <- payload from entry in r0
0xffff8386: 29 20                         #             movd    %r1, %r0            ; arg 1 = imm
0xffff8388: 09 08                         #             movh    %r0, %r2            ; arg 0 = reg
0xffff838a: 59 40                         #             mov     %r2, 0              ; arg 2 = false [long move doesn't need nops]
0xffff838c: 8e 2a                         #             jmp     assemble_long_mov
0xffff838e:                               # fp_LJ_good_payload:
0xffff838e: be 32                         #             call    ste_get_payload     ; arg 0 = entry->payload
0xffff8390: 58 3e                         #             mov     %r1, 30             ; get 30 for comparison
0xffff8392: 03 44                         #             cmph    %r2, %r1            ; opc == 30?
0xffff8394: 2a 34                         #             ldd     %r1, %bp            ; arg 1 = static_data->asm_ip
0xffff8396: 90 3c                         #             je      fp_call_L           ; if opc == 30, go to call_L
0xffff8398: 9e 68                         #             jmp     fp_jump_L           ; otherwise, to jump_L
0xffff839a:                               # fp_LJ:
0xffff839a: 43 4f                         #             cmph    %r2, 15             ; opc >? 15
0xffff839c: 88 0a                         #             jbe     fp_LJ_good_opc      ; if no, we have a jump which is valid
0xffff839e: 58 1e                         #             mov     %r0, 30             ; get 30 for comparison
0xffff83a0: 03 40                         #             cmph    %r2, %r0            ; opc == 30?
0xffff83a2: 80 04                         #             je      fp_LJ_good_opc      ; if yes, opcode is good
0xffff83a4: b1 c4                         #             call    fpsm_reject         ; if no, reject
0xffff83a6:                               # fp_LJ_good_opc:
0xffff83a6: 29 10                         #             movd    %r0, %r4            ; arg 0 = name
0xffff83a8: be aa                         #             call    fp_get_symbol       ; r0 = entry for name in symtab
0xffff83aa: 67 1f                         #             testd   %r0, -1             ; test the entry pointer
0xffff83ac: 91 e2                         #             jnz     fp_LJ_good_payload  ; if it's not NULL, dispatch to {call/jump}_L
0xffff83ae: 09 08                         #             movh    %r0, %r2            ; arg 0 = opc
0xffff83b0: 59 3f                         #             mov     %r1, -1             ; arg 1 = -1
0xffff83b2: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0xffff83b4: 9e 96                         #             jmp     finalize_encoding   ; tail-call
0xffff83b6:                               # assemble_long_mov:
0xffff83b6: 2d c0                         #             pushd   %r0                 ; cache all our arguments on the stack.
0xffff83b8: 2d c8                         #             pushd   %r2                 ; we will retrieve these as needed (painfully).
0xffff83ba: 2d c4                         #             pushd   %r1                 ; push imm last because it is also the last bit_group.
0xffff83bc: 29 04                         #             movd    %r0, %r1            ; arg 0 = imm
0xffff83be: 58 3b                         #             movz    %r1, 27             ; arg 1 = 27 (#bits to preserve)
0xffff83c0: bd 52                         #             call    shr5
0xffff83c2: 2d c0                         #             pushd   %r0                 ; groups[5] = imm >> 5
0xffff83c4: 58 36                         #             movz    %r1, 22
0xffff83c6: bd 4c                         #             call    shr5
0xffff83c8: 2d c0                         #             pushd   %r0                 ; groups[4] = groups[5] >> 5
0xffff83ca: 58 31                         #             movz    %r1, 17
0xffff83cc: bd 46                         #             call    shr5
0xffff83ce: 2d c0                         #             pushd   %r0                 ; groups[3] = groups[4] >> 5
0xffff83d0: 58 2c                         #             movz    %r1, 12
0xffff83d2: bd 40                         #             call    shr5
0xffff83d4: 2d c0                         #             pushd   %r0                 ; groups[2] = groups[3] >> 5
0xffff83d6: 58 27                         #             movz    %r1, 7
0xffff83d8: bd 3a                         #             call    shr5
0xffff83da: 2d c0                         #             pushd   %r0                 ; groups[1] = groups[2] >> 5
0xffff83dc: 58 22                         #             movz    %r1, 2
0xffff83de: bd 34                         #             call    shr5                ; r0 = groups[1] >> 5 (2 bits)
0xffff83e0: 65 02                         #             xord    %r0, 2              ; this xor-sub sequence performs
0xffff83e2: 61 02                         #             subd    %r0, 2              ; sign-extension from 2 bits!
0xffff83e4: 2d c0                         #             pushd   %r0                 ; groups[0] = sext(groups[1] >> 5, from 2)
0xffff83e6: 59 80                         #             mov     %r4, 0              ; group = 0 [0*4], in r4 where it won't get clobbered.
0xffff83e8: 58 18                         #             mov     %r0, 24
0xffff83ea: 20 18                         #             addd    %r0, %sp            ; r0 = &imm
0xffff83ec: 2a 00                         #             ldd     %r0, %r0            ; r0 = imm
0xffff83ee: 63 00                         #             cmpd    %r0, 0              ; compare imm against 0
0xffff83f0: 58 18                         #             mov     %r0, 24             ; retrieve 28 in r0, for comparisons later.
0xffff83f2: 8b 3c                         #             jge     alm_pos_check       ; go to the positive loop if its positive
0xffff83f4: 19 70                         #             mov     %r3, %r4            ; copy group-idx to r3
0xffff83f6: 20 78                         #             addd    %r3, %sp            ; &groups[group]
0xffff83f8: 2a 6c                         #             ldd     %r3, %r3            ; groups[group]
0xffff83fa: 8e 04                         #             jmp     alm_neg_check
0xffff83fc:                               # alm_neg_loop:
0xffff83fc: 50 84                         #             addx    %r4, 4              ; group += 1
0xffff83fe:                               # alm_neg_check:
0xffff83fe: 29 4c                         #             movd    %r2, %r3            ; copy-down the predictive group
0xffff8400: 19 70                         #             mov     %r3, %r4            ; copy group
0xffff8402: 50 64                         #             addx    %r3, 4              ; group + 1
0xffff8404: 20 78                         #             addd    %r3, %sp            ; &groups[group+1]
0xffff8406: 2a 6c                         #             ldd     %r3, %r3            ; groups[group+1]
0xffff8408: 13 80                         #             cmpx    %r4, %r0            ; compare group-idx against 24
0xffff840a: 85 10                         #             jae     alm_neg_mov         ; if it's not below, exit the loop
0xffff840c: 58 3f                         #             movz    %r1, 0x1F           ; r1 = 1F, nothing magic here
0xffff840e: 06 44                         #             andh    %r2, %r1            ; groups[group] & 0x1F
0xffff8410: 03 44                         #             cmph    %r2, %r1            ; groups[group] & 0x1F ==? 0x1F
0xffff8412: 81 08                         #             jne     alm_neg_mov         ; exit the loop if not equal,
0xffff8414: 58 30                         #             mov     %r1, 0x10           ; but we also have to exit if the next group
0xffff8416: 07 64                         #             testh   %r3, %r1            ; is the first bit of the next group on?
0xffff8418: 91 e4                         #             jnz     alm_neg_loop        ; if yes, loop.
0xffff841a:                               # alm_neg_mov:
0xffff841a: 58 01 5c 00                   #             mov     %r0, 32
0xffff841e: 20 18                         #             addd    %r0, %sp            ; &reg
0xffff8420: 2a 00                         #             ldd     %r0, %r0            ; arg 0 = reg
0xffff8422: 19 28                         #             mov     %r1, %r2            ; arg 1 = groups[group]. fp_RI will & with 31 for us.
0xffff8424: 59 49                         #             mov     %r2, 9              ; arg 2 = movs opcode
0xffff8426: 59 62                         #             mov     %r3, 2              ; arg 3 = dword size bits
0xffff8428: bf 12                         #             call    fp_RI_stdcall
0xffff842a: 8e 22                         #             jmp     alm_check_pass      ; we're done skipping groups. Insert nops?
0xffff842c:                               # alm_pos_loop:
0xffff842c: 50 84                         #             addx    %r4, 4              ; group += 1
0xffff842e:                               # alm_pos_check:
0xffff842e: 19 50                         #             mov     %r2, %r4            ; copy group-idx
0xffff8430: 20 58                         #             addd    %r2, %sp            ; &groups[group]
0xffff8432: 2a 48                         #             ldd     %r2, %r2            ; groups[group]
0xffff8434: 13 80                         #             cmpx    %r4, %r0            ; compare group-idx against 24
0xffff8436: 85 06                         #             jae     alm_pos_mov         ; if not below, exit the loop
0xffff8438: 63 40                         #             cmpd    %r2, 0              ; groups[group] ==? 0
0xffff843a: 90 f2                         #             je      alm_pos_loop        ; if yes, loop
0xffff843c:                               # alm_pos_mov:
0xffff843c: 58 01 5c 00                   #             mov     %r0, 32
0xffff8440: 20 18                         #             addd    %r0, %sp            ; &reg
0xffff8442: 2a 00                         #             ldd     %r0, %r0            ; arg 0 = reg
0xffff8444: 19 28                         #             mov     %r1, %r2            ; arg 1 = groups[group]. fp_RI will & with 31
0xffff8446: 59 48                         #             mov     %r2, 8              ; arg 2 = movz opcode
0xffff8448: 59 62                         #             mov     %r3, 2              ; arg 3 = dword size bits
0xffff844a: be f0                         #             call    fp_RI_stdcall
0xffff844c:                               # alm_check_pass:
0xffff844c: 58 1c                         #             mov     %r0, 28
0xffff844e: 20 18                         #             addd    %r0, %sp            ; &pass
0xffff8450: 2a 00                         #             ldd     %r0, %r0            ; pass
0xffff8452: 47 1f                         #             testh   %r0, -1             ; if pass is zero, skip nops
0xffff8454: 80 2c                         #             jz      alm_slo_check
0xffff8456: 59 60                         #             mov     %r3, 0              ; group is initially 0 and goes up by 4,
0xffff8458: 8e 0c                         #             jmp     alm_nop_check       ; so we have to match that for nop_count
0xffff845a:                               # alm_nop_loop:
0xffff845a: 59 00                         #             mov     %r0, 0
0xffff845c: 59 20                         #             mov     %r1, 0              ; arg 0 = arg 1 = 0. Jump disp will be 0.
0xffff845e: 59 4f                         #             mov     %r2, 15             ; arg 2 = NEVER cond code. canonical nop
0xffff8460: be 9e                         #             call    fp_jump_L_stdcall
0xffff8462: 50 64                         #             addx    %r3, 4              ; nop_count++
0xffff8464:                               # alm_nop_check:
0xffff8464: 13 70                         #             cmpx    %r3, %r4            ; nop_count <? group
0xffff8466: 94 f4                         #             jb      alm_nop_loop        ; loop if below
0xffff8468: 8e 18                         #             jmp     alm_slo_check       ; enter the slo-making loop
0xffff846a:                               # alm_slo_loop:
0xffff846a: 50 84                         #             addx    %r4, 4              ; group += 1
0xffff846c: 58 01 5c 00                   #             mov     %r0, 32
0xffff8470: 20 18                         #             addd    %r0, %sp            ; &reg
0xffff8472: 2a 00                         #             ldd     %r0, %r0            ; arg 0 = reg
0xffff8474: 19 30                         #             mov     %r1, %r4            ; r1 = group-idx
0xffff8476: 20 38                         #             addd    %r1, %sp            ; r1 = &groups[group]
0xffff8478: 2a 24                         #             ldd     %r1, %r1            ; arg 1 = groups[group]
0xffff847a: 59 4c                         #             mov     %r2, 12             ; arg 2 = slo opcode
0xffff847c: 59 62                         #             mov     %r3, 2              ; arg 3 = dword size bits
0xffff847e: be bc                         #             call    fp_RI_stdcall
0xffff8480:                               # alm_slo_check:
0xffff8480: 58 18                         #             mov     %r0, 24
0xffff8482: 13 80                         #             cmpx    %r4, %r0            ; group-idx <? 24 [group <? 6]
0xffff8484: 94 e6                         #             jb      alm_slo_loop        ; if yes, keep going.
0xffff8486: 60 cc                         #             addd    %sp, 12
0xffff8488: 60 cc                         #             addd    %sp, 12
0xffff848a: 60 cc                         #             addd    %sp, 12             ; %sp += 36. Same instr count as mov ?,36;add.
0xffff848c: 2c f8                         #             popd    %ln
0xffff848e: af ee                         #             ret
0xffff8490:                               # fpsm:
0xffff8490: 2d dc                         #             pushd   %ln
0xffff8492: 2d d4                         #             pushd   %r5
0xffff8494: 2a 74                         #             ldd     %r3, %r5            ; r3 = static_data->asm_ip
0xffff8496: 4a a1                         #             ldh     %r5, STREAM         ; initialize reader
0xffff8498: b7 4a                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff849a: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff849c: 80 18                         #             jz      fpsm_0_notalpha     ; branch past name read if not name start
0xffff849e: b4 f2                         #             call    read_name           ; r0 = pointer to read-in name
0xffff84a0: 09 94                         #             movh    %r4, %r5            ; stash cur in r4
0xffff84a2: 2a b8                         #             ldd     %r5, %sp            ; temporarily reload &static_data
0xffff84a4: 29 2c                         #             movd    %r1, %r3            ; r1 = static_data->asm_ip
0xffff84a6: bd 04                         #             call    ste_attach_payload  ; add this entry to the symbol table
0xffff84a8: 09 b0                         #             movh    %r5, %r4            ; restore cur to r5
0xffff84aa: 58 01 5c 1a                   #             mov     %r0, 58             ; setup 58 == ':' for comparison
0xffff84ae: b6 06                         #             call    match               ; cur == ':'?
0xffff84b0: 47 1f                         #             testh   %r0, -1             ; test result
0xffff84b2: 81 b6                         #             jne     fpsm_reject         ; reject with syntax error if cur != ':'
0xffff84b4:                               # fpsm_0_notalpha:
0xffff84b4: 58 01 5c 0e                   #             mov     %r0, 46             ; setup '.' for comparison
0xffff84b8: 03 a0                         #             cmph    %r5, %r0            ; cur ==? '.'
0xffff84ba: 80 06                         #             je      fpsm_process_directive ; if yes, process a directive. That will return from fpsm.
0xffff84bc: 59 21                         #             mov     %r1, 1              ; state = 1
0xffff84be: 8e b2                         #             jmp     fpsm_iterate        ; step the loop
0xffff84c0:                               # fpsm_process_directive:
0xffff84c0: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar(), step past '.'
0xffff84c2: b4 ce                         #             call    read_name           ; r0 = direc = read_name()
0xffff84c4: 29 40                         #             movd    %r2, %r0            ; stash direc somewhere that skip_whitespace won't clobber it
0xffff84c6: b3 f4                         #             call    skip_whitespace     ; skip_whitespace()
0xffff84c8: 29 08                         #             movd    %r0, %r2            ; arg 0 = direc
0xffff84ca: 2c 58                         #             popd    %r2                 ; arg 2 = &static_data, popping off our stack so that
0xffff84cc: b3 34                         #             call    asm_directive       ; tail-call asm_directive. It returns to our caller.
0xffff84ce:                               # fpsm_1:                                 ; switch case 1
0xffff84ce: b7 74                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0xffff84d0: 47 1f                         #             testh   %r0, -1             ; test result
0xffff84d2: 81 1a                         #             jnz     fpsm_1_accept       ; accept if is_eol(cur)
0xffff84d4: 58 01 5c 0e                   #             mov     %r0, 46             ; setup '.' for comparison
0xffff84d8: 03 a0                         #             cmph    %r5, %r0            ; cur ==? '.'
0xffff84da: 90 e6                         #             je      fpsm_process_directive ; if equal, process a directive instead.
0xffff84dc: b5 de                         #             call    read_opcode         ; r0 = rop.opcode, r1 = rop.state
0xffff84de: 09 80                         #             movh    %r4, %r0            ; temporarily save the opcode in r4
0xffff84e0: 09 64                         #             movh    %r3, %r1            ; temporarily save the target state in r3
0xffff84e2: b3 fe                         #             call    read_size           ; r0 = size_bits
0xffff84e4: 2d c0                         #             pushd   %r0                 ; put size_bits in their stack slot
0xffff84e6: 2d d0                         #             pushd   %r4                 ; put opcode into its stack slot
0xffff84e8: 09 2c                         #             movh    %r1, %r3            ; re-place the state in r1
0xffff84ea: 8e 86                         #             jmp     fpsm_iterate        ; break
0xffff84ec:                               # fpsm_1_accept:
0xffff84ec: 2c 98                         #             popd    %r4                 ; restore static_data pointer
0xffff84ee: 60 88                         #             addd    %r4, EOL_CHAR_OFS   ; &static_data.eol_char
0xffff84f0: 0b b0                         #             sth     %r5, %r4            ; static_data->eol_char = cur
0xffff84f2: 61 88                         #             subd    %r4, EOL_CHAR_OFS   ; undo offset
0xffff84f4: 29 b0                         #             movd    %r5, %r4            ; move pointer back where it belongs
0xffff84f6: 2c f8                         #             popd    %ln
0xffff84f8: af ee                         #             ret
0xffff84fa:                               # fpsm_2:
0xffff84fa: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff84fe: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8500: 81 0a                         #             jne     fpsm_2_imm          ; if not equal, try checking immediate
0xffff8502: b5 8a                         #             call    read_register       ; if yes equal, read a register
0xffff8504: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff8506: 59 2c                         #             mov     %r1, 12             ; state = 12
0xffff8508: 8e 68                         #             jmp     fpsm_iterate        ; break
0xffff850a:                               # fpsm_2_imm:
0xffff850a: b7 06                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0xffff850c: 47 1f                         #             testh   %r0, -1             ; test is_imm_start(cur)
0xffff850e: 80 5a                         #             jz      fpsm_reject         ; if !is_imm_start(cur), this state rejects
0xffff8510: b4 0a                         #             call    read_immediate      ; otherwise, read the immediate
0xffff8512: 58 3f                         #             movz    %r1, 31             ; validate_u5 in %r0; see 'validate_u5' below
0xffff8514: 23 04                         #             cmpd    %r0, %r1            ; set 'be' condition if imm is valid
0xffff8516: 89 56                         #             ja      fpsm_invalid_imm    ; if not 'be' condition, imm is invalid. Die.
0xffff8518: 19 60                         #             movx    %r3, %r0            ; imm = read & validated immediate
0xffff851a: 59 2d                         #             mov     %r1, 13             ; state = 13
0xffff851c: 8e 54                         #             jmp     fpsm_iterate        ; break
0xffff851e:                               # fpsm_3:
0xffff851e: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8522: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8524: 81 0a                         #             jne     fpsm_3_label        ; if not equal, try checking label
0xffff8526: b5 66                         #             call    read_register       ; if yes equal, read a register
0xffff8528: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff852a: 59 2e                         #             mov     %r1, 14             ; state = 14
0xffff852c: 8e 44                         #             jmp     fpsm_iterate        ; break
0xffff852e:                               # fpsm_3_label:
0xffff852e: b6 b4                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff8530: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff8532: 80 36                         #             jz      fpsm_reject         ; if !is_alpha(cur), this state rejects
0xffff8534: b4 5c                         #             call    read_name           ; r0 = read_name()
0xffff8536: 29 80                         #             movd    %r4, %r0            ; symbolptr = read_name()
0xffff8538: 59 2f                         #             mov     %r1, 15             ; state = 15
0xffff853a: 8e 36                         #             jmp     fpsm_iterate        ; break
0xffff853c:                               # fpsm_4:
0xffff853c: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8540: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8542: 81 26                         #             jne     fpsm_reject         ; if not a register, this state rejects
0xffff8544: b5 48                         #             call    read_register       ; r0 = read_register()
0xffff8546: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff8548: 59 2c                         #             mov     %r1, 12             ; state = 12
0xffff854a: 8e 26                         #             jmp     fpsm_iterate        ; break
0xffff854c:                               # fpsm_5:
0xffff854c: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8550: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8552: 81 16                         #             jne     fpsm_reject         ; if not a register, this state rejects
0xffff8554: b5 38                         #             call    read_register       ; r0 = read_register()
0xffff8556: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0xffff8558: 59 26                         #             mov     %r1, 6              ; state = 6
0xffff855a:                               # fpsm_scan_comma:
0xffff855a: b3 60                         #             call    skip_whitespace     ; skip whitespace between reg and comma
0xffff855c: 58 01 5c 0c                   #             mov     %r0, 44             ; r0 = ',' to check
0xffff8560: b5 54                         #             call    match               ; r0 = (cur != ',')
0xffff8562: 47 1f                         #             testh   %r0, -1             ; test (cur != ',')
0xffff8564: 81 04                         #             jnz     fpsm_reject         ; if it's not a comma, that's an error
0xffff8566: 8e 0a                         #             jmp     fpsm_iterate        ; break
0xffff8568:                               # fpsm_reject:
0xffff8568: 59 00                         #             mov     %r0, 0              ; r0 = INVALID_SYNTAX_CODE
0xffff856a: b6 fc                         #             call    die
0xffff856c:                               # fpsm_invalid_imm:
0xffff856c: 59 02                         #             mov     %r0, 2              ; r0 = INVALID_IMMEDIATE_CODE
0xffff856e: b6 f8                         #             call    die
0xffff8570:                               # fpsm_iterate:
0xffff8570: b3 4a                         #             call    skip_whitespace
0xffff8572: 43 2a                         #             cmph    %r1, 10             ; compare state to 10
0xffff8574: 89 e2                         #             ja      fpsm_eol            ; if bigger, go to the eol+accept check
0xffff8576: b0 16                         #             call    fpsm_iterate_2      ; put the address of the action table in r7
0xffff8578:                               # fpsm_action_table:
0xffff8578: 68 85                         #             .word   fpsm_reject & 0xFFFF
0xffff857a: ce 84                         #             .word   fpsm_1 & 0xFFFF
0xffff857c: fa 84                         #             .word   fpsm_2 & 0xFFFF
0xffff857e: 1e 85                         #             .word   fpsm_3 & 0xFFFF
0xffff8580: 3c 85                         #             .word   fpsm_4 & 0xFFFF
0xffff8582: 4c 85                         #             .word   fpsm_5 & 0xFFFF
0xffff8584: 96 85                         #             .word   fpsm_6 & 0xFFFF
0xffff8586: e6 85                         #             .word   fpsm_7 & 0xFFFF
0xffff8588: fc 85                         #             .word   fpsm_8 & 0xFFFF
0xffff858a: 3e 86                         #             .word   fpsm_9 & 0xFFFF
0xffff858c:                               # fpsm_iterate_2:
0xffff858c: 00 24                         #             addh    %r1, %r1            ; state *= sizeof(word)
0xffff858e: 20 3c                         #             addd    %r1, %r7            ; r1 = pointer to pointer switch case
0xffff8590: 1a 24                         #             ldx     %r1, %r1            ; r1 = pointer to switch case (16 bit)
0xffff8592: 19 24                         #             movsx   %r1, %r1            ; r1 = sext16(r1)
0xffff8594: af 2e                         #             jmp     %r1                 ; follow the yellow brick road
0xffff8596:                               # fpsm_6:
0xffff8596: 0a 98                         #             ldh     %r4, %sp            ; r4 = opc, bottom stack slot
0xffff8598: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff859c: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff859e: 81 0e                         #             jne     fpsm_6_imm          ; if not a register, try checking immediate
0xffff85a0: 43 8c                         #             cmph    %r4, 12             ; opc == OPC_SLO?
0xffff85a2: 90 c6                         #             je      fpsm_reject         ; this state rejects OPC_SLO
0xffff85a4: b4 e8                         #             call    read_register       ; r0 = read_register()
0xffff85a6: 09 60                         #             movh    %r3, %r0            ; regR = read_register()
0xffff85a8: 58 30                         #             mov     %r1, 16             ; state = 16
0xffff85aa: 9e c6                         #             jmp     fpsm_iterate        ; break
0xffff85ac:                               # fpsm_6_imm:
0xffff85ac: b6 64                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0xffff85ae: 57 1f                         #             test    %r0, -1             ; test is_imm_start(cur)
0xffff85b0: 80 1e                         #             jz      fpsm_6_symbol       ; if not, we still must check for .set symbols
0xffff85b2: b3 68                         #             call    read_immediate      ; r0 = read_immediate()
0xffff85b4:                               # fpsm_6_validate_imm:
0xffff85b4: 43 8a                         #             cmph    %r4, 10             ; opc >= 10?
0xffff85b6: 85 0c                         #             jae     fpsm_6_u5           ; if yes, validate unsigned
0xffff85b8: 43 88                         #             cmph    %r4, 8              ; opc == 8?
0xffff85ba: 80 08                         #             je      fpsm_6_u5           ; if yes, validate unsigned
0xffff85bc:                               # fpsm_6_s5:
0xffff85bc: b6 14                         #             call    validate_s5         ; r0 unchanged, flags set 'b' if valid
0xffff85be: 95 ae                         #             jae     fpsm_invalid_imm    ; if not 'b' condition, imm is invalid. Die.
0xffff85c0: 8e 08                         #             jmp     fpsm_6_end          ; clean up
0xffff85c2:                               # fpsm_6_u5:
0xffff85c2: 58 3f                         #             movz    %r1, 31             ; validate_u5 in %r0; see 'validate_u5' below
0xffff85c4: 23 04                         #             cmpd    %r0, %r1            ; set 'be' condition if imm is valid
0xffff85c6: 99 a6                         #             ja      fpsm_invalid_imm    ; if not 'be' condition, imm is invalid. Die.
0xffff85c8:                               # fpsm_6_end:
0xffff85c8: 19 60                         #             movx    %r3, %r0            ; It's valid. Save it: imm = r0
0xffff85ca: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff85cc: 9e a4                         #             jmp     fpsm_iterate        ; break
0xffff85ce:                               # fpsm_6_symbol:
0xffff85ce: b6 14                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff85d0: 47 1f                         #             testh   %r0, -1             ; if it's not, this state is out of options and rejects
0xffff85d2: 90 96                         #             jz      fpsm_reject
0xffff85d4: b3 bc                         #             call    read_name           ; r0 = read_name()
0xffff85d6: 09 94                         #             movh    %r4, %r5            ; hide cur in %r4
0xffff85d8: 59 a8                         #             mov     %r5, 8              ; offset of stack slot for &static_data
0xffff85da: 20 b8                         #             addd    %r5, %sp
0xffff85dc: 2a b4                         #             ldd     %r5, %r5            ; r5 = &static_data
0xffff85de: bc 74                         #             call    fp_get_symbol       ; clobbers r1 and r3. nothing in r3 (yet). r2 has regL
0xffff85e0: 09 b0                         #             movh    %r5, %r4            ; return cur to %r5
0xffff85e2: bc b4                         #             call    sp_get_symbol       ; r0 = payload from entry if it's valid.
0xffff85e4: 9e d0                         #             jmp     fpsm_6_validate_imm ; validate that immediate.
0xffff85e6:                               # fpsm_7:
0xffff85e6: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff85ea: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff85ec: 91 7c                         #             jne     fpsm_reject         ; if not register, this state rejects
0xffff85ee: b3 d8                         #             call    read_any_register   ; r0 = read_any_register()
0xffff85f0: 09 40                         #             movh    %r2, %r0            ; regL = read_any_register()
0xffff85f2: 43 48                         #             cmph    %r2, 8              ; regL <? 8
0xffff85f4: 59 28                         #             mov     %r1, 8              ; state = 8
0xffff85f6: 94 64                         #             jb      fpsm_scan_comma     ; if regL < 8, scan comma
0xffff85f8: 59 29                         #             mov     %r1, 9              ; otherwise, state = 9
0xffff85fa: 9e 60                         #             jmp     fpsm_scan_comma     ; then scan comma
0xffff85fc:                               # fpsm_8:
0xffff85fc: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8600: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0xffff8602: 81 18                         #             jne     fpsm_8_imm          ; if not register, try immediate
0xffff8604: b3 c2                         #             call    read_any_register   ; r0 = read_any_register()
0xffff8606: 09 60                         #             movh    %r3, %r0            ; regR = read_any_register()
0xffff8608: 43 68                         #             cmph    %r3, 8              ; regR <? 8
0xffff860a: 8b 06                         #             jge     fpsm_8_ctrl_reg     ; if regR >= 8, it's a control reg
0xffff860c: 58 30                         #             mov     %r1, 16             ; state = 16
0xffff860e: 9e 62                         #             jmp     fpsm_iterate        ; break
0xffff8610:                               # fpsm_8_ctrl_reg:
0xffff8610: 41 68                         #             subh    %r3, 8              ; imm = regR - 8
0xffff8612: 60 c4                         #             addd    %sp, 4              ; pop opc off the stack
0xffff8614: 6d ce                         #             pushd   14                  ; overwrite opc with 14
0xffff8616: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff8618: 9e 58                         #             jmp     fpsm_iterate        ; break
0xffff861a:                               # fpsm_8_imm:
0xffff861a: b5 f6                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0xffff861c: 47 1f                         #             testh   %r0, -1             ; test is_imm_start(cur)
0xffff861e: 80 12                         #             jz      fpsm_8_label        ; if not an imm, try label
0xffff8620: b2 fa                         #             call    read_immediate      ; r0 = read_immediate()
0xffff8622: b5 ae                         #             call    validate_s5         ; set 'b' if r0 is a valid s5
0xffff8624: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff8626: 29 60                         #             movd    %r3, %r0            ; imm = read_immediate()
0xffff8628: 94 48                         #             jb      fpsm_iterate        ; break, if imm is a valid s5
0xffff862a: 59 80                         #             mov     %r4, 0              ; symbolptr = NULL
0xffff862c: 58 32                         #             mov     %r1, 18             ; state = 18
0xffff862e: 9e 42                         #             jmp     fpsm_iterate        ; break
0xffff8630:                               # fpsm_8_label:
0xffff8630: b5 b2                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff8632: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff8634: 90 34                         #             jz      fpsm_reject         ; if !is_alpha(cur), finally this state rejects.
0xffff8636: b3 5a                         #             call    read_name           ; r0 = read_name()
0xffff8638: 29 80                         #             movd    %r4, %r0            ; symbolptr = read_name()
0xffff863a: 58 32                         #             mov     %r1, 18             ; state = 18
0xffff863c: 9e 34                         #             jmp     fpsm_iterate        ; break
0xffff863e:                               # fpsm_9:
0xffff863e: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0xffff8642: 03 a0                         #             cmph    %r5, %r0            ; r0 == '%'?
0xffff8644: 91 24                         #             jne     fpsm_reject         ; if not a register, this state rejects
0xffff8646: 09 68                         #             movh    %r3, %r2            ; imm = regL
0xffff8648: 41 68                         #             subh    %r3, 8              ; imm -= 8
0xffff864a: b4 42                         #             call    read_register       ; r0 = read_register()
0xffff864c: 09 40                         #             movh    %r2, %r0            ; r2 = read_register()
0xffff864e: 60 c4                         #             addd    %sp, 4              ; pop opc off the stack
0xffff8650: 6d cf                         #             pushd   15                  ; overwrite opc with 15
0xffff8652: 58 31                         #             mov     %r1, 17             ; state = 17
0xffff8654: 9e 1c                         #             jmp     fpsm_iterate
0xffff8656:                               # fpsm_eol:
0xffff8656: b5 ec                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0xffff8658: 47 1f                         #             testh   %r0, -1             ; test is_eol(cur)
0xffff865a: 90 0e                         #             jz      fpsm_reject         ; if it's not eol (somehow?) reject!
0xffff865c:                               # fpsm_accept:
0xffff865c: 59 e8                         #             mov     %r7, 8              ; offset of &static_data on the stack
0xffff865e: 20 f8                         #             addd    %r7, %sp            ; point at stack slot of &static_data
0xffff8660: 2a fc                         #             ldd     %r7, %r7            ; r7 = &static_data
0xffff8662: 60 e8                         #             addd    %r7, EOL_CHAR_OFS   ; r7 = &static_data.eol_char
0xffff8664: 0b bc                         #             sth     %r5, %r7            ; static_data->eol_char = cur
0xffff8666: 09 a4                         #             movh    %r5, %r1            ; r5 = state, temporarily
0xffff8668: 09 08                         #             movh    %r0, %r2            ; arg 0 = regL
0xffff866a: 19 2c                         #             movx    %r1, %r3            ; arg 1 = regR/imm
0xffff866c: 2c 58                         #             popd    %r2                 ; arg 2 = opcode
0xffff866e: 2c 78                         #             popd    %r3                 ; arg 3 = size_bits
0xffff8670: b0 12                         #             call    fpsm_accept_exit    ; get the address of the table into r7
0xffff8672:                               # fpsm_accept_jump_table:
0xffff8672: ae 82                         #             .word   fp_0  & 0xFFFF
0xffff8674: 5a 83                         #             .word   fp_R  & 0xFFFF
0xffff8676: 68 83                         #             .word   fp_I  & 0xFFFF
0xffff8678: c4 82                         #             .word   fp_RJ & 0xFFFF
0xffff867a: 9a 83                         #             .word   fp_LJ & 0xFFFF
0xffff867c: 22 83                         #             .word   fp_RR & 0xFFFF
0xffff867e: 3c 83                         #             .word   fp_RI & 0xFFFF
0xffff8680: 6c 83                         #             .word   fp_LM & 0xFFFF
0xffff8682:                               # fpsm_accept_exit:
0xffff8682: 41 ab                         #             subh    %r5, 11             ; offset = state - 11
0xffff8684: 00 b4                         #             addh    %r5, %r5            ; offset *= sizeof(word)
0xffff8686: 20 f4                         #             addd    %r7, %r5            ; r7 = pointer to address to jump to
0xffff8688: 1a fc                         #             ldx     %r7, %r7            ; r7 = address to jump to (16 bit)
0xffff868a: 19 fc                         #             movsx   %r7, %r7            ; r7 = full address to jump to (32-bit)
0xffff868c: 2c b8                         #             popd    %r5                 ; r5 = &static_data. Hooray!
0xffff868e: af ee                         #             jmp     %r7                 ; tail-call the assembling function
0xffff8690:                               # die_out_of_range:
0xffff8690: 59 03                         #             mov     %r0, 3              ; OUT_OF_RANGE_CODE
0xffff8692: b5 d4                         #             call    die
0xffff8694:                               # die_missing_feature:
0xffff8694: 59 05                         #             mov     %r0, 5              ; missing feature code
0xffff8696: b5 d0                         #             call    die
0xffff8698:                               # die_unknown_symbol:
0xffff8698: 59 06                         #             mov     %r0, 6              ; unknown symbol code
0xffff869a: b5 cc                         #             call    die
0xffff869c:                               # strncmp:
0xffff869c: 2d cc                         #             pushd   %r3             ; wind stack, giving two free registers
0xffff869e: 2d d0                         #             pushd   %r4             ; which we will use to hold *a and *b
0xffff86a0:                               # strncmp_L1:                         ; top of loop
0xffff86a0: 0a 60                         #             ldh     %r3, %r0        ; r3 = *a
0xffff86a2: 0a 84                         #             ldh     %r4, %r1        ; r4 = *b
0xffff86a4: 01 8c                         #             subh    %r4, %r3        ; subtract *a from *b
0xffff86a6: 81 0e                         #             jne     strncmp_L2      ; return if *a != *b
0xffff86a8: 47 7f                         #             testh   %r3, -1         ; test *a
0xffff86aa: 80 0a                         #             jz      strncmp_L2      ; also return if *a == 0 (note *b - *a still in %r4)
0xffff86ac: 60 01                         #             addd    %r0, 1          ; ++a
0xffff86ae: 60 21                         #             addd    %r1, 1          ; ++b
0xffff86b0: 61 41                         #             subd    %r2, 1          ; --n
0xffff86b2: 99 ee                         #             ja      strncmp_L1      ; if n is > 0 (unsigned), loop
0xffff86b4:                               # strncmp_L2:                         ; return label
0xffff86b4: 09 10                         #             movh    %r0, %r4        ; return value is *b - *a
0xffff86b6: 2c 98                         #             popd    %r4             ; unwind stack
0xffff86b8: 2c 78                         #             popd    %r3
0xffff86ba: af ee                         #             ret
0xffff86bc:                               # encode_value:
0xffff86bc: 2d dc                         #             pushd   %ln
0xffff86be:                               # encode_value_stkret:
0xffff86be: 2a e8                         #             ldd     %ln, %r2            ; iloc = static_data->asm_ip
0xffff86c0: 2d c0                         #             pushd   %r0                 ; put value on the stack so we can pop one byte at a time
0xffff86c2:                               # encode_value_loop:
0xffff86c2: 0c 18                         #             poph    %r0                 ; pop 1 byte of the value
0xffff86c4: 0b 1c                         #             sth     %r0, %ln            ; *iloc = *val
0xffff86c6: 60 e1                         #             addd    %ln, 1              ; iloc++
0xffff86c8: 41 21                         #             subh    %r1, 1              ; numbytes--
0xffff86ca: 91 f8                         #             jnz     encode_value_loop   ; if numbytes is now 0, we're done. Owise loop
0xffff86cc: 60 c3                         #             addd    %sp, 3
0xffff86ce: 66 dc                         #             andd    %sp, -4             ; re-align the stack pointer
0xffff86d0: 2b e8                         #             std     %ln, %r2            ; static_data->asm_ip = iloc
0xffff86d2: 2c f8                         #             popd    %ln
0xffff86d4: af ee                         #             ret
0xffff86d6:                               # set_directive:
0xffff86d6: 2d dc                         #             pushd   %ln
0xffff86d8: 2d c0                         #             pushd   %r0                 ; skip_whitespace clobbers this
0xffff86da: 2d c4                         #             pushd   %r1                 ; is_alpha clobbers this
0xffff86dc: 2d c8                         #             pushd   %r2                 ; ste_attach_payload clobbers this
0xffff86de: 2d cc                         #             pushd   %r3                 ; ste_attach_payload clobbers this
0xffff86e0: b5 02                         #             call    cur_is_alpha        ; r0 = boolean cur is alpha?
0xffff86e2: 47 1f                         #             testh   %r0, -1             ; if it is not (r0 == 0), reject
0xffff86e4: 80 2c                         #             jz      set_directive_reject
0xffff86e6: b2 a6                         #             call    read_name_with_sd   ; read a name, &static_data is still in r2
0xffff86e8: 2d c0                         #             pushd   %r0                 ; and immediately save it on the stack
0xffff86ea: b1 d0                         #             call    skip_whitespace     ; skip whitespace between name and value
0xffff86ec: b5 24                         #             call    cur_is_imm_start    ; check syntax: next character starts imm?
0xffff86ee: 47 1f                         #             testh   %r0, -1             ; if it's not (r0 == 0), reject
0xffff86f0: 80 20                         #             jz      set_directive_reject
0xffff86f2: b2 28                         #             call    read_immediate      ; read a number
0xffff86f4: 2d c0                         #             pushd   %r0                 ; and immediately save it on the stack
0xffff86f6: b1 c4                         #             call    skip_whitespace     ; read to end-of-line (hopefully)
0xffff86f8: b5 4a                         #             call    cur_is_eol          ; check syntax: at the end of line?
0xffff86fa: 47 1f                         #             testh   %r0, -1             ; if not, reject
0xffff86fc: 80 14                         #             jz      set_directive_reject
0xffff86fe: 2c 38                         #             popd    %r1                 ; pop the number we read to arg 1
0xffff8700: 2c 18                         #             popd    %r0                 ; pop the name we read to arg 0
0xffff8702: ba a8                         #             call    ste_attach_payload  ; attach the value to that name
0xffff8704: 2c 78                         #             popd    %r3
0xffff8706: 2c 58                         #             popd    %r2
0xffff8708: 2c 38                         #             popd    %r1
0xffff870a: 2c 18                         #             popd    %r0
0xffff870c: 2c f8                         #             popd    %ln
0xffff870e: af ee                         #             ret
0xffff8710:                               # set_directive_reject:
0xffff8710: be 58                         #             call    fpsm_reject
0xffff8712:                               # value_directive:
0xffff8712: 2d dc                         #             pushd   %ln
0xffff8714: 09 80                         #             movh    %r4, %r0            ; save byte_size in %r4, which nothing clobbers.
0xffff8716: 8e 04                         #             jmp value_directive_loop    ; enter loop without skipping whitespace
0xffff8718:                               # value_directive_skip_ws:
0xffff8718: b1 a2                         #             call    skip_whitespace
0xffff871a:                               # value_directive_loop:
0xffff871a: b4 f6                         #             call    cur_is_imm_start    ; can cur start an immediate?
0xffff871c: 47 1f                         #             testh   %r0, -1             ; check result
0xffff871e: 80 0a                         #             jz      value_directive_try_name ; if not, try reading a name
0xffff8720: b1 fa                         #             call    read_immediate      ; read an immediate into r0 = arg 0
0xffff8722: 09 30                         #             movh    %r1, %r4            ; arg 1 = byte_size
0xffff8724: bf 98                         #             call    encode_value        ; arg 2 is still static_data
0xffff8726: 9e f2                         #             jmp     value_directive_skip_ws
0xffff8728:                               # value_directive_try_name:
0xffff8728: b4 ba                         #             call    cur_is_alpha        ; can cur start a name?
0xffff872a: 47 1f                         #             testh   %r0, -1             ; check result
0xffff872c: 80 2a                         #             jz      value_directive_try_eol ; if not, ensure we're at EOL
0xffff872e: b2 5e                         #             call    read_name_with_sd   ; we do have &static_data in r2
0xffff8730: 2d d4                         #             pushd   %r5                 ; save cur, fp_get_symbol needs static data in r5
0xffff8732: 29 a8                         #             movd    %r5, %r2            ; setup for fp_get_symbol
0xffff8734: bb 1e                         #             call    fp_get_symbol       ; clobbers %r1 and %r3, which we're not using
0xffff8736: 67 1f                         #             testd   %r0, -1             ; is the entry NULL?
0xffff8738: 80 0e                         #             jz      value_directive_no_entry ; if yes, prepare the relocation.
0xffff873a: ba 86                         #             call    ste_get_payload     ; arg 0 = entry->payload
0xffff873c: 09 30                         #             movh    %r1, %r4            ; arg 1 = byte_size
0xffff873e: 29 54                         #             movd    %r2, %r5            ; arg 2 = &static_data
0xffff8740: 2c b8                         #             popd    %r5                 ; restore cur to r5
0xffff8742: bf 7a                         #             call    encode_value
0xffff8744: 9e d4                         #             jmp     value_directive_skip_ws
0xffff8746:                               # value_directive_no_entry:
0xffff8746: 09 10                         #             movh    %r0, %r4            ; r0 = byte_size
0xffff8748: 42 00                         #             rsubh   %r0, 0              ; arg 0 = 0 - byte_size
0xffff874a: 59 20                         #             mov     %r1, 0              ; arg 1 = 0 [according to the C code, this value shouldn't matter]
0xffff874c: 09 50                         #             movh    %r2, %r4            ; arg 2 = byte_size
0xffff874e: bb fa                         #             call    finalize_encoding_stdcall
0xffff8750: 29 54                         #             movd    %r2, %r5            ; return &static_data to r2
0xffff8752: 2c b8                         #             popd    %r5                 ; restore cur to r5 off the stack
0xffff8754: 9e c4                         #             jmp     value_directive_skip_ws
0xffff8756:                               # value_directive_try_eol:
0xffff8756: b4 ec                         #             call    cur_is_eol          ; is cur end-of-line?
0xffff8758: 47 1f                         #             testh   %r0, -1             ; check result
0xffff875a: 81 04                         #             jnz     value_directive_ret ; if yes, return. yay!
0xffff875c: be 0c                         #             call    fpsm_reject         ; otherwise reject the program.
0xffff875e:                               # value_directive_ret:
0xffff875e: 2c f8                         #             popd    %ln
0xffff8760: af ee                         #             ret
0xffff8762:                               # align_directive:
0xffff8762: 2d dc                         #             pushd   %ln
0xffff8764: b4 ba                         #             call    cur_is_num          ; can cur start a POSITIVE number?
0xffff8766: 47 1f                         #             testh   %r0, -1
0xffff8768: 80 1a                         #             jz      align_directive_reject ; if not, reject the program
0xffff876a: b1 b0                         #             call    read_immediate      ; r0 = byte_size from read_immediate
0xffff876c: 29 60                         #             movd    %r3, %r0            ; move it to r3. Move the full 32-bit value
0xffff876e: b1 4c                         #             call    skip_whitespace     ; skip whitespace after the number
0xffff8770: b4 d2                         #             call    cur_is_eol          ; are we at end-of-line?
0xffff8772: 47 1f                         #             testh   %r0, -1
0xffff8774: 80 0e                         #             jz      align_directive_reject ; if not, reject the program.
0xffff8776: 63 61                         #             cmpd    %r3, 1              ; is byte_size 1?
0xffff8778: 80 0c                         #             je      align_directive_ok  ; if yes, acceptable
0xffff877a: 63 62                         #             cmpd    %r3, 2
0xffff877c: 80 08                         #             je      align_directive_ok  ; 2 is also acceptable
0xffff877e: 63 64                         #             cmpd    %r3, 4
0xffff8780: 80 04                         #             je      align_directive_ok  ; and finally, so is 4.
0xffff8782:                               # align_directive_reject:
0xffff8782: bd e6                         #             call    fpsm_reject
0xffff8784:                               # align_directive_ok:
0xffff8784: 2a 08                         #             ldd     %r0, %r2            ; r0 = ip = static_data->asm_ip
0xffff8786: 20 0c                         #             addd    %r0, %r3            ; ip += byte_size
0xffff8788: 60 1f                         #             addd    %r0, -1             ; ip -= 1
0xffff878a: 42 60                         #             rsubh   %r3, 0              ; -byte_size
0xffff878c: 26 0c                         #             andd    %r0, %r3            ; ip &= -byte_size
0xffff878e: 2b 08                         #             std     %r0, %r2            ; static_data->asm_ip = ip
0xffff8790: 2c f8                         #             popd    %ln
0xffff8792: af ee                         #             ret
0xffff8794:                               # ascii_directive:
0xffff8794: 58 21 5c 22                   #             mov     %r1, 34             ; '"'
0xffff8798: 03 a4                         #             cmph    %r5, %r1            ; is cur '"' ?
0xffff879a: 81 54                         #             jne     ascii_directive_reject ; if not, reject the program
0xffff879c: 2d dc                         #             pushd   %ln
0xffff879e: 19 80                         #             mov     %r4, %r0            ; store add_terminator in r4 until we need to check it
0xffff87a0: 2a 68                         #             ldd     %r3, %r2            ; iloc = static_data->asm_ip
0xffff87a2: 8e 38                         #             jmp     ascii_directive_check ; enter the loop, don't assume that the string is empty.
0xffff87a4:                               # ascii_directive_loop:
0xffff87a4: b4 9e                         #             call    cur_is_eol          ; is cur an EOL ?
0xffff87a6: 47 1f                         #             testh   %r0, -1
0xffff87a8: 81 46                         #             jnz     ascii_directive_reject ; if YES, reject the program
0xffff87aa: 58 22 5c 3c                   #             mov     %r1, 92             ; '\'
0xffff87ae: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '\'
0xffff87b0: 81 26                         #             jne     ascii_directive_enc ; if not, encode it directly
0xffff87b2: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar();
0xffff87b4: 03 a4                         #             cmph    %r5, %r1            ; new cur == '\' too?
0xffff87b6: 80 20                         #             je      ascii_directive_enc ; if yes, encode a '\'
0xffff87b8: 58 23 5c 2e                   #             mov     %r1, 110            ; 'n'
0xffff87bc: 03 a4                         #             cmph    %r5, %r1            ; cur ==? 'n'
0xffff87be: 81 06                         #             jne     ascii_directive_try_q ; if not, try a quote
0xffff87c0: 59 aa                         #             mov     %r5, 10             ; if yes, encode a '\n'
0xffff87c2: 8e 14                         #             jmp     ascii_directive_enc
0xffff87c4:                               # ascii_directive_try_q:
0xffff87c4: 58 21 5c 22                   #             mov     %r1, 34             ; '"'
0xffff87c8: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '"'
0xffff87ca: 80 0c                         #             je      ascii_directive_enc ; if yes, encode a '"'
0xffff87cc: 58 21 5c 30                   #             mov     %r1, 48             ; '0'
0xffff87d0: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '0'
0xffff87d2: 81 1c                         #             jne     ascii_directive_reject ; if it's not, unknown escape! reject the program.
0xffff87d4: 59 a0                         #             mov     %r5, 0              ; but if it is, encode a 0.
0xffff87d6:                               # ascii_directive_enc:
0xffff87d6: 0b ac                         #             sth     %r5, %r3            ; *iloc = encode
0xffff87d8: 60 61                         #             addd    %r3, 1              ; iloc++
0xffff87da:                               # ascii_directive_check:
0xffff87da: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff87dc: 58 21 5c 22                   #             mov     %r1, 34             ; '"'
0xffff87e0: 03 a4                         #             cmph    %r5, %r1            ; cur ==? '"'
0xffff87e2: 91 c2                         #             jne     ascii_directive_loop ; if not, string is still going, loop.
0xffff87e4: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar(), advance past the closing "
0xffff87e6: b0 d4                         #             call    skip_whitespace     ; read (hopefully) to EOL
0xffff87e8: b4 5a                         #             call    cur_is_eol          ; is cur the EOL?
0xffff87ea: 47 1f                         #             testh   %r0, -1
0xffff87ec: 81 04                         #             jnz     ascii_directive_nul ; if yes, we can proceed to the terminator check
0xffff87ee:                               # ascii_directive_reject:                 ; but if not, reject the program.
0xffff87ee: bd 7a                         #             call    fpsm_reject
0xffff87f0:                               # ascii_directive_nul:
0xffff87f0: 47 9f                         #             testh   %r4, -1             ; should we add a terminator?
0xffff87f2: 80 08                         #             jz      ascii_directive_done; if not, we can clean up.
0xffff87f4: 59 20                         #             mov     %r1, 0
0xffff87f6: 0b 2c                         #             sth     %r1, %r3            ; *iloc = 0
0xffff87f8: 60 61                         #             addd    %r3, 1              ; iloc++
0xffff87fa:                               # ascii_directive_done:
0xffff87fa: 2b 68                         #             std     %r3, %r2            ; static_data->asm_ip = iloc
0xffff87fc: 2c f8                         #             popd    %ln
0xffff87fe: af ee                         #             ret
0xffff8800:                               # asm_directive:
0xffff8800: 2d c0                         #             pushd   %r0                 ; save directive_name. Easily retrieved with ldd
0xffff8802: 29 68                         #             movd    %r3, %r2            ; %r2 is needed for strncmp calls, save in r3
0xffff8804: b0 2a                         #             call    asm_directive_with_strings
0xffff8806: 73 65 74 00                   #             .asciiz  "set"
0xffff880a: 68 61 6c 66 00                #             .asciiz  "half"
0xffff880f: 77 6f 72 64 00                #             .asciiz  "word"
0xffff8814: 64 77 6f 72 64 00             #             .asciiz  "dword"
0xffff881a: 61 6c 69 67 6e 00             #             .asciiz  "align"
0xffff8820: 61 73 63 69 69 7a 00          #             .asciiz  "asciiz"
0xffff8827: 61 73 63 69 69 00             #             .asciiz  "ascii"
0xffff882d: 00                            # 
0xffff882e:                               # asm_directive_with_strings:
0xffff882e: 29 3c                         #             movd    %r1, %ln            ; now pointer to "set\0" is in r1
0xffff8830: 59 44                         #             mov     %r2, 4              ; compare 4 characters
0xffff8832: be 6a                         #             call    strncmp             ; r0 = 0 if strings are equal
0xffff8834: 81 08                         #             jne     asm_directive_half  ; if unequal, try half
0xffff8836: 29 4c                         #             movd    %r2, %r3            ; restore &static_data
0xffff8838: be 9e                         #             call    set_directive
0xffff883a: 8e 72                         #             jmp     asm_directive_end
0xffff883c:                               # asm_directive_half:
0xffff883c: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff883e: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "half\0"
0xffff8840: 59 45                         #             mov     %r2, 5              ; compare 5 characters
0xffff8842: be 5a                         #             call    strncmp
0xffff8844: 81 0a                         #             jne     asm_directive_word  ; if unequal, try word
0xffff8846: 29 4c                         #             movd    %r2, %r3
0xffff8848: 59 01                         #             mov     %r0, 1
0xffff884a: be c8                         #             call    value_directive
0xffff884c: 8e 60                         #             jmp     asm_directive_end
0xffff884e:                               # asm_directive_word:
0xffff884e: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8850: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "word\0"
0xffff8852: 59 45                         #             mov     %r2, 5              ; compare 5 characters
0xffff8854: be 48                         #             call    strncmp
0xffff8856: 81 0a                         #             jne     asm_directive_dword ; if unequal, try dword
0xffff8858: 29 4c                         #             movd    %r2, %r3
0xffff885a: 59 02                         #             mov     %r0, 2
0xffff885c: be b6                         #             call    value_directive
0xffff885e: 8e 4e                         #             jmp     asm_directive_end
0xffff8860:                               # asm_directive_dword:
0xffff8860: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8862: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "dword\0"
0xffff8864: 59 46                         #             mov     %r2, 6              ; compare 6 characters
0xffff8866: be 36                         #             call    strncmp
0xffff8868: 81 0a                         #             jne     asm_directive_align ; if unequal, try align
0xffff886a: 29 4c                         #             movd    %r2, %r3
0xffff886c: 59 04                         #             mov     %r0, 4
0xffff886e: be a4                         #             call    value_directive
0xffff8870: 8e 3c                         #             jmp     asm_directive_end
0xffff8872:                               # asm_directive_align:
0xffff8872: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8874: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "align\0"
0xffff8876: 59 46                         #             mov     %r2, 6              ; compare 6 characters
0xffff8878: be 24                         #             call    strncmp
0xffff887a: 81 08                         #             jne     asm_directive_asciiz; if unequal, try asciiz
0xffff887c: 29 4c                         #             movd    %r2, %r3
0xffff887e: be e4                         #             call    align_directive
0xffff8880: 8e 2c                         #             jmp     asm_directive_end
0xffff8882:                               # asm_directive_asciiz:
0xffff8882: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8884: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "asciiz\0"
0xffff8886: 59 47                         #             mov     %r2, 7              ; compare 7 characters
0xffff8888: be 14                         #             call    strncmp
0xffff888a: 81 0a                         #             jne     asm_directive_ascii ; if unequal, try ascii
0xffff888c: 29 4c                         #             movd    %r2, %r3
0xffff888e: 59 01                         #             mov     %r0, 1              ; do include NUL terminator
0xffff8890: bf 04                         #             call    ascii_directive
0xffff8892: 8e 1a                         #             jmp     asm_directive_end
0xffff8894:                               # asm_directive_ascii:
0xffff8894: 2a 18                         #             ldd     %r0, %sp            ; r0 = directive_name
0xffff8896: 20 28                         #             addd    %r1, %r2            ; r1 = pointer to "ascii\0"
0xffff8898: 59 46                         #             mov     %r2, 6              ; compare 6 characters
0xffff889a: be 02                         #             call    strncmp
0xffff889c: 81 0a                         #             jne     asm_directive_reject; if unequal, unknown directive. reject
0xffff889e: 29 4c                         #             movd    %r2, %r3
0xffff88a0: 59 00                         #             mov     %r0, 0              ; do not include NUL terminator
0xffff88a2: be f2                         #             call    ascii_directive
0xffff88a4: 8e 08                         #             jmp     asm_directive_end
0xffff88a6:                               # asm_directive_reject:
0xffff88a6: 59 07                         #             mov     %r0, 7              ; arg 0 = UNKNOWN_DIRECTIVE
0xffff88a8: 2a 38                         #             ldd     %r1, %sp            ; arg 1 = directive_name
0xffff88aa: b3 bc                         #             call    die                 ; die unknown directive
0xffff88ac:                               # asm_directive_end:
0xffff88ac: 29 08                         #             movd    %r0, %r2            ; &static_data
0xffff88ae: 60 08                         #             addd    %r0, EOL_CHAR_OFS   ; &static_data->eol_char
0xffff88b0: 0b a0                         #             sth     %r5, %r0            ; static_data->eol_char = cur
0xffff88b2: 29 a8                         #             movd    %r5, %r2            ; return &static_data to r5
0xffff88b4: 60 c4                         #             addd    %sp, 4              ; pop directive_name
0xffff88b6: 2c f8                         #             popd    %ln
0xffff88b8: af ee                         #             ret
0xffff88ba:                               # skip_whitespace:
0xffff88ba: 58 01 5c 00                   #             mov     %r0, 32             ; r0 = ' ' for comparison
0xffff88be: 8e 04                         #             jmp     skip_whitespace_L2
0xffff88c0:                               # skip_whitespace_L1:
0xffff88c0: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff88c2:                               # skip_whitespace_L2:
0xffff88c2: 03 a0                         #             cmph    %r5, %r0            ; r5 ==? 32
0xffff88c4: 90 fc                         #             je      skip_whitespace_L1
0xffff88c6: 43 a9                         #             cmph    %r5, 9              ; r5 ==? '\t'
0xffff88c8: 90 f8                         #             je      skip_whitespace_L1
0xffff88ca: 58 01 5c 1b                   #             mov     %r0, 59             ; r0 = ';'
0xffff88ce: 03 a0                         #             cmph    %r5, %r0
0xffff88d0: af e1                         #             retne                       ; return if cur != ';'
0xffff88d2: 2d dc                         #             pushd   %ln
0xffff88d4:                               # skip_whitespace_L3:
0xffff88d4: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff88d6: b3 6c                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0xffff88d8: 47 1f                         #             testh   %r0, -1             ; test is_eol(cur)
0xffff88da: 90 fa                         #             jz      skip_whitespace_L3  ; loop as long as is_eol(cur) is false
0xffff88dc: 2c f8                         #             popd    %ln
0xffff88de: af ee                         #             ret
0xffff88e0:                               # read_size:
0xffff88e0: 2d dc                         #             pushd   %ln
0xffff88e2: b3 00                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0xffff88e4: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0xffff88e6: 59 02                         #             mov     %r0, 2              ; set return value for if !is_alpha(cur)
0xffff88e8: 80 22                         #             jz      read_size_ret
0xffff88ea: 58 23 5c 38                   #             mov     %r1, 120            ; r1 = 'x'
0xffff88ee: 01 a4                         #             subh    %r5, %r1            ; cur = cur - 'x'
0xffff88f0: 80 0e                         #             je      read_size_guard
0xffff88f2: 41 b0                         #             subh    %r5, -16            ; cur = cur + ('x' - 'h')
0xffff88f4: 59 00                         #             mov     %r0, 0              ; set return value for cur == 'h'
0xffff88f6: 80 08                         #             je      read_size_guard
0xffff88f8: 40 a4                         #             addh    %r5, 4              ; cur = cur + ('h' - 'd')
0xffff88fa: 59 02                         #             mov     %r0, 2              ; set return value for cur == 'd'
0xffff88fc: 81 12                         #             jne     read_size_kill      ; not valid suffix if cur != 'd' at this point
0xffff88fe:                               # read_size_guard:
0xffff88fe: 2d c0                         #             pushd   %r0                 ; spill return value
0xffff8900: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8902: b3 2a                         #             call    cur_is_alphanum     ; r0 = is_alphanum(cur)
0xffff8904: 47 1f                         #             testh   %r0, -1             ; test is_alphanum(cur)
0xffff8906: 81 08                         #             jnz     read_size_kill      ; crash if cur is alphanumeric
0xffff8908: 2c 18                         #             popd    %r0                 ; reload return value
0xffff890a:                               # read_size_ret:
0xffff890a: 2c f8                         #             popd    %ln
0xffff890c: af ee                         #             ret
0xffff890e:                               # read_size_kill:
0xffff890e: 59 00                         #             mov     %r0, 0              ; r0 = INVALID_SYNTAX_CODE
0xffff8910: b3 56                         #             call    die
0xffff8912:                               # shl_L1:
0xffff8912: 20 00                         #             addd    %r0, %r0        ; x <<= 1
0xffff8914:                               # shl:
0xffff8914: 41 21                         #             subh    %r1, 1          ; --shamt
0xffff8916: 93 fc                         #             jnn     shl_L1          ; exec loop if --shamt >= 0 === shamt > 0
0xffff8918: af ee                         #             ret
0xffff891a:                               # read_immediate:
0xffff891a: 2d c8                         #             pushd   %r2                 ; wind
0xffff891c: 58 01 5c 0d                   #             mov     %r0, 45             ; '-', this mov is 2 instructions
0xffff8920: 58 21 5c 30                   #             mov     %r1, 48             ; '0', this mov is also 2 instructions
0xffff8924: 02 14                         #             rsubh   %r0, %r5            ; r0 = r5 - 45
0xffff8926: 2d c0                         #             pushd   %r0                 ; save the result of this subtraction
0xffff8928: 81 04                         #             jne     read_immediate_radix; if cur was not '-', skip to hex check
0xffff892a: 4a a1                         #             ldh     %r5, STREAM         ; otherwise, read the first number.
0xffff892c:                               # read_immediate_radix:
0xffff892c: 09 14                         #             movh    %r0, %r5            ; imm = cur
0xffff892e: 01 04                         #             subh    %r0, %r1            ; imm -= 48 so imm = cur - '0'
0xffff8930: 4a a1                         #             ldh     %r5, STREAM         ; read next char
0xffff8932: 81 46                         #             jnz     read_immediate_dec_check ; if imm != 0, then old cur != '0', so we don't have hex.
0xffff8934: 58 43 5c 58                   #             mov     %r2, 120            ; 'x'
0xffff8938: 03 a8                         #             cmph    %r5, %r2            ; cur ==? 'x'
0xffff893a: 81 3e                         #             jne     read_immediate_dec_check ; if cur != 'x', we don't have hex.
0xffff893c: 19 44                         #             mov     %r2, %r1            ; hex loop needs r1 to be free, but still wants 48 around.
0xffff893e: 2d dc                         #             pushd   %ln                 ; the hex loop calls shl
0xffff8940: 8e 12                         #             jmp     read_immediate_hex_check 
0xffff8942:                               # read_immediate_hex_letter:
0xffff8942: 40 aa                         #             addh    %r5, 10             ; adjust for 'A' being hex 10
0xffff8944: 59 24                         #             mov     %r1, 4
0xffff8946: bf ce                         #             call    shl
0xffff8948: 20 14                         #             addd    %r0, %r5            ; imm += cur - 'A' + 10
0xffff894a: 8e 08                         #             jmp     read_immediate_hex_check ; continue            
0xffff894c:                               # read_immediate_hex_num:
0xffff894c: 59 24                         #             mov     %r1, 4              ; shift left 4 bits
0xffff894e: bf c6                         #             call    shl                 ; imm <<= 4
0xffff8950: 20 14                         #             addd    %r0, %r5            ; imm += cur - '0'
0xffff8952:                               # read_immediate_hex_check:
0xffff8952: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8954: 01 a8                         #             subh    %r5, %r2            ; cur -= 48
0xffff8956: 43 aa                         #             cmph    %r5, 10             ; cur - '0' <? 10
0xffff8958: 94 f4                         #             jb      read_immediate_hex_num ; if yes, we have a hex number
0xffff895a: 41 ac                         #             subh    %r5, 12             ; cur - 60
0xffff895c: 41 a5                         #             subh    %r5, 5              ; cur - 'A'
0xffff895e: 43 a6                         #             cmph    %r5, 6              ; cur - 'A' <? 6
0xffff8960: 94 e2                         #             jb      read_immediate_hex_letter ; if yes we have a hex letter
0xffff8962: 2c f8                         #             popd    %ln                 ; otherwise we're done. Recover %ln
0xffff8964: 58 22 5c 21                   #             mov     %r1, 65             ; Overwrite 48 with the amount to adjust cur by.
0xffff8968: 8e 16                         #             jmp     read_immediate_negate 
0xffff896a:                               # read_immediate_dec_loop:
0xffff896a: 20 00                         #             addd    %r0, %r0            ; imm *= 2
0xffff896c: 29 40                         #             movd    %r2, %r0            ; immx2 = imm
0xffff896e: 20 00                         #             addd    %r0, %r0            ; imm *= 2 (x4 cumulative)
0xffff8970: 20 00                         #             addd    %r0, %r0            ; imm *= 2 (x8 cumulative)
0xffff8972: 20 08                         #             addd    %r0, %r2            ; imm = imm + immx2 (x10 cumulative)
0xffff8974: 20 14                         #             addd    %r0, %r5            ; imm = imm + cur - 48
0xffff8976: 4a a1                         #             ldh     %r5, STREAM         ; r5 = getchar()
0xffff8978:                               # read_immediate_dec_check:
0xffff8978: 01 a4                         #             subh    %r5, %r1            ; r5 = cur - 48
0xffff897a: 43 aa                         #             cmph    %r5, 10             ; compare (cur - 48) to 10
0xffff897c: 94 ee                         #             jb      read_immediate_dec_loop ; loop if 0 <= (cur - 48) < 10
0xffff897e:                               # read_immediate_negate:
0xffff897e: 00 a4                         #             addh    %r5, %r1            ; r5 = cur (previously, r5 was adjusted and r1 held the adjustment)
0xffff8980: 2c 38                         #             popd    %r1                 ; retrieve the comparison of initial cur to '-'
0xffff8982: 2c 58                         #             popd    %r2                 ; unwind stack
0xffff8984: 47 3f                         #             testh   %r1, -1             ; test the result of that comparison, zero means equal
0xffff8986: af e1                         #             retnz                       ; if it wasn't equal, we're done
0xffff8988: 62 00                         #             rsubd   %r0, 0              ; otherwise, imm = -imm
0xffff898a: af ee                         #             ret                         ; and now we're done.
0xffff898c:                               # read_name_with_sd:
0xffff898c: 2d c8                         #             pushd   %r2
0xffff898e: 8e 12                         #             jmp     read_name_have_sd
0xffff8990:                               # read_name:
0xffff8990: 2d c8                         #             pushd   %r2
0xffff8992: 69 5e 6c 40 6c 40 6c 40 6c 40 6c 40 6c 4c#             mov     %r2, STATIC_DATA_PTR
0xffff89a0:                               # read_name_have_sd:
0xffff89a0: 2d dc                         #             pushd   %ln
0xffff89a2: 2d cc                         #             pushd   %r3                 ; get a free register so we can save original buffer
0xffff89a4: 60 44                         #             addd    %r2, HEAP_LIMIT_OFS ; &static_data->heap_limit
0xffff89a6: 2a 48                         #             ldd     %r2, %r2            ; static_data->heap_limit
0xffff89a8: 60 48                         #             addd    %r2, 8              ; static_data->heap_limit + offsetof(table_entry_t, symbol)
0xffff89aa: 29 68                         #             movd    %r3, %r2            ; save original buffer
0xffff89ac:                               # read_name_L1:
0xffff89ac: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0xffff89ae: 60 41                         #             addd    %r2, 1              ; buffer++
0xffff89b0: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff89b2: b2 7a                         #             call    cur_is_name_char    ; r0 = is cur a valid name char?
0xffff89b4: 57 1f                         #             test    %r0, -1             ; check result
0xffff89b6: 91 f6                         #             jnz     read_name_L1        ; if cur is valid, loop
0xffff89b8: 59 00                         #             mov     %r0, 0              ; r0 = \NUL
0xffff89ba: 0b 08                         #             sth     %r0, %r2            ; *buffer = \NUL
0xffff89bc: 29 0c                         #             movd    %r0, %r3            ; restore original buffer
0xffff89be: 2c 78                         #             popd    %r3
0xffff89c0: 2c f8                         #             popd    %ln
0xffff89c2: 2c 58                         #             popd    %r2                 ; we wound in a weird order, undo that
0xffff89c4: af ee                         #             ret
0xffff89c6:                               # read_any_register:
0xffff89c6: 2d dc                         #             pushd   %ln
0xffff89c8: b0 74                         #             call    read_any_register_actual ; put &register_table in %ln
0xffff89ca:                               # register_table:
0xffff89ca: 61 30                         #             .ascii  "a0"
0xffff89cc: 00 00 ec 8d                   #             .word   0 empty_str&0xFFFF
0xffff89d0: 61 31                         #             .ascii  "a1"
0xffff89d2: 01 00 ec 8d                   #             .word   1 empty_str&0xFFFF
0xffff89d6: 61 32                         #             .ascii  "a2"
0xffff89d8: 02 00 ec 8d                   #             .word   2 empty_str&0xFFFF
0xffff89dc: 73 30                         #             .ascii  "s0"
0xffff89de: 03 00 ec 8d                   #             .word   3 empty_str&0xFFFF
0xffff89e2: 73 31                         #             .ascii  "s1"
0xffff89e4: 04 00 ec 8d                   #             .word   4 empty_str&0xFFFF
0xffff89e8: 62 70                         #             .ascii  "bp"
0xffff89ea: 05 00 ec 8d                   #             .word   5 empty_str&0xFFFF
0xffff89ee: 73 70                         #             .ascii  "sp"
0xffff89f0: 06 00 ec 8d                   #             .word   6 empty_str&0xFFFF
0xffff89f4: 6c 6e                         #             .ascii  "ln"
0xffff89f6: 07 00 ec 8d                   #             .word   7 empty_str&0xFFFF
0xffff89fa: 72 30                         #             .ascii  "r0"
0xffff89fc: 00 00 ec 8d                   #             .word   0 empty_str&0xFFFF
0xffff8a00: 72 31                         #             .ascii  "r1"
0xffff8a02: 01 00 ec 8d                   #             .word   1 empty_str&0xFFFF
0xffff8a06: 72 32                         #             .ascii  "r2"
0xffff8a08: 02 00 ec 8d                   #             .word   2 empty_str&0xFFFF
0xffff8a0c: 72 33                         #             .ascii  "r3"
0xffff8a0e: 03 00 ec 8d                   #             .word   3 empty_str&0xFFFF
0xffff8a12: 72 34                         #             .ascii  "r4"
0xffff8a14: 04 00 ec 8d                   #             .word   4 empty_str&0xFFFF
0xffff8a18: 72 35                         #             .ascii  "r5"
0xffff8a1a: 05 00 ec 8d                   #             .word   5 empty_str&0xFFFF
0xffff8a1e: 72 36                         #             .ascii  "r6"
0xffff8a20: 06 00 ec 8d                   #             .word   6 empty_str&0xFFFF
0xffff8a24: 72 37                         #             .ascii  "r7"
0xffff8a26: 07 00 ec 8d                   #             .word   7 empty_str&0xFFFF
0xffff8a2a: 63 31                         #             .ascii  "c1"
0xffff8a2c: 08 00 7c 8e                   #             .word   8 id_str&0xFFFF
0xffff8a30: 63 32                         #             .ascii  "c2"
0xffff8a32: 09 00 7c 8e                   #             .word   9 id_str&0xFFFF
0xffff8a36: 66 65                         #             .ascii  "fe"
0xffff8a38: 0a 00 7f 8e                   #             .word   10 at_str&0xFFFF
0xffff8a3c:                               # read_any_register_actual:
0xffff8a3c: 2d c8                         #             pushd   %r2
0xffff8a3e: 2d cc                         #             pushd   %r3
0xffff8a40: 2d d0                         #             pushd   %r4                 ; wind the stack (%ln already pushed)
0xffff8a42: 58 61 5c 60                   #             mov     %r3, BUFFER_PTR     ; r3 = buffer
0xffff8a46: 4a 01                         #             ldh     %r0, STREAM
0xffff8a48: 0b 0c                         #             sth     %r0, %r3            ; *buffer = getchar()
0xffff8a4a: 60 61                         #             addd    %r3, 1
0xffff8a4c: 4a 01                         #             ldh     %r0, STREAM
0xffff8a4e: 0b 0c                         #             sth     %r0, %r3            ; *(buffer + 1) = getchar()
0xffff8a50: 61 61                         #             subd    %r3, 1              ; r3 = buffer, once again
0xffff8a52: 58 b2                         #             movz    %r5, 18             ; i = 18
0xffff8a54: 29 9c                         #             movd    %r4, %r7            ; r7 previously held &register_table
0xffff8a56:                               # read_any_register_L1:
0xffff8a56: 29 0c                         #             movd    %r0, %r3            ; arg0 = buffer
0xffff8a58: 29 30                         #             movd    %r1, %r4            ; arg1 = register_table[18-i].name
0xffff8a5a: 69 42                         #             movd    %r2, 2              ; arg2 = 2
0xffff8a5c: bc 40                         #             call    strncmp             ; r0 = 0 iff string at buffer == string at name
0xffff8a5e: 47 1f                         #             testh   %r0, -1             ; is r0 == 0?
0xffff8a60: 80 0c                         #             jz      read_any_register_L3; found match! break out of loop
0xffff8a62: 60 86                         #             addd    %r4, 6              ; point r4 at next register table entry
0xffff8a64: 41 a1                         #             subh    %r5, 1              ; --i
0xffff8a66: 9b f0                         #             jge     read_any_register_L1; loop as long as i is still >= 0
0xffff8a68:                               # read_any_register_L2:                   ; but if i < 0, there were no matches. Die.
0xffff8a68: 59 01                         #             mov     %r0, 1              ; r0 = INVALID_REGISTER_CODE
0xffff8a6a: b1 fc                         #             call    die
0xffff8a6c:                               # read_any_register_L3:
0xffff8a6c: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar() [in the C code, this is above the loop]
0xffff8a6e: 60 84                         #             addd    %r4, 4              ; point r4 at entry.remainder_to_consume
0xffff8a70: 1a 30                         #             ldx     %r1, %r4            ; r1 = entry->remainder_to_consume
0xffff8a72: b0 3a                         #             call    consume             ; r0 = 0 iff consume succeeds
0xffff8a74: 47 1f                         #             testh   %r0, -1             ; is r0 == 0?
0xffff8a76: 91 f2                         #             jnz     read_any_register_L2; call die(INVALID_REGISTER) if consume failed
0xffff8a78: b1 b4                         #             call    cur_is_alphanum     ; r0 = is_alphanum(cur)
0xffff8a7a: 47 1f                         #             testh   %r0, -1             ; is r0 != 0?
0xffff8a7c: 91 ec                         #             jnz     read_any_register_L2; call die(INVALID_REGISTER) if is_alphanum(cur)
0xffff8a7e: 61 82                         #             subd    %r4, 2              ; point r4 at entry.number
0xffff8a80: 1a 10                         #             ldx     %r0, %r4            ; return = entry->number
0xffff8a82: 2c 98                         #             popd    %r4
0xffff8a84: 2c 78                         #             popd    %r3
0xffff8a86: 2c 58                         #             popd    %r2                 ; unwind
0xffff8a88: 2c f8                         #             popd    %ln                 ; restore return address
0xffff8a8a: af ee                         #             ret
0xffff8a8c:                               # read_register:
0xffff8a8c: 2d dc                         #             pushd   %ln
0xffff8a8e: bf 38                         #             call    read_any_register
0xffff8a90: 2c f8                         #             popd    %ln
0xffff8a92: 43 08                         #             cmph    %r0, 8
0xffff8a94: af ea                         #             retl                        ; return reg if it's < 8
0xffff8a96: 9e d2                         #             jmp     read_any_register_L2; otherwise, call die(INVALID_REGISTER)
0xffff8a98:                               # read_ctrl_register:
0xffff8a98: 2d dc                         #             pushd   %ln
0xffff8a9a: bf 2c                         #             call    read_any_register
0xffff8a9c: 2c f8                         #             popd    %ln
0xffff8a9e: 43 08                         #             cmph    %r0, 8
0xffff8aa0: af eb                         #             retge                       ; return reg if it's >= 8
0xffff8aa2: 9e c6                         #             jmp     read_any_register_L2; otherwise, call die as above
0xffff8aa4:                               # consume_L1:
0xffff8aa4: 02 14                         #             rsubh   %r0, %r5            ; r0 = *check - cur
0xffff8aa6: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8aa8: af e1                         #             retnz                       ; if match failed, return result
0xffff8aaa: 60 21                         #             addd    %r1, 1              ; ++check
0xffff8aac:                               # consume:
0xffff8aac: 0a 04                         #             ldh     %r0, %r1            ; r0 = *check
0xffff8aae: 47 1f                         #             testh   %r0, -1             ; *check == 0?
0xffff8ab0: 91 f4                         #             jnz     consume_L1          ; loop if *check != 0
0xffff8ab2: af ee                         #             ret                         ; otherwise, return *check === 0
0xffff8ab4:                               # match:
0xffff8ab4: 02 14                         #     rsubh   %r0, %r5                    ; r0 = cur - c
0xffff8ab6: 4a a1                         #     ldh     %r5, STREAM                 ; cur = getchar()
0xffff8ab8: af ee                         #     ret
0xffff8aba:                               # read_opcode:
0xffff8aba: 2d dc                         #             pushd   %ln
0xffff8abc: 2d c8                         #             pushd   %r2
0xffff8abe: 2d cc                         #             pushd   %r3
0xffff8ac0: 2d d0                         #             pushd   %r4
0xffff8ac2: 59 00                         #             mov     %r0, 0              ; r.opcode = 0
0xffff8ac4: 59 23                         #             mov     %r1, 3              ; r.state = STATE_TX
0xffff8ac6: 58 41 5c 40                   #             mov     %r2, BUFFER_PTR     ; r2 = buffer
0xffff8aca: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0xffff8acc: 09 74                         #             movh    %r3, %r5            ; temporarily stash cur in r3
0xffff8ace: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8ad0: 60 41                         #             addd    %r2, 1              ; ++buffer
0xffff8ad2: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0xffff8ad4: 58 83 5c 8a                   #             mov     %r4, 106            ; r4 = 'j' === 106
0xffff8ad8: 03 70                         #             cmph    %r3, %r4            ; check if original cur was 'j'
0xffff8ada: 59 80                         #             mov     %r4, 0              ; trigger = HIT_J === 0
0xffff8adc: 80 96                         #             je      read_opcode_cond    ; jump to the cond part if so
0xffff8ade: 59 62                         #             mov     %r3, 2              ; size = 2
0xffff8ae0: 59 82                         #             mov     %r4, 2              ; count = 2
0xffff8ae2: 69 bf 6c a3 6c b4 6c a3       #             mov     %r5, opcode_tables  ; r5 = pointer to opcode tables
0xffff8aea:                               # read_opcode_sloop:
0xffff8aea: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buffer
0xffff8aee: 29 34                         #             movd    %r1, %r5            ; arg 1 = &table{2/3}[ix].name
0xffff8af0: 19 4c                         #             mov     %r2, %r3            ; arg 2 = size
0xffff8af2: bb aa                         #             call    strncmp             ; r0 = (0 iff hit table)
0xffff8af4: 47 1f                         #             testh   %r0, -1             ; test for hit
0xffff8af6: 81 0c                         #             jnz     read_opcode_sstep   ; if not a hit, go to next step
0xffff8af8: 61 a1                         #             subd    %r5, 1              ; r5 = &table{2/3}[ix].opcode
0xffff8afa: 0a 14                         #             ldh     %r0, %r5            ; r.opcode = table{2/3}[ix].opcode
0xffff8afc: 59 25                         #             mov     %r1, 5              ; r.state = STATE_COMP
0xffff8afe: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8b00: 8e c6                         #             jmp     read_opcode_unwind  ; return
0xffff8b02:                               # read_opcode_sstep:
0xffff8b02: 20 ac                         #             addd    %r5, %r3            ; tableptr += size
0xffff8b04: 60 a1                         #             addd    %r5, 1              ; tableptr += 1 [shift past next opcode]
0xffff8b06: 41 81                         #             subh    %r4, 1              ; --count
0xffff8b08: 9b e2                         #             jge     read_opcode_sloop   ; loop if count still >= 0
0xffff8b0a: 43 62                         #             cmph    %r3, 2              ; check if size was 2 on that iteration
0xffff8b0c: 59 84                         #             mov     %r4, 4              ; count = 4, size is "still" 3 (it's from the future)
0xffff8b0e: 81 30                         #             jne     read_opcode_big     ; if not, stop the short loop
0xffff8b10: 59 63                         #             mov     %r3, 3              ; size = 3
0xffff8b12: 59 85                         #             mov     %r4, 5              ; count = 5
0xffff8b14: 58 01 5c 02                   #             mov     %r0, BUFFER_PTR+2   ; r0 = buffer + 2 (probably 34, if trying to self-host)
0xffff8b18: 4a 41                         #             ldh     %r2, STREAM         ; r2 = getchar()
0xffff8b1a: 0b 40                         #             sth     %r2, %r0            ; *(buffer + 2) = r2
0xffff8b1c: 9e ce                         #             jmp     read_opcode_sloop   ; continue checking short opcodes
0xffff8b1e:                               # read_opcode_bstep:
0xffff8b1e: 20 ac                         #             addd    %r5, %r3            ; tableptr += size
0xffff8b20: 60 a3                         #             addd    %r5, 3              ; tableptr += 3 [shift past opcode,state,trigger]
0xffff8b22: 41 81                         #             subh    %r4, 1              ; --count
0xffff8b24: 8b 20                         #             jge     read_opcode_bloop   ; loop now, if count still >= 0
0xffff8b26: 2c 58                         #             popd    %r2                 ; reload spilled cur into %r2
0xffff8b28: 43 63                         #             cmph    %r3, 3              ; was size still 3 on that iteration?
0xffff8b2a: 81 8e                         #             jne     read_opcode_die     ; if not, we're out of things to check. Die.
0xffff8b2c:                               # read_opcode_try4:
0xffff8b2c: 58 01 5c 03                   #             mov     %r0, BUFFER_PTR+3   ; r0 = buffer + 3 (probably 35, if trying to self-host)
0xffff8b30: 0b 40                         #             sth     %r2, %r0            ; *(buffer + 3) = cur
0xffff8b32: 59 64                         #             mov     %r3, 4              ; size = 4
0xffff8b34: 59 85                         #             mov     %r4, 5              ; count = 5
0xffff8b36: 69 bf 6c a3 6c b6 6c a2       #             mov     %r5, opcode_table4_state
0xffff8b3e:                               # read_opcode_big:                        ; before jumping here, count was set to {4/5}
0xffff8b3e: 4a 41                         #             ldh     %r2, STREAM         ; get another character...
0xffff8b40: 2d c8                         #             pushd   %r2                 ; and spill it, because we still need the table
0xffff8b42: 60 a2                         #             addd    %r5, 2              ; was pointed at state, move it to name
0xffff8b44:                               # read_opcode_bloop:
0xffff8b44: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buffer
0xffff8b48: 29 34                         #             movd    %r1, %r5            ; arg 1 = &table{3/4}[ix].name
0xffff8b4a: 19 4c                         #             mov     %r2, %r3            ; arg 2 = size
0xffff8b4c: bb 50                         #             call    strncmp             ; r0 = (0 iff hit table)
0xffff8b4e: 47 1f                         #             testh   %r0, -1             ; test for hit
0xffff8b50: 91 ce                         #             jnz     read_opcode_bstep   ; if no hit, go to next iteration
0xffff8b52: 2c 58                         #             popd    %r2                 ; retrieve cur, which we spilled
0xffff8b54: 61 a1                         #             subd    %r5, 1              ; move pointer to trigger
0xffff8b56: 0a 94                         #             ldh     %r4, %r5            ; trigger = table[ix].trigger
0xffff8b58: 43 82                         #             cmph    %r4, 2              ; trigger == HIT_MOV?
0xffff8b5a: 81 0a                         #             jne     read_opcode_chkcond ; if it's not, try checking if it's HIT_COND
0xffff8b5c: 09 08                         #             movh    %r0, %r2            ; but if it is, check cur (which we reloaded to r2)
0xffff8b5e: b0 f2                         #             call    is_not_opcode_suffix
0xffff8b60: 47 1f                         #             testh   %r0, -1             ; test !is_opcode_suffix(cur)
0xffff8b62: 91 ca                         #             jnz     read_opcode_try4    ; if holds, skip to trying length-4 names
0xffff8b64:                               # read_opcode_chkcond:
0xffff8b64: 61 a2                         #             subd    %r5, 2              ; move pointer from trigger to opcode
0xffff8b66: 0a 14                         #             ldh     %r0, %r5            ; r.opcode = table[ix].opcode
0xffff8b68: 60 a1                         #             addd    %r5, 1              ; move pointer from opcode to state
0xffff8b6a: 0a 34                         #             ldh     %r1, %r5            ; r.state  = table[ix].state
0xffff8b6c: 09 a8                         #             movh    %r5, %r2            ; restore cur to r5 from r2 (where it was reloaded)
0xffff8b6e: 43 81                         #             cmph    %r4, 1              ; trigger == HIT_COND?
0xffff8b70: 81 56                         #             jne     read_opcode_unwind  ; if no, go to stack unwind and return
0xffff8b72:                               # read_opcode_cond:
0xffff8b72: 1d c4                         #             pushx   %r1                 ; spill r.state  (two spills, so x is fine)
0xffff8b74: 1d c0                         #             pushx   %r0                 ; spill r.opcode
0xffff8b76: 59 42                         #             mov     %r2, 2              ; i = 2
0xffff8b78: 58 61 5c 60                   #             mov     %r3, BUFFER_PTR     ; r3 = buffer
0xffff8b7c:                               # read_opcode_bfrcond:
0xffff8b7c: b0 d2                         #             call    cur_is_not_opcode_suffix
0xffff8b7e: 47 1f                         #             testh   %r0, -1             ; test !is_opcode_suffix(cur)
0xffff8b80: 80 0c                         #             jz      read_opcode_condtbl ; if it doesn't hold (cur is an opcode suffix)
0xffff8b82: 0b ac                         #             sth     %r5, %r3            ; *buffer = cur
0xffff8b84: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0xffff8b86: 60 61                         #             addd    %r3, 1              ; ++buffer
0xffff8b88: 41 41                         #             subh    %r2, 1              ; --i
0xffff8b8a: 9d f2                         #             jg      read_opcode_bfrcond ; continue buffering if i > 0
0xffff8b8c:                               # read_opcode_condtbl:
0xffff8b8c: 59 40                         #             mov     %r2, 0              ; clear r2
0xffff8b8e: 0b 4c                         #             sth     %r2, %r3            ; *buffer = 0
0xffff8b90: 69 7f 6c 63 6c 77 6c 6c       #             mov     %r3, cond_table_name ; get pointer to cond_table[0].name in r3
0xffff8b98: 19 50                         #             mov     %r2, %r4            ; r2 = trigger
0xffff8b9a: 00 48                         #             addh    %r2, %r2            ; r2 = trigger * 2
0xffff8b9c: 00 48                         #             addh    %r2, %r2            ; r2 = trigger * 4
0xffff8b9e: 20 68                         #             addd    %r3, %r2            ; r3 = cond_table[trigger].name
0xffff8ba0: 58 54                         #             movz    %r2, 20
0xffff8ba2: 02 88                         #             rsubh   %r4, %r2            ; trigger = 20 - trigger
0xffff8ba4:                               # read_opcode_cndloop:
0xffff8ba4: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buffer
0xffff8ba8: 29 2c                         #             movd    %r1, %r3            ; arg 1 = cond_table[ix].name
0xffff8baa: 59 43                         #             mov     %r2, 3              ; arg 2 = 3
0xffff8bac: ba f0                         #             call    strncmp             ; r0 = (0 iff hit table)
0xffff8bae: 47 1f                         #             testh   %r0, -1             ; test if hit
0xffff8bb0: 80 0c                         #             jz      read_opcode_hitcond ; if we hit, go leave (finally)
0xffff8bb2: 60 64                         #             addd    %r3, 4              ; otherwise, move to next cond table entry
0xffff8bb4: 41 81                         #             subh    %r4, 1              ; --trigger
0xffff8bb6: 9d ee                         #             jg      read_opcode_cndloop ; continue looping if trigger > 0
0xffff8bb8:                               # read_opcode_die:
0xffff8bb8: 59 00                         #             mov     %r0, 0
0xffff8bba: b0 ac                         #             call    die                 ; otherwise, we are out of options. Die.
0xffff8bbc:                               # read_opcode_hitcond:
0xffff8bbc: 1c 18                         #             popx    %r0                 ; reload r.opcode (two spills, both pushx)
0xffff8bbe: 1c 38                         #             popx    %r1                 ; reload r.state
0xffff8bc0: 61 61                         #             subd    %r3, 1              ; move back from name to opcode
0xffff8bc2: 0a 6c                         #             ldh     %r3, %r3            ; read in the opcode
0xffff8bc4: 00 0c                         #             addh    %r0, %r3            ; r.opcode += cond_table[hit].opcode
0xffff8bc6:                               # read_opcode_unwind:
0xffff8bc6: 2c 98                         #             popd    %r4
0xffff8bc8: 2c 78                         #             popd    %r3
0xffff8bca: 2c 58                         #             popd    %r2
0xffff8bcc: 2c f8                         #             popd    %ln
0xffff8bce: af ee                         #             ret
0xffff8bd0:                               # validate_s5:
0xffff8bd0: 2d c0                         #             pushd   %r0
0xffff8bd2: 2d c4                         #             pushd   %r1
0xffff8bd4: 58 30                         #             movz    %r1, 16
0xffff8bd6: 20 04                         #             addd    %r0, %r1            ; imm + 16
0xffff8bd8: 10 24                         #             addx    %r1, %r1            ; r1 = 32
0xffff8bda: 23 04                         #             cmpd    %r0, %r1            ; compare (imm + 16) against 32
0xffff8bdc: 2c 38                         #             popd    %r1                 ; if 0 <= (imm + 16) < 32, then imm
0xffff8bde: 2c 18                         #             popd    %r0                 ; is a valid s5 immediate. The compare
0xffff8be0: af ee                         #             ret                         ; will set the 'b' condition if so.
0xffff8be2:                               # cur_is_alpha:
0xffff8be2: 19 14                         #             mov     %r0, %r5
0xffff8be4:                               # is_alpha:
0xffff8be4: 58 22 5c 21                   #             mov     %r1, 65             ; r1 = 'A'
0xffff8be8: 03 04                         #             cmph    %r0, %r1
0xffff8bea: 84 1e                         #             jb      is_alpha_ret_false  ; return false if r0 < 'A'
0xffff8bec: 40 2f                         #             addh    %r1, 15
0xffff8bee: 40 2a                         #             addh    %r1, 10             ; r1 = 'Z'
0xffff8bf0: 03 04                         #             cmph    %r0, %r1            ; c <=? 'Z'
0xffff8bf2: 88 1a                         #             jbe     is_alpha_ret_true
0xffff8bf4: 40 25                         #             addh    %r1, 5              ; r1 = '_'
0xffff8bf6: 03 04                         #             cmph    %r0, %r1            ; c ==? '_'
0xffff8bf8: 80 14                         #             je      is_alpha_ret_true
0xffff8bfa: 40 22                         #             addh    %r1, 2              ; r1 = 'a'
0xffff8bfc: 03 04                         #             cmph    %r0, %r1            ; c <? 'a'
0xffff8bfe: 84 0a                         #             jb      is_alpha_ret_false
0xffff8c00: 40 2f                         #             addh    %r1, 15
0xffff8c02: 40 2a                         #             addh    %r1, 10             ; r1 = 'z'
0xffff8c04: 03 04                         #             cmph    %r0, %r1            ; c <=? 'z'
0xffff8c06: 88 06                         #             jbe     is_alpha_ret_true   ; fall through to ret_true otherwise
0xffff8c08:                               # is_eol_ret_false:
0xffff8c08:                               # is_num_ret_false:
0xffff8c08:                               # is_alpha_ret_false:
0xffff8c08: 59 00                         #             mov     %r0, 0
0xffff8c0a: af ee                         #             ret
0xffff8c0c:                               # is_eol_ret_true:
0xffff8c0c:                               # is_num_ret_true:
0xffff8c0c:                               # is_alpha_ret_true:
0xffff8c0c:                               # is_imm_start_ret_true:
0xffff8c0c: 59 01                         #             mov     %r0, 1
0xffff8c0e: af ee                         #             ret
0xffff8c10:                               # cur_is_imm_start:
0xffff8c10: 19 14                         #             mov     %r0, %r5
0xffff8c12:                               # is_imm_start:
0xffff8c12: 58 21 5c 2d                   #             mov     %r1, 45             ; '-' for comparison
0xffff8c16: 03 04                         #             cmph    %r0, %r1            ; c ==? '-'
0xffff8c18: 90 f4                         #             je      is_imm_start_ret_true
0xffff8c1a: 40 23                         #             addh    %r1, 3              ; r1 = '0'
0xffff8c1c: 8e 08                         #             jmp     is_num_have_48      ; this entrypoint is less common
0xffff8c1e:                               # cur_is_num:
0xffff8c1e: 19 14                         #             mov     %r0, %r5
0xffff8c20:                               # is_num:
0xffff8c20: 58 21 5c 30                   #             mov     %r1, 48             ; '0' prep going in
0xffff8c24:                               # is_num_have_48:
0xffff8c24: 01 04                         #             subh    %r0, %r1            ; c = c - '0'
0xffff8c26: 43 0a                         #             cmph    %r0, 10             ; c <? '9'+1
0xffff8c28: 94 e4                         #             jb      is_num_ret_true
0xffff8c2a: 9e de                         #             jmp     is_num_ret_false
0xffff8c2c:                               # cur_is_alphanum:
0xffff8c2c:                               # cur_is_name_char:
0xffff8c2c: 19 14                         #             mov     %r0, %r5
0xffff8c2e:                               # is_alphanum:
0xffff8c2e:                               # is_name_char:
0xffff8c2e: 2d dc                         #             pushd   %ln                 ; we call functions, save %ln
0xffff8c30: 2d c0                         #             pushd   %r0                 ; save c
0xffff8c32: bf b2                         #             call    is_alpha            ; r0 = is_alpha(c)
0xffff8c34: 47 01                         #             testh   %r0, 1              ; test is_alpha(c)
0xffff8c36: 2c 38                         #             popd    %r1                 ; r1 = c
0xffff8c38: 81 06                         #             jnz     is_name_char_ret    ; return if is_alpha(c)
0xffff8c3a: 09 04                         #             movh    %r0, %r1            ; r0 = c
0xffff8c3c: bf e4                         #             call    is_num              ; r0 = is_num(c)
0xffff8c3e:                               # is_name_char_ret:
0xffff8c3e: 2c f8                         #             popd    %ln
0xffff8c40: af ee                         #             ret
0xffff8c42:                               # cur_is_eol:
0xffff8c42: 19 14                         #             mov     %r0, %r5
0xffff8c44:                               # is_eol:
0xffff8c44: 43 0a                         #             cmph    %r0, 10             ; c ==? '\n'
0xffff8c46: 90 c6                         #             je      is_eol_ret_true
0xffff8c48: 43 00                         #             cmph    %r0, 0              ; c ==? '\0'
0xffff8c4a: 90 c2                         #             je      is_eol_ret_true
0xffff8c4c: 9e bc                         #             jmp     is_eol_ret_false
0xffff8c4e:                               # cur_is_not_opcode_suffix:
0xffff8c4e: 19 14                         #             mov     %r0, %r5
0xffff8c50:                               # is_not_opcode_suffix:
0xffff8c50: 19 20                         #             mov     %r1, %r0            ; swap registers
0xffff8c52: 58 03 5c 18                   #             mov     %r0, 120            ; r0 = 'x' = 120
0xffff8c56: 02 04                         #             rsubh   %r0, %r1            ; r0 = c - 'x'
0xffff8c58: af e0                         #             retz                        ; if 0, c == 'x' which is valid, return 0
0xffff8c5a: 41 10                         #             subh    %r0, -16            ; r0 = (c - 'x') - ('h' - 'x') === c - 'h'
0xffff8c5c: af e0                         #             retz                        ; same, but == 'h'
0xffff8c5e: 40 04                         #             addh    %r0, 4              ; r0 = (c - 'h') + ('h' - 'd') === c - 'd'
0xffff8c60: af e0                         #             retz                        ; same, but == 'd'
0xffff8c62: 19 04                         #             mov     %r0, %r1            ; r0 = c
0xffff8c64: 9e 80                         #             jmp     is_alpha            ; tail-call is_alpha. Our return sense is inverted,
0xffff8c66:                               # die:
0xffff8c66: b0 22                         #             call    die_actual          ; %r7 = &msg_header
0xffff8c68:                               # msg_header:                             ; char **msg_header
0xffff8c68: e4 8d                         #             .word   invalid_msg &0xFFFF
0xffff8c6a: e4 8d                         #             .word   invalid_msg &0xFFFF
0xffff8c6c: e4 8d                         #             .word   invalid_msg &0xFFFF
0xffff8c6e: ed 8d                         #             .word   out_of_msg  &0xFFFF
0xffff8c70: ed 8d                         #             .word   out_of_msg  &0xFFFF
0xffff8c72: ec 8d                         #             .word   empty_msg   &0xFFFF
0xffff8c74: 1c 8e                         #             .word   unknown_msg &0xFFFF
0xffff8c76: 1c 8e                         #             .word   unknown_msg &0xFFFF
0xffff8c78:                               # msg_body:                               ; char **msg_body
0xffff8c78: f5 8d                         #             .word   syntax_msg    &0xFFFF
0xffff8c7a: fc 8d                         #             .word   register_msg  &0xFFFF
0xffff8c7c: 05 8e                         #             .word   immediate_msg &0xFFFF
0xffff8c7e: 0f 8e                         #             .word   range_msg     &0xFFFF
0xffff8c80: 15 8e                         #             .word   memory_msg    &0xFFFF
0xffff8c82: 38 8e                         #             .word   missing_features_msg &0xFFFF
0xffff8c84: 25 8e                         #             .word   symbol_msg    &0xFFFF
0xffff8c86: 2d 8e                         #             .word   directive_msg &0xFFFF
0xffff8c88:                               # die_actual:
0xffff8c88: 29 44                         #             movd    %r2, %r1            ; save name in r2 which is stable (r1 is not)
0xffff8c8a: 29 bc                         #             movd    %r5, %r7            ; save &msg_header
0xffff8c8c: 00 00                         #             addh    %r0, %r0            ; ofs = code << 1
0xffff8c8e: 20 1c                         #             addd    %r0, %r7            ; r0 = &(msg_header[code])
0xffff8c90: 29 60                         #             movd    %r3, %r0            ; save &(msg_header[code]) for later
0xffff8c92: 1a 00                         #             ldx     %r0, %r0            ; r0 = msg_header[code] (ldx sign-extends so we get the right ptr)
0xffff8c94: b0 a8                         #             call    puts                ; puts(msg_header[code])
0xffff8c96: 29 0c                         #             movd    %r0, %r3            ; retrieve &msg_header[code]
0xffff8c98: 60 08                         #             addd    %r0, 8              ; r0 = &msg_body[code]
0xffff8c9a: 60 08                         #             addd    %r0, 8              ; which is &msg_header[code] + 16
0xffff8c9c: 1a 00                         #             ldx     %r0, %r0            ; r0 = msg_body[code]   (ldx sign-extends so we get the right ptr)
0xffff8c9e: b0 9e                         #             call    puts                ; puts(msg_body[code])   additionally r1 = 0
0xffff8ca0: 21 74                         #             subd    %r3, %r5            ; r3 = &msg_header[code] - msg_header, eqv. 2*code
0xffff8ca2: 53 6a                         #             cmpx    %r3, 10             ; compare 2*code against 10
0xffff8ca4: 8c 06                         #             jle     die_line            ; if 2*code <= 10, we're done and can print line and halt
0xffff8ca6: 29 08                         #             movd    %r0, %r2            ; move name to argument 0 (it was saved in r2 and is untouched)
0xffff8ca8: b0 94                         #             call    puts                ; puts(name)
0xffff8caa:                               # die_line:
0xffff8caa: b0 0c                         #             call    die_line_with_msg
0xffff8cac: 20 61 74 20 6c 69 6e 65 20 00 #             .asciiz " at line "
0xffff8cb6:                               # die_line_with_msg:
0xffff8cb6: 29 1c                         #             movd    %r0, %ln
0xffff8cb8: b0 84                         #             call    puts                ; print " at line "
0xffff8cba: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buf
0xffff8cbe: 59 50 5c 40 5c 4a             #             mov     %r2, 0xC00A         ; &static_data.src_lineno
0xffff8cc4: 1a 48                         #             ldx     %r2, %r2            ; arg 2 = static_data->src_lineno
0xffff8cc6: b0 38                         #             call    utoa                ; convert lineno to string in buffer
0xffff8cc8: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buf, again
0xffff8ccc: b0 70                         #             call    puts                ; print the line number
0xffff8cce: 8e 00                         #             hlt                         ; crash the kernel.
0xffff8cd0:                               # udiv16:
0xffff8cd0: 2d cc                         #             pushd   %r3                 ; save r3
0xffff8cd2: 59 20                         #             mov     %r1, 0              ; initial partial remainder is 0
0xffff8cd4: 58 70                         #             mov     %r3, 16             ; number of iterations to perform
0xffff8cd6:                               # udiv16_loop:
0xffff8cd6: 10 24                         #             addx    %r1, %r1            ; shift the partial remainder one bit left
0xffff8cd8: 10 00                         #             addx    %r0, %r0            ; shift dividend left one bit thru carry
0xffff8cda: 85 04                         #             jnc     udiv16_no_qbit      ; if no carry, skip moving bit into partial rem
0xffff8cdc: 54 21                         #             orx     %r1, 1              ; move carry into bottom bit of shifted partial rem
0xffff8cde:                               # udiv16_no_qbit:
0xffff8cde: 11 28                         #             sub     %r1, %r2            ; attempt subtraction from partial remainder
0xffff8ce0: 85 06                         #             jnc     udiv16_no_borrow    ; if that subtraction succeeded, set bit of quotient
0xffff8ce2: 10 28                         #             add     %r1, %r2            ; otherwise, restore partial remainder
0xffff8ce4: 8e 04                         #             jmp     udiv16_step         ; and skip setting quotient bit
0xffff8ce6:                               # udiv16_no_borrow:
0xffff8ce6: 54 01                         #             orx     %r0, 1              ; set bottom bit of the dividend (growing quotient)
0xffff8ce8:                               # udiv16_step:
0xffff8ce8: 41 61                         #             subh    %r3, 1              ; decrement counter
0xffff8cea: 99 ec                         #             ja      udiv16_loop         ; continue as long as counter remains > 0
0xffff8cec: 2c 78                         #             popd    %r3                 ; otherwise we're done. Restore r3
0xffff8cee: af ee                         #             ret
0xffff8cf0:                               # itoa:
0xffff8cf0: 57 5f                         #             testx   %r2, -1             ; test the input number for sign
0xffff8cf2: 83 0c                         #             jnn     utoa                ; if it's already positive, go straight to utoa
0xffff8cf4: 58 21 5c 2d                   #             mov     %r1, 45             ; otherwise, prepare a minus sign '-'
0xffff8cf8: 0b 20                         #             sth     %r1, %r0            ; to put in the buffer
0xffff8cfa: 60 01                         #             addd    %r0, 1              ; buf++
0xffff8cfc: 52 40                         #             rsubx   %r2, 0              ; d = -d
0xffff8cfe:                               # utoa:
0xffff8cfe: 2d dc                         #             pushd   %ln
0xffff8d00: 2d d0                         #             pushd   %r4                 ; wind
0xffff8d02: 2d c0                         #             pushd   %r0                 ; save original value of buffer
0xffff8d04: 58 81 5c 90                   #             mov     %r4, 48             ; stash '0' for quick access
0xffff8d08: 29 60                         #             movd    %r3, %r0            ; p = buf
0xffff8d0a: 19 08                         #             mov     %r0, %r2            ; dividend = d
0xffff8d0c: 59 4a                         #             mov     %r2, 10             ; divisor = base = 10
0xffff8d0e:                               # itoa_loop:
0xffff8d0e: bf c2                         #             call    udiv16              ; r0 = quotient, r1 = remainder, r2 still 10
0xffff8d10: 00 30                         #             addh    %r1, %r4            ; chr = remainder + '0'
0xffff8d12: 0b 2c                         #             sth     %r1, %r3            ; *p = chr
0xffff8d14: 60 61                         #             addd    %r3, 1              ; p++
0xffff8d16: 57 1f                         #             testx   %r0, -1             ; test quotient for zero
0xffff8d18: 91 f6                         #             jnz     itoa_loop           ; loop as long as quotient is not yet zero
0xffff8d1a: 0b 0c                         #             sth     %r0, %r3            ; *p = 0, terminate the string
0xffff8d1c: 61 61                         #             subd    %r3, 1              ; p2 = p - 1
0xffff8d1e: 2c 18                         #             popd    %r0                 ; p1 = buf
0xffff8d20: 2c 98                         #             popd    %r4
0xffff8d22: 2c f8                         #             popd    %ln                 ; fully unwind the stack to prepare for
0xffff8d24: 8e 0e                         #             jmp     itoa_rev_check      ; enter loop at check
0xffff8d26:                               # itoa_rev_loop:
0xffff8d26: 0a 40                         #             ldh     %r2, %r0            ; tmp = *p1
0xffff8d28: 0a 2c                         #             ldh     %r1, %r3            ; r1 = *p2
0xffff8d2a: 0b 20                         #             sth     %r1, %r0            ; *p1 = *p2
0xffff8d2c: 0b 4c                         #             sth     %r2, %r3            ; *p2 = tmp
0xffff8d2e: 60 01                         #             addd    %r0, 1              ; p1++
0xffff8d30: 61 61                         #             subd    %r3, 1              ; p2--
0xffff8d32:                               # itoa_rev_check:
0xffff8d32: 23 0c                         #             cmpd    %r0, %r3            ; p1 <? p2
0xffff8d34: 94 f2                         #             jb      itoa_rev_loop       ; loop if yes
0xffff8d36: af ee                         #             ret                         ; otherwise we're done, return.
0xffff8d38:                               # puts_L1:
0xffff8d38: 4b 23                         #             sth     %r1, OUTPUT         ; putchar(*str)
0xffff8d3a: 60 01                         #             addd    %r0, 1              ; ++str
0xffff8d3c:                               # puts:
0xffff8d3c: 0a 20                         #             ldh     %r1, %r0            ; r1 = *str
0xffff8d3e: 47 3f                         #             testh   %r1, -1             ; test *str
0xffff8d40: 91 f8                         #             jnz     puts_L1             ; loop if *str != 0
0xffff8d42: af ee                         #             ret                         ; return if *str == 0
0xffff8d44:                               # syscall_exit:
0xffff8d44: 2d c4                         #             pushd   %r1                     ; save status
0xffff8d46: b0 1e                         #             call    syscall_exit_with_msg   ; get msg into ln
0xffff8d48: 50 72 6f 67 72 61 6d 20 65 78 69 74 65 64 20 77 69 74 68 20 73 74 61 74 75 73 20 00#             .asciiz "Program exited with status "
0xffff8d64:                               # syscall_exit_with_msg:
0xffff8d64: 29 1c                         #             movd    %r0, %r7            ; arg 0 = msg
0xffff8d66: bf d6                         #             call    puts                ; print the msg
0xffff8d68: 2c 58                         #             popd    %r2                 ; arg 2 = status
0xffff8d6a: 69 1e 6c 00 6c 00 6c 00 6c 00 6c 00 6c 14#             mov     %r0, RT_BUFFER_PTR  ; arg 0 = runtime buffer after kernel data
0xffff8d78: 29 80                         #             movd    %r4, %r0            ; save buffer addr
0xffff8d7a: bf 84                         #             call    utoa                ; write str(code) into buffer
0xffff8d7c: 29 10                         #             movd    %r0, %r4            ; arg 0 = buffer again
0xffff8d7e: bf be                         #             call    puts                ; print the code
0xffff8d80: 8e 00                         #             hlt                         ; terminate
0xffff8d82:                               # syscall_putuint:
0xffff8d82:                               # syscall_putsint:
0xffff8d82: 2d c8                         #             pushd   %r2                 ; wind stack to save all user registers that we would clobber
0xffff8d84: 2d cc                         #             pushd   %r3
0xffff8d86: 2d d0                         #             pushd   %r4
0xffff8d88: 43 02                         #             cmph    %r0, 2              ; compare 2*service_no to 2. If it's 2, print unsigned.
0xffff8d8a: 19 44                         #             movx    %r2, %r1            ; arg 2 = number
0xffff8d8c: 69 1e 6c 00 6c 00 6c 00 6c 00 6c 00 6c 14#             mov     %r0, RT_BUFFER_PTR  ; arg 0 = runtime buffer after kernel data
0xffff8d9a: 29 80                         #             movd    %r4, %r0            ; and save this address
0xffff8d9c: 81 06                         #             jne     syscall_do_signed   ; if service no is not 2, use itoa
0xffff8d9e: bf 60                         #             call    utoa                ; otherwise use utoa
0xffff8da0: 8e 04                         #             jmp     syscall_have_a
0xffff8da2:                               # syscall_do_signed:
0xffff8da2: bf 4e                         #             call    itoa
0xffff8da4:                               # syscall_have_a:                         ; now the buffer has the rep of the number to print
0xffff8da4: 29 10                         #             movd    %r0, %r4            ; get its address back
0xffff8da6: bf 96                         #             call    puts                ; and print the number
0xffff8da8: 2c 98                         #             popd    %r4
0xffff8daa: 2c 78                         #             popd    %r3
0xffff8dac: 2c 58                         #             popd    %r2                 ; unwind
0xffff8dae: 8e 22                         #             jmp     syscall_return
0xffff8db0:                               # syscall_puts:
0xffff8db0: 29 04                         #             movd    %r0, %r1            ; arg 0 = message
0xffff8db2: bf 8a                         #             call    puts                ; print it
0xffff8db4: 8e 1c                         #             jmp     syscall_return
0xffff8db6:                               # syscall_sbrk:
0xffff8db6: 69 fe 6c e0 6c e0 6c e0 6c e0 6c e0 6c ec#             mov     %r7, STATIC_DATA_PTR ; r7 = &static_data.break
0xffff8dc4: 2a 1c                         #             ldd     %r0, %r7            ; r0 = static_data->break
0xffff8dc6: 20 20                         #             addd    %r1, %r0            ; r1 = static_data->break + numbytes
0xffff8dc8: 60 23                         #             addd    %r1, 3
0xffff8dca: 66 3c                         #             andd    %r1, -4             ; dword align the new break
0xffff8dcc: 2b 3c                         #             std     %r1, %r7            ; record the new break
0xffff8dce: 8e 02                         #             jmp     syscall_return
0xffff8dd0:                               # syscall_return:
0xffff8dd0: 2c f8                         #             popd    %ln                 ; restore our return address
0xffff8dd2: 69 de 6c c0 6c c0 6c c0 6c c0 6c c0 6c c0#             mov     %sp, 0x80000000     ; &static_data->user_sp
0xffff8de0: 2a d8                         #             ldd     %sp, %sp            ; %sp = static_data->user_sp
0xffff8de2: af ee                         #             ret
0xffff8de4:                               # invalid_msg:
0xffff8de4: 69 6e 76 61 6c 69 64 20       #             .ascii  "invalid "
0xffff8dec:                               # empty_str:
0xffff8dec:                               # empty_msg:                  ; share the NUL-terminator to get empty string
0xffff8dec: 00                            #             .half   0
0xffff8ded:                               # out_of_msg:
0xffff8ded: 6f 75 74 20 6f 66 20 00       #             .asciiz "out of "
0xffff8df5:                               # syntax_msg:
0xffff8df5: 73 79 6e 74 61 78 00          #             .asciiz "syntax"
0xffff8dfc:                               # register_msg:
0xffff8dfc: 72 65 67 69 73 74 65 72 00    #             .asciiz "register"
0xffff8e05:                               # immediate_msg:
0xffff8e05: 69 6d 6d 65 64 69 61 74 65 00 #             .asciiz "immediate"
0xffff8e0f:                               # range_msg:
0xffff8e0f: 72 61 6e 67 65 00             #             .asciiz "range"
0xffff8e15:                               # memory_msg:
0xffff8e15: 6d 65 6d 6f 72 79 00          #             .asciiz "memory"
0xffff8e1c:                               # unknown_msg:
0xffff8e1c: 75 6e 6b 6e 6f 77 6e 20 00    #             .asciiz "unknown "
0xffff8e25:                               # symbol_msg:
0xffff8e25: 73 79 6d 62 6f 6c 20 00       #             .asciiz "symbol "
0xffff8e2d:                               # directive_msg:
0xffff8e2d: 64 69 72 65 63 74 69 76 65 20 00#             .asciiz "directive "
0xffff8e38:                               # missing_features_msg:
0xffff8e38: 6d 69 73 73 69 6e 67 20 66 65 61 74 75 72 65 73 20 3a 28 00#             .asciiz "missing features :("
0xffff8e4c:                               # completed_assembly_msg:
0xffff8e4c: 61 73 73 65 6d 62 6c 79 20 63 6f 6d 70 6c 65 74 65 21 0a 00#             .asciiz "assembly complete!\n"
0xffff8e60:                               # exit_with_status_msg:
0xffff8e60: 70 72 6f 67 72 61 6d 20 65 78 69 74 65 64 20 77 69 74 68 20 73 74 61 74 75 73 20 00#             .asciiz "program exited with status "
0xffff8e7c:                               # id_str:
0xffff8e7c: 69 64 00                      #             .asciiz "id"
0xffff8e7f:                               # at_str:
0xffff8e7f: 61 74 00                      #             .asciiz "at"
0xffff8e82:                               # opcode_table2:
0xffff8e82: 04                            #             .half   4
0xffff8e83:                               # opcode_tables:                  ; pointer directly to 'name'
0xffff8e83: 6f 72                         #             .ascii  "or"
0xffff8e85: 0a                            #             .half   10
0xffff8e86: 6c 64                         #             .ascii  "ld"
0xffff8e88: 0b                            #             .half   11
0xffff8e89: 73 74                         #             .ascii  "st"
0xffff8e8b:                               # opcode_table3short:
0xffff8e8b: 00                            #             .half   0
0xffff8e8c: 61 64 64                      #             .ascii  "add"
0xffff8e8f: 01                            #             .half   1
0xffff8e90: 73 75 62                      #             .ascii  "sub"
0xffff8e93: 03                            #             .half   3
0xffff8e94: 63 6d 70                      #             .ascii  "cmp"
0xffff8e97: 05                            #             .half   5
0xffff8e98: 78 6f 72                      #             .ascii  "xor"
0xffff8e9b: 06                            #             .half   6
0xffff8e9c: 61 6e 64                      #             .ascii  "and"
0xffff8e9f: 0c                            #             .half   12
0xffff8ea0: 73 6c 6f                      #             .ascii  "slo"
0xffff8ea3:                               # opcode_table3:
0xffff8ea3: 09 07 02                      #             .half   9   7   2
0xffff8ea6: 6d 6f 76                      #             .ascii  "mov"
0xffff8ea9: 0c 04 03                      #             .half   12  4   3
0xffff8eac: 70 6f 70                      #             .ascii  "pop"
0xffff8eaf: 0e 0b 03                      #             .half   14  11  3
0xffff8eb2: 68 6c 74                      #             .ascii  "hlt"
0xffff8eb5: 0f 0b 03                      #             .half   15  11  3
0xffff8eb8: 6e 6f 70                      #             .ascii  "nop"
0xffff8ebb: 10 0b 01                      #             .half   16  11  1
0xffff8ebe: 72 65 74                      #             .ascii  "ret"
0xffff8ec1:                               # opcode_table4:
0xffff8ec1: 02                            #             .half   2
0xffff8ec2:                               # opcode_table4_state:
0xffff8ec2: 05 03                         #             .half   5   3
0xffff8ec4: 72 73 75 62                   #             .ascii  "rsub"
0xffff8ec8: 07 05 03                      #             .half   7   5   3
0xffff8ecb: 74 65 73 74                   #             .ascii  "test"
0xffff8ecf: 08 05 03                      #             .half   8   5   3
0xffff8ed2: 6d 6f 76 7a                   #             .ascii  "movz"
0xffff8ed6: 09 05 03                      #             .half   9   5   3
0xffff8ed9: 6d 6f 76 73                   #             .ascii  "movs"
0xffff8edd: 0d 02 03                      #             .half   13  2   3
0xffff8ee0: 70 75 73 68                   #             .ascii  "push"
0xffff8ee4: 10 03 01                      #             .half   16  3   1
0xffff8ee7: 63 61 6c 6c                   #             .ascii  "call"
0xffff8eeb:                               # cond_table:
0xffff8eeb: 0e                            #             .half   14
0xffff8eec:                               # cond_table_name:
0xffff8eec: 6d 70 00                      #             .asciiz "mp"
0xffff8eef: 00                            #             .half   0
0xffff8ef0: 7a 00 00                      #             .asciiz "z\0"
0xffff8ef3: 00                            #             .half   0
0xffff8ef4: 65 00 00                      #             .asciiz "e\0"
0xffff8ef7: 01                            #             .half   1
0xffff8ef8: 6e 7a 00                      #             .asciiz "nz"
0xffff8efb: 01                            #             .half   1
0xffff8efc: 6e 65 00                      #             .asciiz "ne"
0xffff8eff: 02                            #             .half   2
0xffff8f00: 6e 00 00                      #             .asciiz "n\0"
0xffff8f03: 03                            #             .half   3
0xffff8f04: 6e 6e 00                      #             .asciiz "nn"
0xffff8f07: 04                            #             .half   4
0xffff8f08: 63 00 00                      #             .asciiz "c\0"
0xffff8f0b: 04                            #             .half   4
0xffff8f0c: 62 00 00                      #             .asciiz "b\0"
0xffff8f0f: 05                            #             .half   5
0xffff8f10: 6e 63 00                      #             .asciiz "nc"
0xffff8f13: 05                            #             .half   5
0xffff8f14: 61 65 00                      #             .asciiz "ae"
0xffff8f17: 06                            #             .half   6
0xffff8f18: 6f 00 00                      #             .asciiz "o\0"
0xffff8f1b: 07                            #             .half   7
0xffff8f1c: 6e 6f 00                      #             .asciiz "no"
0xffff8f1f: 08                            #             .half   8
0xffff8f20: 62 65 00                      #             .asciiz "be"
0xffff8f23: 09                            #             .half   9
0xffff8f24: 61 00 00                      #             .asciiz "a\0"
0xffff8f27: 0a                            #             .half   10
0xffff8f28: 6c 00 00                      #             .asciiz "l\0"
0xffff8f2b: 0b                            #             .half   11
0xffff8f2c: 67 65 00                      #             .asciiz "ge"
0xffff8f2f: 0c                            #             .half   12
0xffff8f30: 6c 65 00                      #             .asciiz "le"
0xffff8f33: 0d                            #             .half   13
0xffff8f34: 67 00 00                      #             .asciiz "g\0"
0xffff8f37: 0e                            #             .half   14
0xffff8f38: 00 00 00                      #             .asciiz "\0\0"
