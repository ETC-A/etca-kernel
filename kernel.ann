0x8000:                               # .set STREAM 1
0x8000:                               # .set MODEQ 2
0x8000:                               # .set OUTPUT 3
0x8000:                               # .set SRCLINENO_OFS     -6
0x8000:                               # .set RELOC_TAB_TOP_OFS -4
0x8000:                               # .set RELOC_TAB_BOT_OFS -2
0x8000:                               # .set SYMTAB_ROOT_OFS    2
0x8000:                               # .set SYMTAB_END_OFS     4
0x8000:                               # .set EOL_CHAR_OFS       6
0x8000:                               # .set STATIC_DATA_PTR    0xC010
0x8000:                               # .set INIT_SYMTAB_ROOT   0xC020
0x8000:                               # .set INIT_STK_PTR       0x0000   ; word-aligned, I don't think we ever need to put 32-bit data on the stack
0x8000:                               # .set INIT_OBJ_STK_PTR   0x8000   ; dword-aligned, as that is the promise we make to the object program
0x8000:                               # .set BUFFER_PTR         0x0020
0x8000:                               # .set CODE_SEGMENT       0x0030
0x8000:                               # .set RELOC_TAB_TOP      0x8000   ; past the end
0x8000: b0 48                         #             call    _start
0x8002:                               # object_return_stub:
0x8002: 59 00                         #             mov     %r0, 0                  ; SYSCALL_EXIT
0x8004: 59 20                         #             mov     %r1, 0                  ; STATUS_OK
0x8006:                               # syscall:
0x8006: 43 04                         #             cmph    %r0, 4                  ; biggest known syscall is 4.
0x8008: 88 0a                         #             jbe     good_service_no         ; service <= 4? if yes, keep going. Otherwise, exit 140
0x800a: 59 00                         #             mov     %r0, 0
0x800c: 58 24 5c 2c                   #             mov     %r1, 140                ; exit code 140, SIGSYS
0x8010: 9e f6                         #             jmp     syscall
0x8012:                               # good_service_no:
0x8012: 57 c1                         #             testx   %sp, 1                  ; test the bottom stack bit. The ABI requires that this
0x8014: 80 0c                         #             jz      aligned_stack           ; crash the program with code 139 (segfault) if it's on
0x8016: 56 de                         #             andx    %sp, -2                 ; align the stack so that we don't weirdloop
0x8018: 59 00                         #             mov     %r0, 0
0x801a: 58 24 5c 2b                   #             mov     %r1, 139
0x801e: 9e e8                         #             jmp syscall
0x8020:                               # aligned_stack:
0x8020: 1d dc                         #             pushx   %ln                     ; the stack is now guaranteed to be aligned. Save %ln.
0x8022: 50 c2                         #             addx    %sp, 2                  ; But without pushing, so that we save the right %sp.
0x8024: 59 f0 5c e0 5c ea             #             mov     %ln, 0xC00A             ; &static_data->user_sp
0x802a: 1b dc                         #             stx     %sp, %ln                ; static_data->user_sp = (original) %sp
0x802c: 50 de                         #             addx    %sp, -2                 ; return stack pointer to after push %ln
0x802e: 1c f8                         #             popx    %ln                     ; restore our return address
0x8030: 59 c0                         #             mov     %sp, INIT_STK_PTR       ; initialize our own stack
0x8032: 1d dc                         #             pushx   %ln                     ; and save our return address there.
0x8034: b0 0c                         #             call    syscall_with_table      ; get the syscall table
0x8036: ac 89 e2 89 e2 89 08 8a 0e 8a #             .word   syscall_exit syscall_putuint syscall_putsint syscall_puts syscall_sbrk
0x8040:                               # syscall_with_table:
0x8040: 00 00                         #             addh    %r0, %r0                ; service_no *= sizeof(word)
0x8042: 10 e0                         #             addx    %ln, %r0                ; offset into the syscall table
0x8044: 1a fc                         #             ldx     %ln, %ln                ; load the system function to call
0x8046: af ee                         #             jmp     %ln                     ; invoke it
0x8048:                               # _start:
0x8048: 59 b0 5c a0 5c b0             #             mov     %r5, STATIC_DATA_PTR
0x804e: 59 c0                         #             mov     %r6, INIT_STK_PTR
0x8050: 58 10                         #             movz    %r0, 16
0x8052: 10 14                         #             addx    %r0, %r5                ; INIT_SYMTAB_ROOT is STATIC_DATA_PTR+16
0x8054: 19 34                         #             movx    %r1, %r5
0x8056: 50 22                         #             addx    %r1, 2                  ; &static_data.symtab_root
0x8058: 1b 04                         #             stx     %r0, %r1
0x805a: 50 22                         #             addx    %r1, 2
0x805c: 1b 04                         #             stx     %r0, %r1                ; static_data->symtab_root = static_data->symtab_end = STATIC_DATA_PTR+16
0x805e: 51 26                         #             sub     %r1, 6                  ; &static_data.reloc_tab_bot
0x8060: 59 1f 5c 00 5c 00 5c 00       #             mov     %r0, RELOC_TAB_TOP
0x8068: 1b 04                         #             stx     %r0, %r1                ; static_data->reloc_tab_bot = RELOC_TAB_TOP
0x806a: 51 22                         #             sub     %r1, 2                  ; &static_data.reloc_tab_top
0x806c: 1b 04                         #             stx     %r0, %r1                ; static_data->reloc_tab_top = RELOC_TAB_TOP
0x806e: 51 22                         #             sub     %r1, 2                  ; &static_data.src_lineno
0x8070: 59 01                         #             mov     %r0, 1                  ; initial line is line 1
0x8072: 1b 04                         #             stx     %r0, %r1                ; static_data->src_lineno = 1
0x8074: 58 01 5c 10                   #             mov     %r0, CODE_SEGMENT       ; initial code segment ip
0x8078: 1b 14                         #             stx     %r0, %r5                ; static_data->asm_ip = CODE_SEGMENT
0x807a: b1 10                         #             call    assemble_fp
0x807c: b1 36                         #             call    assemble_sp
0x807e: b0 0a                         #             call    get_start_stub
0x8080: 5f 73 74 61 72 74 00          #             .asciiz "_start"
0x8087: 00                            # 
0x8088:                               # get_start_stub:
0x8088: 19 1c                         #             movx    %r0, %ln                ; arg 0 = "_start"
0x808a: b0 90                         #             call    find_table_entry        ; find (or create, boo) a table entry for "_start"
0x808c: b1 ba                         #             call    sp_get_symbol           ; xlookup the address for _start
0x808e: 1d c0                         #             pushx   %r0                     ; stash that while we clean up
0x8090: 59 1f 5c 02 5c 13 5c 14       #             mov     %r0, completed_assembly_msg
0x8098: 59 ff 5c e2 5c ed 5c e4       #             mov     %ln, puts
0x80a0: af fe                         #             call    %ln                     ; inform the user that their program is starting soon
0x80a2: 59 ff 5c e0 5c e0 5c e2       #             mov     %ln, object_return_stub
0x80aa: 59 04                         #             mov     %r0, 4                  ; syscall - object return stub
0x80ac: 10 1c                         #             addx    %r0, %ln                ; r0 = syscall
0x80ae: 1c 38                         #             popx    %r1                     ; reload address of _start to prepare transfer of control
0x80b0: 59 df 5c c0 5c c0 5c c0       #             mov     %sp, INIT_OBJ_STK_PTR   ; initialize the object program stack pointer
0x80b8: 59 40                         #             mov     %r2, 0
0x80ba: 59 60                         #             mov     %r3, 0
0x80bc: 59 80                         #             mov     %r4, 0
0x80be: 59 a0                         #             mov     %r5, 0
0x80c0: af 2e                         #             jmp     %r1                     ; give control to the object program!
0x80c2:                               # shr5:
0x80c2: 1d c8                         #             pushx   %r2      ; having separated vaneers like this is fewer instructions
0x80c4: 58 50                         #             movzx   %r2, 16  ; I have optimized for the placement of shr4 here.
0x80c6: 10 48                         #             addx    %r2, %r2        ; 16 + 16 = 32
0x80c8: 8e 06                         #             jmp     shr_L1
0x80ca:                               # shr4:       
0x80ca: 1d c8                         #             pushx   %r2       
0x80cc: 58 50                         #             movzx   %r2, 16
0x80ce:                               # shr_L1:     
0x80ce: 1d cc                         #             pushx   %r3
0x80d0: 29 60                         #             movd    %r3, %r0        ; move x to r3
0x80d2: 1d d0                         #             pushx   %r4
0x80d4: 59 81                         #             mov     %r4, 1          ; b = 1
0x80d6: 15 00                         #             xor     %r0, %r0        ; clear r0 (it holds 'r')
0x80d8:                               # shr_L2:                             ; top of shr loop
0x80d8: 27 4c                         #             testd   %r2, %r3        ; test mask & x
0x80da: 80 04                         #             jz      shr_L3          ; don't set bit of r if !(mask & x)
0x80dc: 24 10                         #             ord     %r0, %r4        ; r |= b if mask & x, shifts that bit over
0x80de:                               # shr_L3:     
0x80de: 20 48                         #             addd    %r2, %r2        ; mask <<= 1
0x80e0: 23 4c                         #             cmpd    %r2, %r3        ; mask >? x
0x80e2: 89 08                         #             ja      shr_L4          ; if yes, further testds will fail and we can quit.
0x80e4: 20 90                         #             addd    %r4, %r4        ; b <<= 1
0x80e6: 41 21                         #             subh    %r1, 1          ; --width
0x80e8: 91 f0                         #             jnz     shr_L2          ; loop if width != 0
0x80ea:                               # shr_L4:
0x80ea: 1c 98                         #             pop     %r4             ; now r0 has the result
0x80ec: 1c 78                         #             pop     %r3               ; so we can unwind
0x80ee: 1c 58                         #             pop     %r2
0x80f0: af ee                         #             ret
0x80f2:                               # shl_L1:
0x80f2: 20 00                         #             addd    %r0, %r0        ; x <<= 1
0x80f4:                               # shl:
0x80f4: 41 21                         #             subh    %r1, 1          ; --shamt
0x80f6: 93 fc                         #             jnn     shl_L1          ; exec loop if --shamt >= 0 === shamt > 0
0x80f8: af ee                         #             ret
0x80fa:                               # strncmp:
0x80fa: 1d cc                         #             pushx   %r3             ; wind stack, giving two free registers
0x80fc: 1d d0                         #             pushx   %r4             ; which we will use to hold *a and *b
0x80fe:                               # strncmp_L1:                         ; top of loop
0x80fe: 0a 60                         #             ldh     %r3, %r0        ; r3 = *a
0x8100: 0a 84                         #             ldh     %r4, %r1        ; r4 = *b
0x8102: 01 8c                         #             subh    %r4, %r3        ; subtract *a from *b
0x8104: 81 0e                         #             jne     strncmp_L2      ; return if *a != *b
0x8106: 47 7f                         #             testh   %r3, -1         ; test *a
0x8108: 80 0a                         #             jz      strncmp_L2      ; also return if *a == 0 (note *b - *a still in %r4)
0x810a: 60 01                         #             addd    %r0, 1          ; ++a
0x810c: 60 21                         #             addd    %r1, 1          ; ++b
0x810e: 61 41                         #             subd    %r2, 1          ; --n
0x8110: 9d ee                         #             jg      strncmp_L1      ; if n is > 0, loop
0x8112:                               # strncmp_L2:                         ; return label
0x8112: 09 10                         #             movh    %r0, %r4        ; return value is *b - *a
0x8114: 1c 98                         #             popx    %r4             ; unwind stack
0x8116: 1c 78                         #             popx    %r3
0x8118: af ee                         #             ret
0x811a:                               # find_table_entry:
0x811a: 1d dc                         #             pushx   %ln                 ; we call functions so we have to save this
0x811c: 19 74                         #             movx    %r3, %r5            ; copy &static_data
0x811e: 50 62                         #             addx    %r3, SYMTAB_ROOT_OFS; r3 = &static_data.symtab_root
0x8120: 1a 2c                         #             ldx     %r1, %r3            ; r1 = static_data->symtab_root
0x8122: 50 62                         #             addx    %r3, 2              ; r3 = &static_data.symtab_end
0x8124: 1a 6c                         #             ldx     %r3, %r3            ; r3 = static_data->symtab_end
0x8126: 8e 1c                         #             jmp     find_table_entry_L3
0x8128:                               # find_table_entry_L1:                    ; loop top
0x8128: 58 50                         #             movz    %r2, 16             ; third argument = 16, first two are already name,ste
0x812a: 1d c0                         #             pushx   %r0                 ; save name
0x812c: 1d c4                         #             pushx   %r1                 ; save ste
0x812e: bf cc                         #             call    strncmp             ; r0 = !(name `streq` ste->symbol), r1 = r1 + N, r2 = r2 - N
0x8130: 57 1f                         #             test    %r0, -1             ; set Z flag if (name `streq` ste->symbol)
0x8132: 1c 18                         #             popx    %r0                 ; restore ste
0x8134: 81 08                         #             jnz     find_table_entry_L2 ; if we missed on the table, skip return and keep going
0x8136: 50 c2                         #             addx    %sp, 2              ; pop name off the stack, w/out restoring it
0x8138: 1c f8                         #             popx    %ln                 ; restore return address
0x813a: af ee                         #             ret                         ; return ste
0x813c:                               # find_table_entry_L2:
0x813c: 1c 18                         #             popx    %r0                 ; restore name
0x813e: 10 28                         #             addx    %r1, %r2            ; invariant guarantee tells us that r1 now is ste + 16
0x8140: 50 24                         #             addx    %r1, 4              ; ste = ste + 20
0x8142:                               # find_table_entry_L3:
0x8142: 13 2c                         #             cmpx    %r1, %r3            ; compare ste against symtab end
0x8144: 94 e4                         #             jb      find_table_entry_L1 ; loop as long as ste < symtab end
0x8146: 59 20                         #             mov     %r1, 0              ; argument 1 = 0
0x8148: 1c f8                         #             popx    %ln                 ; restore return address
0x814a:                               # add_table_entry:
0x814a: 1d d0                         #             pushx   %r4                 ; wind a saved register
0x814c: 19 54                         #             movx    %r2, %r5            ; char *ptr = &static_data
0x814e: 50 44                         #             addx    %r2, SYMTAB_END_OFS ; ptr = &static_data.symtab_end
0x8150: 1d c8                         #             pushx   %r2                 ; spill this address for quick retrieval
0x8152: 1a 48                         #             ldx     %r2, %r2            ; ptr = static_data->symtab_end
0x8154: 59 64                         #             mov     %r3, 4              ; i = 4
0x8156:                               # add_table_entry_L1:
0x8156: 2a 80                         #             ldd     %r4, %r0            ; temp = *name, 32-bit transfer
0x8158: 2b 88                         #             std     %r4, %r2            ; *ptr = *name, 32-bit transfer
0x815a: 50 04                         #             addx    %r0, 4              ; name += 4
0x815c: 50 44                         #             addx    %r2, 4              ; ptr  += 4
0x815e: 51 61                         #             sub     %r3, 1              ; --i
0x8160: 91 f6                         #             jnz     add_table_entry_L1  ; loop until i == 0
0x8162: 2b 28                         #             std     %r1, %r2            ; *ptr = payload
0x8164: 50 44                         #             addx    %r2, 4              ; ptr += 4
0x8166: 1c 38                         #             popx    %r1                 ; r1 = &static_data.symtab_end (spilled earlier)
0x8168: 1a 04                         #             ldx     %r0, %r1            ; return value = static_data->symtab_end
0x816a: 1b 44                         #             stx     %r2, %r1            ; static_data->symtab_end = ptr
0x816c: 1c 98                         #             popx    %r4                 ; unwind
0x816e: af ee                         #             ret
0x8170:                               # ste_attach_payload:
0x8170: 1d dc                         #             pushx   %ln                 ; save return address
0x8172: 1d c4                         #             pushx   %r1                 ; save payload
0x8174: bf a6                         #             call    find_table_entry    ; r0 = entry for 'name'
0x8176: 58 30                         #             movz    %r1, 16             ; r1 = offsetof(table_entry, payload)
0x8178: 10 04                         #             addx    %r0, %r1            ; r0 = &entry.payload
0x817a: 1c 38                         #             popx    %r1                 ; r1 = payload
0x817c: 1b 20                         #             stx     %r1, %r0            ; entry->payload = payload
0x817e: 1c f8                         #             popx    %ln
0x8180: af ee                         #             ret
0x8182:                               # ste_get_payload:
0x8182: 50 08                         #             addx    %r0, 8
0x8184: 50 08                         #             addx    %r0, 8              ; 16 is too large for add, so add 8 twice
0x8186: 1a 00                         #             ldx     %r0, %r0            ; entry->payload
0x8188: af ee                         #             ret
0x818a:                               # assemble_fp:
0x818a: 1d dc                         #             pushx   %ln
0x818c:                               # assemble_fp_L1:
0x818c: b2 16                         #             call    fpsm
0x818e: 19 14                         #             movx    %r0, %bp            ; r0 = &static_data
0x8190: 50 1a                         #             addx    %r0, SRCLINENO_OFS  ; r0 = &static_data.src_lineno
0x8192: 1a 20                         #             ldx     %r1, %r0            ; r1 = static_data->src_lineno
0x8194: 50 21                         #             addx    %r1, 1
0x8196: 1b 20                         #             stx     %r1, %r0            ; static_data->src_lineno++
0x8198: 50 04                         #             addx    %r0, 4              ; r0 = &static_data.reloc_tab_bot
0x819a: 1a 20                         #             ldx     %r1, %r0            ; r1 = static_data->reloc_tab_bot
0x819c: 1a 54                         #             ldx     %r2, %bp            ; r2 = static_data->asm_ip
0x819e: 13 44                         #             cmpx    %r2, %r1            ; asm_ip >? reloc_tab_bot
0x81a0: 88 06                         #             jbe     assemble_fp_L2      ; if no, don't die
0x81a2: 59 04                         #             mov     %r0, 4              ; arg 0 = OUT_OF_MEMORY_CODE
0x81a4: b7 2e                         #             call    die
0x81a6:                               # assemble_fp_L2:
0x81a6: 50 08                         #             addx    %r0, 8              ; r0 = &static_data.eol_char
0x81a8: 0a 00                         #             ldh     %r0, %r0            ; r0 = static_data->eol_char
0x81aa: 47 1f                         #             testh   %r0, -1             ; test the char
0x81ac: 91 e0                         #             jnz     assemble_fp_L1      ; loop if it's not \NUL
0x81ae: 1c f8                         #             popx    %ln                 ; if it's \NUL, we're done.
0x81b0: af ee                         #             ret
0x81b2:                               # assemble_sp:
0x81b2: 1d dc                         #             pushx   %ln
0x81b4: 1a 14                         #             ldx     %r0, %bp            ; r0 = static_data->asm_ip
0x81b6: 1d c0                         #             pushx   %r0                 ; save ip at end of program
0x81b8: 59 1a                         #             mov     %r0, SRCLINENO_OFS
0x81ba: 10 14                         #             addx    %r0, %bp            ; r0 = &static_data.src_lineno
0x81bc: 1a 00                         #             ldx     %r0, %r0            ; r0 = static_data->src_lineno
0x81be: 1d c0                         #             pushx   %r0                 ; save final lineno (idk why but hey)
0x81c0: 59 1e                         #             mov     %r0, RELOC_TAB_BOT_OFS
0x81c2: 10 14                         #             addx    %r0, %bp            ; r0 = &static_data.reloc_tab_bot
0x81c4: 1a 40                         #             ldx     %r2, %r0            ; r2 = reloc_entry = static_data->reloc_tab_bot
0x81c6: 57 5f                         #             testx   %r2, -1             ; test the pointer to see if it's negative
0x81c8: 82 1e                         #             jn      assemble_sp_L2      ; skip the loop entirely if so
0x81ca:                               # assemble_sp_L1:
0x81ca: 1d c8                         #             pushx   %r2                 ; save original value of reloc_entry
0x81cc: 1a 28                         #             ldx     %r1, %r2            ; r1 = arg 1 = reloc_entry->asm_ip
0x81ce: 1b 34                         #             stx     %r1, %bp            ; static_data->asm_ip = reloc_entry->asm_ip
0x81d0: 50 44                         #             addx    %r2, 4              ; &reloc_entry.src_lineno
0x81d2: 1a 08                         #             ldx     %r0, %r2            ; r0 = reloc_entry->src_lineno
0x81d4: 59 7a                         #             mov     %r3, SRCLINENO_OFS
0x81d6: 10 74                         #             addx    %r3, %bp            ; r3 = &static_data.src_lineno
0x81d8: 1b 0c                         #             stx     %r0, %r3            ; static_data->src_lineno = reloc_entry->src_lineno
0x81da: 51 42                         #             subx    %r2, 2              ; &reloc_entry.entry
0x81dc: 1a 08                         #             ldx     %r0, %r2            ; arg 0 = reloc_entry->entry
0x81de: b0 18                         #             call    assemble_sp_visit   ; handle this reloc table entry
0x81e0: 1c 58                         #             popx    %r2                 ; reload original value of reloc_entry
0x81e2: 50 46                         #             addx    %r2, 6              ; advance to next entry
0x81e4: 93 e6                         #             jnn     assemble_sp_L1      ; if result is not negative, it's a valid entry. Loop.
0x81e6:                               # assemble_sp_L2:
0x81e6: 1c 18                         #             popx    %r0                 ; restore final lineno
0x81e8: 59 3a                         #             mov     %r1, SRCLINENO_OFS
0x81ea: 10 34                         #             addx    %r1, %bp            ; &static_data.src_lineno
0x81ec: 1b 04                         #             stx     %r0, %r1            ; static_data->src_lineno = saved original lineno
0x81ee: 1c 18                         #             popx    %r0                 ; restore ip at end of program
0x81f0: 1b 14                         #             stx     %r0, %bp            ; static_data->asm_ip = ip at end of program
0x81f2: 1c f8                         #             popx    %ln                 ; restore return address
0x81f4: af ee                         #             ret
0x81f6:                               # assemble_sp_visit:
0x81f6: 1d dc                         #             pushx   %ln
0x81f8: b0 4e                         #             call    sp_get_symbol       ; arg 0 = target = sp_get_symbol(ste)
0x81fa: 0a 44                         #             ldh     %r2, %r1            ; opc = *asm_ip
0x81fc: 43 5f                         #             cmph    %r2, -1             ; test if opc is -1
0x81fe: 81 0c                         #             jne     assemble_sp_visit_tx; if it's not, it's a control transfer
0x8200: 50 21                         #             addx    %r1, 1              ; asm_ip + 1
0x8202: 0a 44                         #             ldh     %r2, %r1            ; r2 = reg = *(asm_ip+1)
0x8204: 19 20                         #             movx    %r1, %r0            ; arg 1 = target
0x8206: 09 08                         #             movh    %r0, %r2            ; arg 0 = reg
0x8208: b1 2e                         #             call    assemble_long_mov   ; tail-call (it won't be returning here)
0x820a:                               # assemble_sp_visit_tx:
0x820a: 43 4f                         #             cmph    %r2, 15             ; opc >? 15
0x820c: 89 78                         #             ja      fp_call_L           ; if yes, this is a call
0x820e: 8e a2                         #             jmp     fp_jump_L           ; otherwise, it's a jump
0x8210:                               # fp_get_symbol:
0x8210: 1d dc                         #             pushx   %ln
0x8212: 1d c8                         #             pushx   %r2                 ; stack wind
0x8214: bf 06                         #             call    find_table_entry    ; r0 = entry = find_table_entry(name)
0x8216: 1d c0                         #             pushx   %r0                 ; spill entry
0x8218: bf 6a                         #             call    ste_get_payload     ; r0 = ste_get_payload(entry)
0x821a: 57 1f                         #             testx   %r0, -1             ; check the returned payload value
0x821c: 81 22                         #             jnz     fp_get_symbol_unwind; if it's not 0, we're done.
0x821e: 19 34                         #             mov     %r1, %bp            ; r1 = copy &static_data
0x8220: 50 3e                         #             addx    %r1, RELOC_TAB_BOT_OFS ; r1 = &static_data.reloc_tab_bot
0x8222: 1a 44                         #             ldx     %r2, %r1            ; r2 = static_data->reloc_tab_bot
0x8224: 51 46                         #             subx    %r2, 6              ; r2 = static_data->reloc_tab_bot - 1 (ptr arith)
0x8226: 1b 44                         #             stx     %r2, %r1            ; static_data->reloc_tab_bot -= 1
0x8228: 1a 14                         #             ldx     %r0, %bp            ; r0 = static_data->asm_ip
0x822a: 1b 08                         #             stx     %r0, %r2            ; reloc->asmp_ip = static_data->asm_ip
0x822c: 50 42                         #             addx    %r2, 2              ; point at &reloc.entry
0x822e: 1c 18                         #             popx    %r0                 ; reload entry from stack
0x8230: 1b 08                         #             stx     %r0, %r2            ; reloc->entry = entry
0x8232: 50 3c                         #             addx    %r1, -4             ; offset of lineno from reloc_tab_bot ofs
0x8234: 1a 04                         #             ldx     %r0, %r1            ; r0 = static_data->src_lineno
0x8236: 50 42                         #             addx    %r2, 2              ; point at &reloc.src_lineno
0x8238: 1b 08                         #             stx     %r0, %r2            ; reloc->src_lineno = static_data->src_lineno
0x823a: 59 00                         #             mov     %r0, 0              ; prepare return value of 0
0x823c: 8e 04                         #             jmp     fp_get_symbol_unwind2 ; unwind, but we've already popped off entry
0x823e:                               # fp_get_symbol_unwind:
0x823e: 50 c2                         #             addx    %sp, 2              ; discard top of stack (spilled entry)
0x8240:                               # fp_get_symbol_unwind2:
0x8240: 1c 58                         #             popx    %r2                 ; stack unwind
0x8242: 1c f8                         #             popx    %ln
0x8244: af ee                         #             ret
0x8246:                               # sp_get_symbol:
0x8246: 1d c0                         #             pushx   %r0                 ; push entry
0x8248: 50 08                         #             addx    %r0, 8
0x824a: 50 08                         #             addx    %r0, 8              ; point at entry.payload
0x824c: 1a 00                         #             ldx     %r0, %r0            ; r0 = entry->payload
0x824e: 57 1f                         #             testx   %r0, -1             ; test payload
0x8250: 80 06                         #             jz      sp_get_symbol_crash ; if it's zero, crash.
0x8252: 50 c2                         #             addx    %sp, 2              ; otherwise, unwind stack
0x8254: af ee                         #             ret                         ; and return.
0x8256:                               # sp_get_symbol_crash:
0x8256: 1c 38                         #             popx    %r1                 ; otherwise, reload the entry
0x8258: 59 05                         #             mov     %r0, 5              ; arg 0 = UNKNOWN_SYMBOL_CODE
0x825a: b6 78                         #             call    die                 ; crash
0x825c:                               # fp_die_out_range:
0x825c: 59 03                         #             mov     %r0, 3              ; OUT_OF_RANGE_CODE
0x825e: b6 74                         #             call    die
0x8260:                               # fp_0:
0x8260: 43 4f                         #             cmph    %r2, 15             ; opc <=? 15
0x8262: 89 0e                         #             ja      fp_0_encode_ret     ; if not, encode a return
0x8264: 49 04                         #             movh    %r0, 4              ; otherwise, enc_fst = 4
0x8266: 4c 00                         #             sloh    %r0, 0              ; enc_fst <<= 5
0x8268: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0x826a: 49 20                         #             movh    %r1, 0              ; enc_snd = 0
0x826c: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0x826e: 8e 8c                         #             jmp     finalize_encoding   ; tail-call
0x8270:                               # fp_0_encode_ret:
0x8270: 59 07                         #             mov     %r0, 7              ; regL = 7
0x8272: 46 4f                         #             andh    %r2, 15             ; opc &= 15
0x8274: 8e 02                         #             jmp     fp_RJ               ; tail-call
0x8276:                               # fp_RJ:
0x8276: 09 20                         #             movh    %r1, %r0            ; enc_snd = reg
0x8278: 4c 20                         #             sloh    %r1, 0              ; enc_snd <<= 5
0x827a: 04 28                         #             orh     %r1, %r2            ; enc_snd |= opc
0x827c: 49 05                         #             movh    %r0, 5              ; enc_fst = 5
0x827e: 4c 0f                         #             sloh    %r0, 15             ; enc_fst = enc_fst << 5 | 15
0x8280: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0x8282: 8e 78                         #             jmp     finalize_encoding   ; tail-call
0x8284:                               # fp_call_L:
0x8284: 11 04                         #             subx    %r0, %r1            ; disp = tgt - here
0x8286: 58 21 5c 3f 5c 3f             #             mov     %r1, 2047           ; get 2047 for comparison
0x828c: 13 04                         #             cmpx    %r0, %r1            ; disp >? 2047
0x828e: 9d ce                         #             jg      fp_die_out_range    ; if yes, die
0x8290: 52 3f                         #             rsubx   %r1, -1             ; r1 = ~2047 = -2048
0x8292: 13 04                         #             cmpx    %r0, %r1            ; disp <? -2048
0x8294: 9a c8                         #             jl      fp_die_out_range
0x8296: 19 60                         #             mov     %r3, %r0            ; save displacement in r3
0x8298: 59 28                         #             mov     %r1, 8              ; arg 1 = 8
0x829a: be 30                         #             call    shr4                ; imm = (imm >> 4) & 0xFF
0x829c: 59 24                         #             mov     %r1, 4              ; arg 1 = 4
0x829e: be 2c                         #             call    shr4                ; imm = (imm >> 4) & 0xF
0x82a0: 40 08                         #             addh    %r0, 8
0x82a2: 40 08                         #             addh    %r0, 8              ; imm += 16
0x82a4: 59 25                         #             mov     %r1, 5
0x82a6: 4c 20                         #             sloh    %r1, 0              ; r1 = 5 << 5
0x82a8: 04 04                         #             orh     %r0, %r1            ; enc_fst = imm | (5 << 5)
0x82aa: 19 2c                         #             mov     %r1, %r3            ; put displacement back in arg 1
0x82ac: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0x82ae: 8e 4c                         #             jmp     finalize_encoding   ; tail-call
0x82b0:                               # fp_jump_L:
0x82b0: 12 20                         #             rsubx   %r1, %r0            ; disp = tgt - done
0x82b2: 58 07 5c 1f                   #             mov     %r0, 255            ; get 255 for comparison
0x82b6: 13 20                         #             cmpx    %r1, %r0            ; disp >? 255
0x82b8: 9d a4                         #             jg      fp_die_out_range    ; if yes, die
0x82ba: 52 1f                         #             rsubx   %r0, -1             ; r0 = ~255 = -256
0x82bc: 13 20                         #             cmpx    %r1, %r0            ; disp <? -256
0x82be: 9a 9e                         #             jl      fp_die_out_range
0x82c0: 53 20                         #             cmpx    %r1, 0              ; disp <? 0
0x82c2: 8b 06                         #             jge     fp_jump_L_skip_inc  ; if not, don't adjust the opcode
0x82c4: 50 48                         #             addx    %r2, 8
0x82c6: 50 48                         #             addx    %r2, 8              ; opc += 16
0x82c8:                               # fp_jump_L_skip_inc:
0x82c8: 59 04                         #             mov     %r0, 4              ; enc_fst = 4
0x82ca: 4c 00                         #             sloh    %r0, 0              ; enc_fst <<= 5
0x82cc: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0x82ce: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0x82d0: 8e 2a                         #             jmp     finalize_encoding   ; tail-call
0x82d2:                               # fp_RR:
0x82d2: 00 24                         #             addh    %r1, %r1            ; regR <<= 1
0x82d4: 00 24                         #             addh    %r1, %r1            ; regR <<= 1
0x82d6: 4c 00                         #             sloh    %r0, 0              ; regL <<= 5
0x82d8: 04 20                         #             orh     %r1, %r0            ; enc_snd = regL (<< 5) | regR (<< 2)
0x82da:                               # fp_RX_shared:
0x82da: 00 6c                         #             addh    %r3, %r3            ; size_bits << 1
0x82dc: 00 6c                         #             addh    %r3, %r3            ; size_bits << 2
0x82de: 00 6c                         #             addh    %r3, %r3            ; size_bits << 3
0x82e0: 00 6c                         #             addh    %r3, %r3            ; size_bits << 4
0x82e2: 09 0c                         #             movh    %r0, %r3            ; enc_fst = size_bits << 4
0x82e4: 04 08                         #             orh     %r0, %r2            ; enc_fst |= opc
0x82e6: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0x82e8: 8e 12                         #             jmp     finalize_encoding
0x82ea:                               # fp_RI_stdcall:
0x82ea: 1d dc                         #             pushx   %ln
0x82ec:                               # fp_RI:
0x82ec: 4c 00                         #             sloh    %r0, 0              ; regL <<= 5
0x82ee: 58 ff                         #             movz    %r7, 31
0x82f0: 06 3c                         #             andh    %r1, %r7            ; imm &= 31
0x82f2: 04 20                         #             orh     %r1, %r0            ; enc_snd = regL (<< 5) | imm (& 31)
0x82f4: 40 64                         #             addh    %r3, 4              ; size_bits += 4
0x82f6: 9e e4                         #             jmp     fp_RX_shared        ; tail-call to setup enc_fst and numbytes
0x82f8:                               # finalize_encoding_stdcall:
0x82f8: 1d dc                         #             pushx   %ln
0x82fa:                               # finalize_encoding:
0x82fa: 1a f4                         #             ldx     %r7, %bp            ; r7 = iloc = static_data->asm_ip
0x82fc: 10 5c                         #             addx    %r2, %r7            ; r2 = iloc + numbytes
0x82fe: 1b 54                         #             stx     %r2, %bp            ; static_data->asm_ip += numbytes
0x8300: 0b 1c                         #             sth     %r0, %r7            ; *iloc = first byte
0x8302: 50 e1                         #             addx    %r7, 1              ; iloc + 1
0x8304: 0b 3c                         #             sth     %r1, %r7            ; *(iloc + 1) = second byte
0x8306: 1c f8                         #             popx    %ln
0x8308: af ee                         #             ret
0x830a:                               # fp_R:
0x830a: 43 4c                         #             cmph    %r2, 12             ; opc == 12?
0x830c: 81 06                         #             jne     fp_R_push           ; if not, encode a push
0x830e: 49 26                         #             movh    %r1, 6              ; otherwise, encode a pop
0x8310: 9e c2                         #             jmp     fp_RR               ; tail-call
0x8312:                               # fp_R_push:
0x8312: 09 20                         #             movh    %r1, %r0            ; regR = regL
0x8314: 49 06                         #             movh    %r0, 6              ; regL = 6
0x8316: 9e bc                         #             jmp     fp_RR               ; tail-call
0x8318:                               # fp_I:
0x8318: 49 06                         #             movh    %r0, 6              ; regL = 6
0x831a: 9e d2                         #             jmp     fp_RI               ; tail-call
0x831c:                               # fp_LM:
0x831c: 57 9f                         #             testx   %r4, -1             ; test name
0x831e: 80 18                         #             jz      assemble_long_mov   ; if it's null, dispatch immediately (tail call)
0x8320: 09 40                         #             movh    %r2, %r0            ; r2 = reg
0x8322: 19 10                         #             movx    %r0, %r4            ; arg 0 = name
0x8324: be ec                         #             call    fp_get_symbol       ; lookup the payload for name
0x8326: 57 1f                         #             testx   %r0, -1             ; test it
0x8328: 81 0a                         #             jnz     fp_LM_have_imm      ; if it's valid, rearrange args and go
0x832a: 49 1f                         #             movh    %r0, -1             ; otherwise, set up to defer
0x832c: 09 28                         #             movh    %r1, %r2            ; arg 1 = reg
0x832e: 59 48                         #             movx    %r2, 8              ; numbytes = 8
0x8330: 9e ca                         #             jmp     finalize_encoding   ; tail-call
0x8332:                               # fp_LM_have_imm:
0x8332: 19 20                         #             movx    %r1, %r0            ; arg 1 = imm
0x8334: 09 08                         #             movh    %r0, %r2            ; arg 0 = reg
0x8336:                               # assemble_long_mov:
0x8336: 1d c0                         #             pushx   %r0                 ; spill reg
0x8338: 1d c4                         #             pushx   %r1                 ; spill immediate
0x833a: 53 20                         #             cmpx    %r1, 0              ; imm <? 0
0x833c: 59 20                         #             mov     %r1, 0              ; arg 1 = 0
0x833e: 8b 04                         #             jge     alm_L1              ; if imm >= 0, don't adjust arg 1
0x8340: 59 21                         #             mov     %r1, 1              ; otherwise arg 1 = 1
0x8342:                               # alm_L1:
0x8342: 59 49                         #             mov     %r2, 9              ; opc = 9
0x8344: 59 61                         #             mov     %r3, 1              ; size_bits = 1
0x8346: bf a4                         #             call    fp_RI_stdcall       ; encode 'mov %dst, bool(imm < 0)'
0x8348: 1c 18                         #             popx    %r0                 ; r0 = reload immediate
0x834a: 1c 98                         #             popx    %r4                 ; r4 = reload reg (r4 is not clobbered by fp_RI)
0x834c: 58 3f                         #             movz    %r1, 31             ; get 31
0x834e: 16 20                         #             andx    %r1, %r0            ; r1 = bottom = imm & 31
0x8350: 1d c4                         #             pushx   %r1                 ; spill bottom
0x8352: 59 2a                         #             mov     %r1, 10             ; arg 1 = 10
0x8354: bd 6e                         #             call    shr5                ; middle = (imm >> 5) & 0x3FF
0x8356: 58 3f                         #             movz    %r1, 31
0x8358: 16 20                         #             andx    %r1, %r0            ; r1 = middle & 0x1F
0x835a: 1d c4                         #             pushx   %r1                 ; spill that value
0x835c: 59 25                         #             mov     %r1, 5              ; arg 1 = 5
0x835e: bd 64                         #             call    shr5                ; top = (imm >> 10) & 0x1F
0x8360: 19 20                         #             mov     %r1, %r0            ; arg 1 = top
0x8362: 19 10                         #             mov     %r0, %r4            ; arg 0 = reg
0x8364: 59 4c                         #             mov     %r2, 12             ; arg 2 = 12
0x8366: 59 61                         #             mov     %r3, 1              ; size_bits = 1
0x8368: bf 82                         #             call    fp_RI_stdcall       ; encode 'slo %dst, ((imm >> 10) & 0x1F)'
0x836a: 1c 38                         #             popx    %r1                 ; arg 1 = reload middle & 0x1F
0x836c: 19 10                         #             mov     %r0, %r4            ; arg 0 = reg
0x836e: 59 4c                         #             mov     %r2, 12             ; arg 2 = 12
0x8370: 59 61                         #             mov     %r3, 1              ; size_bits = 1
0x8372: bf 78                         #             call    fp_RI_stdcall       ; encode 'slo %dst, ((imm >> 5) & 0x1F)'
0x8374: 1c 38                         #             popx    %r1                 ; reload bottom
0x8376: 19 10                         #             mov     %r0, %r4            ; arg 0 = reg
0x8378: 59 4c                         #             mov     %r2, 12             ; arg 2 = 12
0x837a: 59 61                         #             mov     %r3, 1              ; size_bits = 1
0x837c: 9e 70                         #             jmp     fp_RI               ; encode 'slo %dst, (imm & 0x1F)' and return
0x837e:                               # fp_LJ_good_payload:
0x837e: 58 3e                         #             mov     %r1, 30             ; get 30 for comparison
0x8380: 03 44                         #             cmph    %r2, %r1            ; opc == 30?
0x8382: 1a 34                         #             ldx     %r1, %bp            ; arg 1 = static_data->asm_ip
0x8384: 90 00                         #             je      fp_call_L           ; if opc == 30, go to call_L
0x8386: 9e 2a                         #             jmp     fp_jump_L           ; otherwise, to jump_L
0x8388:                               # fp_LJ:
0x8388: 43 4f                         #             cmph    %r2, 15             ; opc >? 15
0x838a: 88 08                         #             jbe     fp_LJ_good_opc      ; if no, we have a jump which is valid
0x838c: 58 1e                         #             mov     %r0, 30             ; get 30 for comparison
0x838e: 03 40                         #             cmph    %r2, %r0            ; opc == 30?
0x8390: 81 ce                         #             jne     fpsm_reject         ; if no, reject
0x8392:                               # fp_LJ_good_opc:
0x8392: 19 10                         #             mov     %r0, %r4            ; arg 0 = name
0x8394: be 7c                         #             call    fp_get_symbol       ; r0 = payload for name in symtab
0x8396: 57 1f                         #             testx   %r0, -1             ; test the payload
0x8398: 91 e6                         #             jnz     fp_LJ_good_payload  ; if it's not 0, dispatch to {call/jump}_L
0x839a: 09 08                         #             movh    %r0, %r2            ; arg 0 = opc
0x839c: 59 3f                         #             mov     %r1, -1             ; arg 1 = -1
0x839e: 59 42                         #             mov     %r2, 2              ; numbytes = 2
0x83a0: 9e 5a                         #             jmp     finalize_encoding   ; tail-call
0x83a2:                               # fpsm:
0x83a2: 1d dc                         #             pushx   %ln
0x83a4: 1d d4                         #             pushx   %r5
0x83a6: 1a 74                         #             ldx     %r3, %r5            ; r3 = static_data->asm_ip
0x83a8: 4a a1                         #             ldh     %r5, STREAM         ; initialize reader
0x83aa: b4 a4                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0x83ac: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0x83ae: 80 1a                         #             jz      fpsm_0_notalpha     ; branch past name read if not name start
0x83b0: b2 56                         #             call    read_name           ; r0 = pointer to read-in name
0x83b2: 09 94                         #             movh    %r4, %r5            ; stash cur in r4
0x83b4: 1c b8                         #             popx    %r5                 ; temporarily reload &static_data
0x83b6: 19 2c                         #             movx    %r1, %r3            ; r1 = static_data->asm_ip
0x83b8: bd b8                         #             call    ste_attach_payload  ; add this entry to the symbol table
0x83ba: 1d d4                         #             pushx   %r5                 ; re-push &static_data
0x83bc: 09 b0                         #             movh    %r5, %r4            ; restore cur to r5
0x83be: 58 01 5c 1a                   #             mov     %r0, 58             ; setup 58 == ':' for comparison
0x83c2: b3 5e                         #             call    match               ; cur == ':'?
0x83c4: 47 1f                         #             testh   %r0, -1             ; test result
0x83c6: 81 98                         #             jnz     fpsm_reject         ; reject with syntax error if cur != ':'
0x83c8:                               # fpsm_0_notalpha:
0x83c8: 59 21                         #             mov     %r1, 1              ; state = 1
0x83ca: 8e d6                         #             jmp     fpsm_iterate        ; step the loop
0x83cc:                               # fpsm_1:                                 ; switch case 1
0x83cc: b4 e2                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0x83ce: 47 1f                         #             testh   %r0, -1             ; test result
0x83d0: 81 12                         #             jnz     fpsm_1_accept       ; accept if is_eol(cur)
0x83d2: b3 54                         #             call    read_opcode         ; r0 = rop.opcode, r1 = rop.state
0x83d4: 09 80                         #             movh    %r4, %r0            ; temporarily save the opcode in r4
0x83d6: 09 64                         #             movh    %r3, %r1            ; temporarily save the target state in r3
0x83d8: b1 c6                         #             call    read_size           ; r0 = size_bits
0x83da: 1d c0                         #             pushx   %r0                 ; put size_bits in their stack slot
0x83dc: 1d d0                         #             pushx   %r4                 ; put opcode into its stack slot
0x83de: 09 2c                         #             movh    %r1, %r3            ; re-place the state in r1
0x83e0: 8e c0                         #             jmp     fpsm_iterate        ; break
0x83e2:                               # fpsm_1_accept:
0x83e2: 1c 98                         #             popx    %r4                 ; restore static_data pointer
0x83e4: 50 86                         #             addx    %r4, EOL_CHAR_OFS   ; &static_data.eol_char
0x83e6: 0b b0                         #             sth     %r5, %r4            ; static_data->eol_char = cur
0x83e8: 51 86                         #             subx    %r4, EOL_CHAR_OFS   ; undo offset
0x83ea: 19 b0                         #             movx    %r5, %r4            ; move pointer back where it belongs
0x83ec: 1c f8                         #             popx    %ln
0x83ee: af ee                         #             ret
0x83f0:                               # fpsm_2:
0x83f0: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x83f4: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x83f6: 81 0a                         #             jne     fpsm_2_imm          ; if not equal, try checking immediate
0x83f8: b3 00                         #             call    read_register       ; if yes equal, read a register
0x83fa: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0x83fc: 59 2c                         #             mov     %r1, 12             ; state = 12
0x83fe: 8e a2                         #             jmp     fpsm_iterate        ; break
0x8400:                               # fpsm_2_imm:
0x8400: b4 7c                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0x8402: 47 1f                         #             testh   %r0, -1             ; test is_imm_start(cur)
0x8404: 80 5a                         #             jz      fpsm_reject         ; if !is_imm_start(cur), this state rejects
0x8406: b1 ca                         #             call    read_immediate      ; otherwise, read the immediate
0x8408: 58 3f                         #             movz    %r1, 31             ; validate_u5 in %r0; see 'validate_u5' below
0x840a: 23 04                         #             cmpd    %r0, %r1            ; set 'be' condition if imm is valid
0x840c: 89 56                         #             ja      fpsm_invalid_imm    ; if not 'be' condition, imm is invalid. Die.
0x840e: 19 60                         #             movx    %r3, %r0            ; imm = read & validated immediate
0x8410: 59 2d                         #             mov     %r1, 13             ; state = 13
0x8412: 8e 8e                         #             jmp     fpsm_iterate        ; break
0x8414:                               # fpsm_3:
0x8414: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x8418: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x841a: 81 0a                         #             jne     fpsm_3_label        ; if not equal, try checking label
0x841c: b2 dc                         #             call    read_register       ; if yes equal, read a register
0x841e: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0x8420: 59 2e                         #             mov     %r1, 14             ; state = 14
0x8422: 8e 7e                         #             jmp     fpsm_iterate        ; break
0x8424:                               # fpsm_3_label:
0x8424: b4 2a                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0x8426: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0x8428: 80 36                         #             jz      fpsm_reject         ; if !is_alpha(cur), this state rejects
0x842a: b1 dc                         #             call    read_name           ; r0 = read_name()
0x842c: 19 80                         #             movx    %r4, %r0            ; symbolptr = read_name()
0x842e: 59 2f                         #             mov     %r1, 15             ; state = 15
0x8430: 8e 70                         #             jmp     fpsm_iterate        ; break
0x8432:                               # fpsm_4:
0x8432: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x8436: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x8438: 81 26                         #             jne     fpsm_reject         ; if not a register, this state rejects
0x843a: b2 be                         #             call    read_register       ; r0 = read_register()
0x843c: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0x843e: 59 2c                         #             mov     %r1, 12             ; state = 12
0x8440: 8e 60                         #             jmp     fpsm_iterate        ; break
0x8442:                               # fpsm_5:
0x8442: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x8446: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x8448: 81 16                         #             jne     fpsm_reject         ; if not a register, this state rejects
0x844a: b2 ae                         #             call    read_register       ; r0 = read_register()
0x844c: 09 40                         #             movh    %r2, %r0            ; regL = read_register()
0x844e: 59 26                         #             mov     %r1, 6              ; state = 6
0x8450:                               # fpsm_scan_comma:
0x8450: b1 28                         #             call    skip_whitespace     ; skip whitespace between reg and comma
0x8452: 58 01 5c 0c                   #             mov     %r0, 44             ; r0 = ',' to check
0x8456: b2 ca                         #             call    match               ; r0 = (cur != ',')
0x8458: 47 1f                         #             testh   %r0, -1             ; test (cur != ',')
0x845a: 81 04                         #             jnz     fpsm_reject         ; if it's not a comma, that's an error
0x845c: 8e 44                         #             jmp     fpsm_iterate        ; break
0x845e:                               # fpsm_reject:
0x845e: 59 00                         #             mov     %r0, 0              ; r0 = INVALID_SYNTAX_CODE
0x8460: b4 72                         #             call    die
0x8462:                               # fpsm_invalid_imm:
0x8462: 59 02                         #             mov     %r0, 2              ; r0 = INVALID_IMMEDIATE_CODE
0x8464: b4 6e                         #             call    die
0x8466:                               # fpsm_6:
0x8466: 1c 98                         #             popx    %r4                 ; r4 = opc
0x8468: 51 c2                         #             subx    %sp, 2              ; put %sp back so that opc stays on the stack
0x846a: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x846e: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x8470: 81 0e                         #             jne     fpsm_6_imm          ; if not a register, try checking immediate
0x8472: 43 8c                         #             cmph    %r4, 12             ; opc == OPC_SLO?
0x8474: 90 ea                         #             je      fpsm_reject         ; this state rejects OPC_SLO
0x8476: b2 82                         #             call    read_register       ; r0 = read_register()
0x8478: 09 60                         #             movh    %r3, %r0            ; regR = read_register()
0x847a: 58 30                         #             mov     %r1, 16             ; state = 16
0x847c: 8e 24                         #             jmp     fpsm_iterate        ; break
0x847e:                               # fpsm_6_imm:
0x847e: b3 fe                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0x8480: 57 1f                         #             test    %r0, -1             ; test is_imm_start(cur)
0x8482: 90 dc                         #             jz      fpsm_reject         ; if !is_imm_start(cur), this state rejects
0x8484: b1 4c                         #             call    read_immediate      ; r0 = read_immediate()
0x8486: 43 8a                         #             cmph    %r4, 10             ; opc >= 10?
0x8488: 85 0c                         #             jae     fpsm_6_u5           ; if yes, validate unsigned
0x848a: 43 88                         #             cmph    %r4, 8              ; opc == 8?
0x848c: 80 08                         #             je      fpsm_6_u5           ; if yes, validate unsigned
0x848e:                               # fpsm_6_s5:
0x848e: b3 ae                         #             call    validate_s5         ; r0 unchanged, flags set 'b' if valid
0x8490: 95 d2                         #             jae     fpsm_invalid_imm    ; if not 'b' condition, imm is invalid. Die.
0x8492: 8e 08                         #             jmp     fpsm_6_end          ; clean up
0x8494:                               # fpsm_6_u5:
0x8494: 58 3f                         #             movz    %r1, 31             ; validate_u5 in %r0; see 'validate_u5' below
0x8496: 23 04                         #             cmpd    %r0, %r1            ; set 'be' condition if imm is valid
0x8498: 99 ca                         #             ja      fpsm_invalid_imm    ; if not 'be' condition, imm is invalid. Die.
0x849a:                               # fpsm_6_end:
0x849a: 19 60                         #             movx    %r3, %r0            ; imm = r0
0x849c: 58 31                         #             mov     %r1, 17             ; state = 17
0x849e: 8e 02                         #             jmp     fpsm_iterate        ; break
0x84a0:                               # fpsm_iterate:
0x84a0: b0 d8                         #             call    skip_whitespace
0x84a2: 43 2a                         #             cmph    %r1, 10             ; compare state to 10
0x84a4: 89 9c                         #             ja      fpsm_eol            ; if bigger, go to the eol+accept check
0x84a6: b0 16                         #             call    fpsm_iterate_2      ; put the address of the action table in r7
0x84a8:                               # fpsm_action_table:
0x84a8: 5e 84 cc 83 f0 83 14 84 32 84 #             .word   fpsm_reject fpsm_1 fpsm_2 fpsm_3 fpsm_4
0x84b2: 42 84 66 84 c4 84 da 84 28 85 #             .word   fpsm_5 fpsm_6 fpsm_7 fpsm_8 fpsm_9
0x84bc:                               # fpsm_iterate_2:
0x84bc: 00 24                         #             addh    %r1, %r1            ; state *= sizeof(word)
0x84be: 10 3c                         #             addx    %r1, %r7            ; r1 = pointer to pointer switch case
0x84c0: 1a 24                         #             ldx     %r1, %r1            ; r1 = pointer to switch case
0x84c2: af 2e                         #             jmp     %r1                 ; follow the yellow brick road
0x84c4:                               # fpsm_7:
0x84c4: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x84c8: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x84ca: 91 94                         #             jne     fpsm_reject         ; if not register, this state rejects
0x84cc: b1 66                         #             call    read_any_register   ; r0 = read_any_register()
0x84ce: 09 40                         #             movh    %r2, %r0            ; regL = read_any_register()
0x84d0: 43 48                         #             cmph    %r2, 8              ; regL <? 8
0x84d2: 59 28                         #             mov     %r1, 8              ; state = 8
0x84d4: 94 7c                         #             jb      fpsm_scan_comma     ; if regL < 8, scan comma
0x84d6: 59 29                         #             mov     %r1, 9              ; otherwise, state = 9
0x84d8: 9e 78                         #             jmp     fpsm_scan_comma     ; then scan comma
0x84da:                               # fpsm_8:
0x84da: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x84de: 03 a0                         #             cmph    %r5, %r0            ; cur == '%'?
0x84e0: 81 18                         #             jne     fpsm_8_imm          ; if not register, try immediate
0x84e2: b1 50                         #             call    read_any_register   ; r0 = read_any_register()
0x84e4: 09 60                         #             movh    %r3, %r0            ; regR = read_any_register()
0x84e6: 43 68                         #             cmph    %r3, 8              ; regR <? 8
0x84e8: 8b 06                         #             jge     fpsm_8_ctrl_reg     ; if regR >= 8, it's a control reg
0x84ea: 58 30                         #             mov     %r1, 16             ; state = 16
0x84ec: 9e b4                         #             jmp     fpsm_iterate        ; break
0x84ee:                               # fpsm_8_ctrl_reg:
0x84ee: 41 68                         #             subh    %r3, 8              ; imm = regR - 8
0x84f0: 50 c2                         #             addx    %sp, 2              ; pop opc nonrestoring
0x84f2: 5d ce                         #             pushx   14                  ; overwrite opc with 14
0x84f4: 58 31                         #             mov     %r1, 17             ; state = 17
0x84f6: 9e aa                         #             jmp     fpsm_iterate        ; break
0x84f8:                               # fpsm_8_imm:
0x84f8: b3 84                         #             call    cur_is_imm_start    ; r0 = is_imm_start(cur)
0x84fa: 47 1f                         #             testh   %r0, -1             ; test is_imm_start(cur)
0x84fc: 80 1e                         #             jz      fpsm_8_label        ; if not an imm, try label
0x84fe: b0 d2                         #             call    read_immediate      ; r0 = read_immediate()
0x8500: b3 3c                         #             call    validate_s5         ; set 'b' if r0 is a valid s5
0x8502: 58 31                         #             mov     %r1, 17             ; state = 17
0x8504: 29 60                         #             movd    %r3, %r0            ; imm = read_immediate()
0x8506: 94 9a                         #             jb      fpsm_iterate        ; break, if imm is a valid s5
0x8508: 19 0c                         #             movsx   %r0, %r3            ; r0 = sign_extend(imm, 16)
0x850a: 23 0c                         #             cmpd    %r0, %r3            ; imm == sign_extend(imm, 16)?
0x850c: 80 08                         #             je      fpsm_8_vld_i16      ; if yes, it's valid
0x850e: 18 0c                         #             movzx   %r0, %r3            ; otherwise try r0 = zero_extend(imm,16)
0x8510: 23 0c                         #             cmpd    %r0, %r3            ; imm == zero_extend(imm, 16)?
0x8512: 91 50                         #             jne     fpsm_invalid_imm    ; if no, imm is not a valid i16. Die.
0x8514:                               # fpsm_8_vld_i16: 
0x8514: 59 80                         #             mov     %r4, 0              ; symbolptr = NULL
0x8516: 58 32                         #             mov     %r1, 18             ; state = 18
0x8518: 9e 88                         #             jmp     fpsm_iterate        ; break
0x851a:                               # fpsm_8_label:
0x851a: b3 34                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0x851c: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0x851e: 90 40                         #             jz      fpsm_reject         ; if !is_alpha(cur), finally this state rejects.
0x8520: b0 e6                         #             call    read_name           ; r0 = read_name()
0x8522: 19 80                         #             movx    %r4, %r0            ; symbolptr = read_name()
0x8524: 58 32                         #             mov     %r1, 18             ; state = 18
0x8526: 9e 7a                         #             jmp     fpsm_iterate        ; break
0x8528:                               # fpsm_9:
0x8528: 58 01 5c 05                   #             mov     %r0, 37             ; r0 = '%' to check for register
0x852c: 03 a0                         #             cmph    %r5, %r0            ; r0 == '%'?
0x852e: 91 30                         #             jne     fpsm_reject         ; if not a register, this state rejects
0x8530: 09 68                         #             movh    %r3, %r2            ; imm = regL
0x8532: 41 68                         #             subh    %r3, 8              ; imm -= 8
0x8534: b1 c4                         #             call    read_register       ; r0 = read_register()
0x8536: 09 40                         #             movh    %r2, %r0            ; r2 = read_register()
0x8538: 50 c2                         #             addx    %sp, 2              ; pop opc nonrestoring
0x853a: 5d cf                         #             pushx   15                  ; overwrite opc with 15
0x853c: 58 31                         #             mov     %r1, 17             ; state = 17
0x853e: 9e 62                         #             jmp     fpsm_iterate
0x8540:                               # fpsm_eol:
0x8540: b3 6e                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0x8542: 47 1f                         #             testh   %r0, -1             ; test is_eol(cur)
0x8544: 90 1a                         #             jz      fpsm_reject         ; if it's not eol (somehow?) reject!
0x8546:                               # fpsm_accept:
0x8546: 50 c4                         #             addx    %sp, 4              ; point at stack slot of &static_data
0x8548: 1a f8                         #             ldx     %r7, %sp            ; r7 = &static_data
0x854a: 51 c4                         #             subx    %sp, 4              ; restore %sp
0x854c: 50 e6                         #             addx    %r7, EOL_CHAR_OFS   ; r7 = &static_data.eol_char
0x854e: 0b bc                         #             sth     %r5, %r7            ; static_data->eol_char = cur
0x8550: 09 a4                         #             movh    %r5, %r1            ; r5 = state, temporarily
0x8552: 09 08                         #             movh    %r0, %r2            ; arg 0 = regL
0x8554: 19 2c                         #             movx    %r1, %r3            ; arg 1 = regR/imm
0x8556: 1c 58                         #             popx    %r2                 ; arg 2 = opcode
0x8558: 1c 78                         #             popx    %r3                 ; arg 3 = size_bits
0x855a: b0 12                         #             call    fpsm_accept_exit    ; get the address of the table into r7
0x855c:                               # fpsm_accept_jump_table:
0x855c: 60 82 0a 83 18 83 76 82 88 83 d2 82 ec 82 1c 83#             .word   fp_0 fp_R fp_I fp_RJ fp_LJ fp_RR fp_RI fp_LM
0x856c:                               # fpsm_accept_exit:
0x856c: 41 ab                         #             subh    %r5, 11             ; offset = state - 11
0x856e: 00 b4                         #             addh    %r5, %r5            ; offset *= sizeof(word)
0x8570: 10 f4                         #             addx    %r7, %r5            ; r7 = pointer to address to jump to
0x8572: 1a fc                         #             ldx     %r7, %r7            ; r7 = address to jump to
0x8574: 1c b8                         #             popx    %r5                 ; r5 = &static_data. Hooray!
0x8576: af ee                         #             jmp     %r7                 ; tail-call the assembling function
0x8578:                               # skip_whitespace:
0x8578: 58 01 5c 00                   #             mov     %r0, 32             ; r0 = ' ' for comparison
0x857c: 8e 04                         #             jmp     skip_whitespace_L2
0x857e:                               # skip_whitespace_L1:
0x857e: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x8580:                               # skip_whitespace_L2:
0x8580: 03 a0                         #             cmph    %r5, %r0            ; r5 ==? 32
0x8582: 90 fc                         #             je      skip_whitespace_L1
0x8584: 43 a9                         #             cmph    %r5, 9              ; r5 ==? '\t'
0x8586: 90 f8                         #             je      skip_whitespace_L1
0x8588: 58 01 5c 1b                   #             mov     %r0, 59             ; r0 = ';'
0x858c: 03 a0                         #             cmph    %r5, %r0
0x858e: af e1                         #             retne                       ; return if cur != ';'
0x8590: 1d dc                         #             pushx   %ln
0x8592:                               # skip_whitespace_L3:
0x8592: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x8594: b3 1a                         #             call    cur_is_eol          ; r0 = is_eol(cur)
0x8596: 47 1f                         #             testh   %r0, -1             ; test is_eol(cur)
0x8598: 90 fa                         #             jz      skip_whitespace_L3  ; loop as long as is_eol(cur) is false
0x859a: 1c f8                         #             popx    %ln
0x859c: af ee                         #             ret
0x859e:                               # read_size:
0x859e: 1d dc                         #             pushx   %ln
0x85a0: b2 ae                         #             call    cur_is_alpha        ; r0 = is_alpha(cur)
0x85a2: 47 1f                         #             testh   %r0, -1             ; test is_alpha(cur)
0x85a4: 59 01                         #             mov     %r0, 1              ; set return value for if !is_alpha(cur)
0x85a6: 80 22                         #             jz      read_size_ret
0x85a8: 58 23 5c 38                   #             mov     %r1, 120            ; r1 = 'x'
0x85ac: 01 a4                         #             subh    %r5, %r1            ; cur = cur - 'x'
0x85ae: 80 0e                         #             je      read_size_guard
0x85b0: 41 b0                         #             subh    %r5, -16            ; cur = cur + ('x' - 'h')
0x85b2: 59 00                         #             mov     %r0, 0              ; set return value for cur == 'h'
0x85b4: 80 08                         #             je      read_size_guard
0x85b6: 40 a4                         #             addh    %r5, 4              ; cur = cur + ('h' - 'd')
0x85b8: 59 02                         #             mov     %r0, 2              ; set return value for cur == 'd'
0x85ba: 81 12                         #             jne     read_size_kill      ; not valid suffix if cur != 'd' at this point
0x85bc:                               # read_size_guard:
0x85bc: 1d c0                         #             pushx   %r0                 ; spill return value
0x85be: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x85c0: b2 d8                         #             call    cur_is_alphanum     ; r0 = is_alphanum(cur)
0x85c2: 47 1f                         #             testh   %r0, -1             ; test is_alphanum(cur)
0x85c4: 81 08                         #             jnz     read_size_kill      ; crash if cur is alphanumeric
0x85c6: 1c 18                         #             popx    %r0                 ; reload return value
0x85c8:                               # read_size_ret:
0x85c8: 1c f8                         #             popx    %ln
0x85ca: af ee                         #             ret
0x85cc:                               # read_size_kill:
0x85cc: 59 00                         #             mov     %r0, 0              ; r0 = INVALID_SYNTAX_CODE
0x85ce: b3 04                         #             call    die
0x85d0:                               # read_immediate:
0x85d0: 1d c8                         #             pushx   %r2                 ; wind
0x85d2: 58 01 5c 0d                   #             mov     %r0, 45             ; '-', this mov is 2 instructions
0x85d6: 58 21 5c 30                   #             mov     %r1, 48             ; '0', this mov is also 2 instructions
0x85da: 02 14                         #             rsubh   %r0, %r5            ; r0 = r5 - 45
0x85dc: 1d c0                         #             pushx   %r0                 ; save the result of this subtraction
0x85de: 80 12                         #             je      read_immediate_L2   ; read extra char if '-'; r0 = imm = 0 since 'e'
0x85e0: 59 00                         #             mov     %r0, 0              ; r0 = imm = 0
0x85e2: 8e 10                         #             jmp     read_immediate_L3   ; jump to loop add step
0x85e4:                               # read_immediate_L1:
0x85e4: 20 00                         #             addd    %r0, %r0            ; imm *= 2
0x85e6: 29 40                         #             movd    %r2, %r0            ; immx2 = imm
0x85e8: 20 00                         #             addd    %r0, %r0            ; imm *= 2 (x4 cumulative)
0x85ea: 20 00                         #             addd    %r0, %r0            ; imm *= 2 (x8 cumulative)
0x85ec: 20 08                         #             addd    %r0, %r2            ; imm = imm + immx2 (x10 cumulative)
0x85ee: 20 14                         #             addd    %r0, %r5            ; imm = imm + cur - 48
0x85f0:                               # read_immediate_L2:
0x85f0: 4a a1                         #             ldh     %r5, STREAM         ; r5 = getchar()
0x85f2:                               # read_immediate_L3:
0x85f2: 01 a4                         #             subh    %r5, %r1            ; r5 = cur - 48
0x85f4: 43 aa                         #             cmph    %r5, 10             ; compare (cur - 48) to 10
0x85f6: 94 ee                         #             jb      read_immediate_L1   ; loop if 0 <= (cur - 48) < 10
0x85f8: 00 a4                         #             addh    %r5, %r1            ; r5 = cur (previously, r5 = cur-48)
0x85fa: 1c 38                         #             popx    %r1                 ; retrieve the comparison of initial cur to '-'
0x85fc: 1c 58                         #             popx    %r2                 ; unwind stack
0x85fe: 47 3f                         #             testh   %r1, -1             ; test the result of that comparison, zero means equal
0x8600: af e1                         #             retnz                       ; if it wasn't equal, we're done
0x8602: 62 00                         #             rsubd   %r0, 0              ; otherwise, imm = -imm
0x8604: af ee                         #             ret                         ; and now we're done.
0x8606:                               # read_name:
0x8606: 1d dc                         #             pushx   %ln
0x8608: 1d c8                         #             pushx   %r2
0x860a: 58 01 5c 00                   #             mov     %r0, 32             ; r0 = buffer
0x860e: 59 40                         #             mov     %r2, 0              ; i = 0
0x8610:                               # read_name_L1:
0x8610: 0b a0                         #             sth     %r5, %r0            ; *buffer = cur
0x8612: 50 01                         #             addx    %r0, 1              ; ++buffer
0x8614: 40 41                         #             addh    %r2, 1              ; ++i
0x8616: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x8618: 43 4f                         #             cmph    %r2, 15             ; i <=? 15
0x861a: 89 10                         #             ja      read_name_L3        ; return if i > 15
0x861c: 1d c0                         #             pushx   %r0                 ; spill buffer
0x861e: b2 7a                         #             call    cur_is_name_char    ; r0 = is cur a valid name char?
0x8620: 57 01                         #             test    %r0, 1
0x8622: 1c 18                         #             popx    %r0                 ; unspill buffer
0x8624: 91 ec                         #             jnz     read_name_L1        ; if it's valid, loop
0x8626:                               # read_name_L2:                           ; if we reach this label, i < 16
0x8626: 59 20                         #             mov     %r1, 0
0x8628: 0b 20                         #             sth     %r1, %r0            ; *buffer = 0
0x862a:                               # read_name_L3:
0x862a: 11 08                         #             subx    %r0, %r2            ; buffer = buffer - i === 32
0x862c: 1c 58                         #             popx    %r2
0x862e: 1c f8                         #             popx    %ln
0x8630: af ee                         #             ret
0x8632:                               # read_any_register:
0x8632: 1d dc                         #             pushx   %ln
0x8634: b0 74                         #             call    read_any_register_actual ; put &register_table in %ln
0x8636:                               # register_table:
0x8636: 61 30                         #             .ascii  "a0"
0x8638: 00 00 34 8a                   #             .word   0 empty_str
0x863c: 61 31                         #             .ascii  "a1"
0x863e: 01 00 34 8a                   #             .word   1 empty_str
0x8642: 61 32                         #             .ascii  "a2"
0x8644: 02 00 34 8a                   #             .word   2 empty_str
0x8648: 73 30                         #             .ascii  "s0"
0x864a: 03 00 34 8a                   #             .word   3 empty_str
0x864e: 73 31                         #             .ascii  "s1"
0x8650: 04 00 34 8a                   #             .word   4 empty_str
0x8654: 62 70                         #             .ascii  "bp"
0x8656: 05 00 34 8a                   #             .word   5 empty_str
0x865a: 73 70                         #             .ascii  "sp"
0x865c: 06 00 34 8a                   #             .word   6 empty_str
0x8660: 6c 6e                         #             .ascii  "ln"
0x8662: 07 00 34 8a                   #             .word   7 empty_str
0x8666: 72 30                         #             .ascii  "r0"
0x8668: 00 00 34 8a                   #             .word   0 empty_str
0x866c: 72 31                         #             .ascii  "r1"
0x866e: 01 00 34 8a                   #             .word   1 empty_str
0x8672: 72 32                         #             .ascii  "r2"
0x8674: 02 00 34 8a                   #             .word   2 empty_str
0x8678: 72 33                         #             .ascii  "r3"
0x867a: 03 00 34 8a                   #             .word   3 empty_str
0x867e: 72 34                         #             .ascii  "r4"
0x8680: 04 00 34 8a                   #             .word   4 empty_str
0x8684: 72 35                         #             .ascii  "r5"
0x8686: 05 00 34 8a                   #             .word   5 empty_str
0x868a: 72 36                         #             .ascii  "r6"
0x868c: 06 00 34 8a                   #             .word   6 empty_str
0x8690: 72 37                         #             .ascii  "r7"
0x8692: 07 00 34 8a                   #             .word   7 empty_str
0x8696: 63 31                         #             .ascii  "c1"
0x8698: 08 00 a4 8a                   #             .word   8 id_str
0x869c: 63 32                         #             .ascii  "c2"
0x869e: 09 00 a4 8a                   #             .word   9 id_str
0x86a2: 66 65                         #             .ascii  "fe"
0x86a4: 0a 00 a7 8a                   #             .word   10 at_str
0x86a8:                               # read_any_register_actual:
0x86a8: 1d c8                         #             pushx   %r2
0x86aa: 1d cc                         #             pushx   %r3
0x86ac: 1d d0                         #             pushx   %r4                 ; wind the stack (%ln already pushed)
0x86ae: 58 61 5c 60                   #             mov     %r3, 32             ; r3 = buffer
0x86b2: 4a 01                         #             ldh     %r0, STREAM
0x86b4: 0b 0c                         #             sth     %r0, %r3            ; *buffer = getchar()
0x86b6: 50 61                         #             addx    %r3, 1
0x86b8: 4a 01                         #             ldh     %r0, STREAM
0x86ba: 0b 0c                         #             sth     %r0, %r3            ; *(buffer + 1) = getchar()
0x86bc: 51 61                         #             subx    %r3, 1              ; r3 = buffer, once again
0x86be: 58 b2                         #             movz    %r5, 18             ; i = 18
0x86c0: 19 9c                         #             movx    %r4, %r7            ; r7 previously held &register_table
0x86c2:                               # read_any_register_L1:
0x86c2: 19 0c                         #             movx    %r0, %r3            ; arg0 = buffer
0x86c4: 19 30                         #             movx    %r1, %r4            ; arg1 = register_table[18-i].name
0x86c6: 59 42                         #             movx    %r2, 2              ; arg2 = 2
0x86c8: ba 32                         #             call    strncmp             ; r0 = 0 iff string at buffer == string at name
0x86ca: 47 1f                         #             testh   %r0, -1             ; is r0 == 0?
0x86cc: 80 0c                         #             jz      read_any_register_L3; found match! break out of loop
0x86ce: 50 86                         #             addx    %r4, 6              ; point r4 at next register table entry
0x86d0: 41 a1                         #             subh    %r5, 1              ; --i
0x86d2: 9b f0                         #             jge     read_any_register_L1; loop as long as i is still >= 0
0x86d4:                               # read_any_register_L2:                   ; but if i < 0, there were no matches. Die.
0x86d4: 59 01                         #             mov     %r0, 1              ; r0 = INVALID_REGISTER_CODE
0x86d6: b1 fc                         #             call    die
0x86d8:                               # read_any_register_L3:
0x86d8: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar() [in the C code, this is above the loop]
0x86da: 50 84                         #             addx    %r4, 4              ; point r4 at entry.remainder_to_consume
0x86dc: 1a 30                         #             ldx     %r1, %r4            ; r1 = entry->remainder_to_consume
0x86de: b0 3a                         #             call    consume             ; r0 = 0 iff consume succeeds
0x86e0: 47 1f                         #             testh   %r0, -1             ; is r0 == 0?
0x86e2: 91 f2                         #             jnz     read_any_register_L2; call die(INVALID_REGISTER) if consume failed
0x86e4: b1 b4                         #             call    cur_is_alphanum     ; r0 = is_alphanum(cur)
0x86e6: 47 1f                         #             testh   %r0, -1             ; is r0 != 0?
0x86e8: 91 ec                         #             jnz     read_any_register_L2; call die(INVALID_REGISTER) if is_alphanum(cur)
0x86ea: 51 82                         #             subx    %r4, 2              ; point r4 at entry.number
0x86ec: 1a 10                         #             ldx     %r0, %r4            ; return = entry->number
0x86ee: 1c 98                         #             popx    %r4
0x86f0: 1c 78                         #             popx    %r3
0x86f2: 1c 58                         #             popx    %r2                 ; unwind
0x86f4: 1c f8                         #             popx    %ln                 ; restore return address
0x86f6: af ee                         #             ret
0x86f8:                               # read_register:
0x86f8: 1d dc                         #             pushx   %ln
0x86fa: bf 38                         #             call    read_any_register
0x86fc: 1c f8                         #             popx    %ln
0x86fe: 43 08                         #             cmph    %r0, 8
0x8700: af ea                         #             retl                        ; return reg if it's < 8
0x8702: 9e d2                         #             jmp     read_any_register_L2; otherwise, call die(INVALID_REGISTER)
0x8704:                               # read_ctrl_register:
0x8704: 1d dc                         #             pushx   %ln
0x8706: bf 2c                         #             call    read_any_register
0x8708: 1c f8                         #             popx    %ln
0x870a: 43 08                         #             cmph    %r0, 8
0x870c: af eb                         #             retge                       ; return reg if it's >= 8
0x870e: 9e c6                         #             jmp     read_any_register_L2; otherwise, call die as above
0x8710:                               # consume_L1:
0x8710: 02 14                         #             rsubh   %r0, %r5            ; r0 = *check - cur
0x8712: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x8714: af e1                         #             retnz                       ; if match failed, return result
0x8716: 50 21                         #             addx    %r1, 1              ; ++check
0x8718:                               # consume:
0x8718: 0a 04                         #             ldh     %r0, %r1            ; r0 = *check
0x871a: 47 1f                         #             testh   %r0, -1             ; *check == 0?
0x871c: 91 f4                         #             jnz     consume_L1          ; loop if *check != 0
0x871e: af ee                         #             ret                         ; otherwise, return *check === 0
0x8720:                               # match:
0x8720: 02 14                         #     rsubh   %r0, %r5                    ; r0 = cur - c
0x8722: 4a a1                         #     ldh     %r5, STREAM                 ; cur = getchar()
0x8724: af ee                         #     ret
0x8726:                               # read_opcode:
0x8726: 1d dc                         #             pushx   %ln
0x8728: 1d c8                         #             pushx   %r2
0x872a: 1d cc                         #             pushx   %r3
0x872c: 1d d0                         #             pushx   %r4
0x872e: 59 00                         #             mov     %r0, 0              ; r.opcode = 0
0x8730: 59 23                         #             mov     %r1, 3              ; r.state = STATE_TX
0x8732: 58 41 5c 40                   #             mov     %r2, 32             ; r2 = buffer
0x8736: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0x8738: 09 74                         #             movh    %r3, %r5            ; temporarily stash cur in r3
0x873a: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x873c: 50 41                         #             addx    %r2, 1              ; ++buffer
0x873e: 0b a8                         #             sth     %r5, %r2            ; *buffer = cur
0x8740: 58 83 5c 8a                   #             mov     %r4, 106            ; r4 = 'j' === 106
0x8744: 03 70                         #             cmph    %r3, %r4            ; check if original cur was 'j'
0x8746: 59 80                         #             mov     %r4, 0              ; trigger = HIT_J === 0
0x8748: 80 96                         #             je      read_opcode_cond    ; jump to the cond part if so
0x874a: 59 62                         #             mov     %r3, 2              ; size = 2
0x874c: 59 82                         #             mov     %r4, 2              ; count = 2
0x874e: 59 bf 5c a2 5c b5 5c ab       #             mov     %r5, opcode_tables  ; r5 = pointer to opcode tables
0x8756:                               # read_opcode_sloop:
0x8756: 58 01 5c 00                   #             mov     %r0, 32             ; arg 0 = buffer
0x875a: 19 34                         #             mov     %r1, %r5            ; arg 1 = &table{2/3}[ix].name
0x875c: 19 4c                         #             mov     %r2, %r3            ; arg 2 = size
0x875e: b9 9c                         #             call    strncmp             ; r0 = (0 iff hit table)
0x8760: 47 1f                         #             testh   %r0, -1             ; test for hit
0x8762: 81 0c                         #             jnz     read_opcode_sstep   ; if not a hit, go to next step
0x8764: 51 a1                         #             subx    %r5, 1              ; r5 = &table{2/3}[ix].opcode
0x8766: 0a 14                         #             ldh     %r0, %r5            ; r.opcode = table{2/3}[ix].opcode
0x8768: 59 25                         #             mov     %r1, 5              ; r.state = STATE_COMP
0x876a: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x876c: 8e c6                         #             jmp     read_opcode_unwind  ; return
0x876e:                               # read_opcode_sstep:
0x876e: 10 ac                         #             addx    %r5, %r3            ; tableptr += size
0x8770: 50 a1                         #             addx    %r5, 1              ; tableptr += 1 [shift past next opcode]
0x8772: 41 81                         #             subh    %r4, 1              ; --count
0x8774: 9b e2                         #             jge     read_opcode_sloop   ; loop if count still >= 0
0x8776: 43 62                         #             cmph    %r3, 2              ; check if size was 2 on that iteration
0x8778: 59 84                         #             mov     %r4, 4              ; count = 4, size is "still" 3 (it's from the future)
0x877a: 81 30                         #             jne     read_opcode_big     ; if not, stop the short loop
0x877c: 59 63                         #             mov     %r3, 3              ; size = 3
0x877e: 59 85                         #             mov     %r4, 5              ; count = 5
0x8780: 58 01 5c 02                   #             mov     %r0, 34             ; r0 = buffer + 2
0x8784: 4a 41                         #             ldh     %r2, STREAM         ; r2 = getchar()
0x8786: 0b 40                         #             sth     %r2, %r0            ; *(buffer + 2) = r2
0x8788: 9e ce                         #             jmp     read_opcode_sloop   ; continue checking short opcodes
0x878a:                               # read_opcode_bstep:
0x878a: 10 ac                         #             addx    %r5, %r3            ; tableptr += size
0x878c: 50 a3                         #             addx    %r5, 3              ; tableptr += 3 [shift past opcode,state,trigger]
0x878e: 41 81                         #             subh    %r4, 1              ; --count
0x8790: 8b 20                         #             jge     read_opcode_bloop   ; loop now, if count still >= 0
0x8792: 1c 58                         #             popx    %r2                 ; reload spilled cur into %r2
0x8794: 43 63                         #             cmph    %r3, 3              ; was size still 3 on that iteration?
0x8796: 81 8e                         #             jne     read_opcode_die     ; if not, we're out of things to check. Die.
0x8798:                               # read_opcode_try4:
0x8798: 58 01 5c 03                   #             mov     %r0, 35             ; r0 = buffer + 3
0x879c: 0b 40                         #             sth     %r2, %r0            ; *(buffer + 3) = cur
0x879e: 59 64                         #             mov     %r3, 4              ; size = 4
0x87a0: 59 85                         #             mov     %r4, 5              ; count = 5
0x87a2: 59 bf 5c a2 5c b7 5c aa       #             mov     %r5, opcode_table4_state
0x87aa:                               # read_opcode_big:                        ; before jumping here, count was set to {4/5}
0x87aa: 4a 41                         #             ldh     %r2, STREAM         ; get another character...
0x87ac: 1d c8                         #             pushx   %r2                 ; and spill it, because we still need the table
0x87ae: 50 a2                         #             addx    %r5, 2              ; was pointed at state, move it to name
0x87b0:                               # read_opcode_bloop:
0x87b0: 58 01 5c 00                   #             mov     %r0, 32             ; arg 0 = buffer
0x87b4: 19 34                         #             mov     %r1, %r5            ; arg 1 = &table{3/4}[ix].name
0x87b6: 19 4c                         #             mov     %r2, %r3            ; arg 2 = size
0x87b8: b9 42                         #             call    strncmp             ; r0 = (0 iff hit table)
0x87ba: 47 1f                         #             testh   %r0, -1             ; test for hit
0x87bc: 91 ce                         #             jnz     read_opcode_bstep   ; if no hit, go to next iteration
0x87be: 1c 58                         #             popx    %r2                 ; retrieve cur, which we spilled
0x87c0: 51 a1                         #             subx    %r5, 1              ; move pointer to trigger
0x87c2: 0a 94                         #             ldh     %r4, %r5            ; trigger = table[ix].trigger
0x87c4: 43 82                         #             cmph    %r4, 2              ; trigger == HIT_MOV?
0x87c6: 81 0a                         #             jne     read_opcode_chkcond ; if it's not, try checking if it's HIT_COND
0x87c8: 09 08                         #             movh    %r0, %r2            ; but if it is, check cur (which we reloaded to r2)
0x87ca: b0 f2                         #             call    is_not_opcode_suffix
0x87cc: 47 1f                         #             testh   %r0, -1             ; test !is_opcode_suffix(cur)
0x87ce: 91 ca                         #             jnz     read_opcode_try4    ; if holds, skip to trying length-4 names
0x87d0:                               # read_opcode_chkcond:
0x87d0: 51 a2                         #             subx    %r5, 2              ; move pointer from trigger to opcode
0x87d2: 0a 14                         #             ldh     %r0, %r5            ; r.opcode = table[ix].opcode
0x87d4: 50 a1                         #             addx    %r5, 1              ; move pointer from opcode to state
0x87d6: 0a 34                         #             ldh     %r1, %r5            ; r.state  = table[ix].state
0x87d8: 09 a8                         #             movh    %r5, %r2            ; restore cur to r5 from r2 (where it was reloaded)
0x87da: 43 81                         #             cmph    %r4, 1              ; trigger == HIT_COND?
0x87dc: 81 56                         #             jne     read_opcode_unwind  ; if no, go to stack unwind and return
0x87de:                               # read_opcode_cond:
0x87de: 1d c4                         #             pushx   %r1                 ; spill r.state
0x87e0: 1d c0                         #             pushx   %r0                 ; spill r.opcode
0x87e2: 59 42                         #             mov     %r2, 2              ; i = 2
0x87e4: 58 61 5c 60                   #             mov     %r3, 32             ; r3 = buffer
0x87e8:                               # read_opcode_bfrcond:
0x87e8: b0 d2                         #             call    cur_is_not_opcode_suffix
0x87ea: 47 1f                         #             testh   %r0, -1             ; test !is_opcode_suffix(cur)
0x87ec: 80 0c                         #             jz      read_opcode_condtbl ; if it doesn't hold (cur is an opcode suffix)
0x87ee: 0b ac                         #             sth     %r5, %r3            ; *buffer = cur
0x87f0: 4a a1                         #             ldh     %r5, STREAM         ; cur = getchar()
0x87f2: 50 61                         #             addx    %r3, 1              ; ++buffer
0x87f4: 41 41                         #             subh    %r2, 1              ; --i
0x87f6: 9d f2                         #             jg      read_opcode_bfrcond ; continue buffering if i > 0
0x87f8:                               # read_opcode_condtbl:
0x87f8: 59 40                         #             mov     %r2, 0              ; clear r2
0x87fa: 0b 4c                         #             sth     %r2, %r3            ; *buffer = 0
0x87fc: 59 7f 5c 62 5c 78 5c 74       #             mov     %r3, cond_table_name ; get pointer to cond_table[0].name in r3
0x8804: 19 50                         #             mov     %r2, %r4            ; r2 = trigger
0x8806: 00 48                         #             addh    %r2, %r2            ; r2 = trigger * 2
0x8808: 00 48                         #             addh    %r2, %r2            ; r2 = trigger * 4
0x880a: 10 68                         #             addx    %r3, %r2            ; r3 = cond_table[trigger].name
0x880c: 58 54                         #             movz    %r2, 20
0x880e: 02 88                         #             rsubh   %r4, %r2            ; trigger = 20 - trigger
0x8810:                               # read_opcode_cndloop:
0x8810: 58 01 5c 00                   #             mov     %r0, 32             ; arg 0 = buffer
0x8814: 19 2c                         #             movx    %r1, %r3            ; arg 1 = cond_table[ix].name
0x8816: 59 43                         #             mov     %r2, 3              ; arg 2 = 3
0x8818: b8 e2                         #             call    strncmp             ; r0 = (0 iff hit table)
0x881a: 47 1f                         #             testh   %r0, -1             ; test if hit
0x881c: 80 0c                         #             jz      read_opcode_hitcond ; if we hit, go leave (finally)
0x881e: 50 64                         #             addx    %r3, 4              ; otherwise, move to next cond table entry
0x8820: 41 81                         #             subh    %r4, 1              ; --trigger
0x8822: 9d ee                         #             jg      read_opcode_cndloop ; continue looping if trigger > 0
0x8824:                               # read_opcode_die:
0x8824: 59 00                         #             mov     %r0, 0
0x8826: b0 ac                         #             call    die                 ; otherwise, we are out of options. Die.
0x8828:                               # read_opcode_hitcond:
0x8828: 1c 18                         #             popx    %r0                 ; reload r.opcode
0x882a: 1c 38                         #             popx    %r1                 ; reload r.state
0x882c: 51 61                         #             subx    %r3, 1              ; move back from name to opcode
0x882e: 0a 6c                         #             ldh     %r3, %r3            ; read in the opcode
0x8830: 00 0c                         #             addh    %r0, %r3            ; r.opcode += cond_table[hit].opcode
0x8832:                               # read_opcode_unwind:
0x8832: 1c 98                         #             popx    %r4
0x8834: 1c 78                         #             popx    %r3
0x8836: 1c 58                         #             popx    %r2
0x8838: 1c f8                         #             popx    %ln
0x883a: af ee                         #             ret
0x883c:                               # validate_s5:
0x883c: 1d c0                         #             pushx   %r0
0x883e: 1d c4                         #             pushx   %r1
0x8840: 58 30                         #             movz    %r1, 16
0x8842: 20 04                         #             addd    %r0, %r1            ; imm + 16
0x8844: 10 24                         #             addx    %r1, %r1            ; r1 = 32
0x8846: 23 04                         #             cmpd    %r0, %r1            ; compare (imm + 16) against 32
0x8848: 1c 38                         #             popx    %r1                 ; if 0 <= (imm + 16) < 32, then imm
0x884a: 1c 18                         #             popx    %r0                 ; is a valid s5 immediate. The compare
0x884c: af ee                         #             ret                         ; will set the 'b' condition if so.
0x884e:                               # cur_is_alpha:
0x884e: 19 14                         #             mov     %r0, %r5
0x8850:                               # is_alpha:
0x8850: 58 22 5c 21                   #             mov     %r1, 65             ; r1 = 'A'
0x8854: 03 04                         #             cmph    %r0, %r1
0x8856: 84 1e                         #             jb      is_alpha_ret_false  ; return false if r0 < 'A'
0x8858: 40 2f                         #             addh    %r1, 15
0x885a: 40 2a                         #             addh    %r1, 10             ; r1 = 'Z'
0x885c: 03 04                         #             cmph    %r0, %r1            ; c <=? 'Z'
0x885e: 88 1a                         #             jbe     is_alpha_ret_true
0x8860: 40 25                         #             addh    %r1, 5              ; r1 = '_'
0x8862: 03 04                         #             cmph    %r0, %r1            ; c ==? '_'
0x8864: 80 14                         #             je      is_alpha_ret_true
0x8866: 40 22                         #             addh    %r1, 2              ; r1 = 'a'
0x8868: 03 04                         #             cmph    %r0, %r1            ; c <? 'a'
0x886a: 84 0a                         #             jb      is_alpha_ret_false
0x886c: 40 2f                         #             addh    %r1, 15
0x886e: 40 2a                         #             addh    %r1, 10             ; r1 = 'z'
0x8870: 03 04                         #             cmph    %r0, %r1            ; c <=? 'z'
0x8872: 88 06                         #             jbe     is_alpha_ret_true   ; fall through to ret_true otherwise
0x8874:                               # is_eol_ret_false:
0x8874:                               # is_num_ret_false:
0x8874:                               # is_alpha_ret_false:
0x8874: 59 00                         #             mov     %r0, 0
0x8876: af ee                         #             ret
0x8878:                               # is_eol_ret_true:
0x8878:                               # is_num_ret_true:
0x8878:                               # is_alpha_ret_true:
0x8878:                               # is_imm_start_ret_true:
0x8878: 59 01                         #             mov     %r0, 1
0x887a: af ee                         #             ret
0x887c:                               # cur_is_imm_start:
0x887c: 19 14                         #             mov     %r0, %r5
0x887e:                               # is_imm_start:
0x887e: 58 21 5c 2d                   #             mov     %r1, 45             ; '-' for comparison
0x8882: 03 04                         #             cmph    %r0, %r1            ; c ==? '-'
0x8884: 90 f4                         #             je      is_imm_start_ret_true
0x8886: 40 23                         #             addh    %r1, 3              ; r1 = '0'
0x8888: 8e 08                         #             jmp     is_num_have_48      ; this entrypoint is less common
0x888a:                               # cur_is_num:
0x888a: 19 14                         #             mov     %r0, %r5
0x888c:                               # is_num:
0x888c: 58 21 5c 30                   #             mov     %r1, 48             ; '0' prep going in
0x8890:                               # is_num_have_48:
0x8890: 01 04                         #             subh    %r0, %r1            ; c = c - '0'
0x8892: 43 0a                         #             cmph    %r0, 10             ; c <? '9'+1
0x8894: 94 e4                         #             jb      is_num_ret_true
0x8896: 9e de                         #             jmp     is_num_ret_false
0x8898:                               # cur_is_alphanum:
0x8898:                               # cur_is_name_char:
0x8898: 19 14                         #             mov     %r0, %r5
0x889a:                               # is_alphanum:
0x889a:                               # is_name_char:
0x889a: 1d dc                         #             pushx   %ln                 ; we call functions, save %ln
0x889c: 1d c0                         #             pushx   %r0                 ; save c
0x889e: bf b2                         #             call    is_alpha            ; r0 = is_alpha(c)
0x88a0: 47 01                         #             testh   %r0, 1              ; test is_alpha(c)
0x88a2: 1c 38                         #             popx    %r1                 ; r1 = c
0x88a4: 81 06                         #             jnz     is_name_char_ret    ; return if is_alpha(c)
0x88a6: 09 04                         #             movh    %r0, %r1            ; r0 = c
0x88a8: bf e4                         #             call    is_num              ; r0 = is_num(c)
0x88aa:                               # is_name_char_ret:
0x88aa: 1c f8                         #             popx    %ln
0x88ac: af ee                         #             ret
0x88ae:                               # cur_is_eol:
0x88ae: 19 14                         #             mov     %r0, %r5
0x88b0:                               # is_eol:
0x88b0: 43 0a                         #             cmph    %r0, 10             ; c ==? '\n'
0x88b2: 90 c6                         #             je      is_eol_ret_true
0x88b4: 43 00                         #             cmph    %r0, 0              ; c ==? '\0'
0x88b6: 90 c2                         #             je      is_eol_ret_true
0x88b8: 9e bc                         #             jmp     is_eol_ret_false
0x88ba:                               # cur_is_not_opcode_suffix:
0x88ba: 19 14                         #             mov     %r0, %r5
0x88bc:                               # is_not_opcode_suffix:
0x88bc: 19 20                         #             mov     %r1, %r0            ; swap registers
0x88be: 58 03 5c 18                   #             mov     %r0, 120            ; r0 = 'x' = 120
0x88c2: 02 04                         #             rsubh   %r0, %r1            ; r0 = c - 'x'
0x88c4: af e0                         #             retz                        ; if 0, c == 'x' which is valid, return 0
0x88c6: 41 10                         #             subh    %r0, -16            ; r0 = (c - 'x') - ('h' - 'x') === c - 'h'
0x88c8: af e0                         #             retz                        ; same, but == 'h'
0x88ca: 40 04                         #             addh    %r0, 4              ; r0 = (c - 'h') + ('h' - 'd') === c - 'd'
0x88cc: af e0                         #             retz                        ; same, but == 'd'
0x88ce: 19 04                         #             mov     %r0, %r1            ; r0 = c
0x88d0: 9e 80                         #             jmp     is_alpha            ; tail-call is_alpha. Our return sense is inverted,
0x88d2:                               # die:
0x88d2: b0 1a                         #             call    die_actual          ; %r7 = &msg_header
0x88d4:                               # msg_header:                             ; char **msg_header
0x88d4: 2c 8a                         #             .word   invalid_msg
0x88d6: 2c 8a                         #             .word   invalid_msg
0x88d8: 2c 8a                         #             .word   invalid_msg
0x88da: 35 8a                         #             .word   out_of_msg
0x88dc: 35 8a                         #             .word   out_of_msg
0x88de: 34 8a                         #             .word   empty_msg
0x88e0:                               # msg_body:                               ; char **msg_body
0x88e0: 3d 8a                         #             .word   syntax_msg
0x88e2: 44 8a                         #             .word   register_msg
0x88e4: 4d 8a                         #             .word   immediate_msg
0x88e6: 57 8a                         #             .word   range_msg
0x88e8: 5d 8a                         #             .word   memory_msg
0x88ea: 64 8a                         #             .word   unknown_symbol_msg
0x88ec:                               # die_actual:
0x88ec: 19 44                         #             movx    %r2, %r1            ; save name in r2 which is stable (r1 is not)
0x88ee: 19 bc                         #             movx    %r5, %r7            ; save &msg_header
0x88f0: 00 00                         #             addh    %r0, %r0            ; ofs = code << 1
0x88f2: 10 1c                         #             addx    %r0, %r7            ; r0 = &(msg_header[code])
0x88f4: 19 60                         #             movx    %r3, %r0            ; save &(msg_header[code]) for later
0x88f6: 1a 00                         #             ldx     %r0, %r0            ; r0 = msg_header[code]
0x88f8: b0 ac                         #             call    puts                ; puts(msg_header[code])
0x88fa: 19 0c                         #             movx    %r0, %r3            ; retrieve &msg_header[code]
0x88fc: 50 0c                         #             addx    %r0, 12             ; r0 = &msg_body[code]
0x88fe: 1a 00                         #             ldx     %r0, %r0            ; r0 = msg_body[code]
0x8900: b0 a4                         #             call    puts                ; puts(msg_body[code])   additionally r1 = 0
0x8902: 11 74                         #             subx    %r3, %r5            ; r3 = &msg_header[code] - msg_header, eqv. 2*code
0x8904: 53 6a                         #             cmpx    %r3, 10             ; compare 2*code against 10
0x8906: 81 0c                         #             jne     die_line            ; if 2*code != 10, we're done and can print line and halt
0x8908: 19 08                         #             movx    %r0, %r2            ; move name to argument 0 (it was saved in r2 and is untouched)
0x890a: 58 50                         #             movz    %r2, 16             ; r2 = 16
0x890c: 10 40                         #             addx    %r2, %r0            ; r2 = &(name + 16)
0x890e: 0b 28                         #             sth     %r1, %r2            ; *(name + 16) = 0,  r1 is still 0 since call to puts
0x8910: b0 94                         #             call    puts                ; puts(name)
0x8912:                               # die_line:
0x8912: b0 0c                         #             call    die_line_with_msg
0x8914: 20 61 74 20 6c 69 6e 65 20 00 #             .asciiz " at line "
0x891e:                               # die_line_with_msg:
0x891e: 19 1c                         #             mov     %r0, %ln
0x8920: b0 84                         #             call    puts                ; print " at line "
0x8922: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buf
0x8926: 59 50 5c 40 5c 4a             #             mov     %r2, 0xC00A         ; &static_data.src_lineno
0x892c: 1a 48                         #             ldx     %r2, %r2            ; arg 2 = static_data->src_lineno
0x892e: b0 38                         #             call    utoa                ; convert lineno to string in buffer
0x8930: 58 01 5c 00                   #             mov     %r0, BUFFER_PTR     ; arg 0 = buf, again
0x8934: b0 70                         #             call    puts                ; print the line number
0x8936: 8e 00                         #             hlt                         ; crash the kernel.
0x8938:                               # udiv16:
0x8938: 1d cc                         #             pushx   %r3                 ; save r3
0x893a: 59 20                         #             mov     %r1, 0              ; initial partial remainder is 0
0x893c: 58 70                         #             mov     %r3, 16             ; number of iterations to perform
0x893e:                               # udiv16_loop:
0x893e: 10 24                         #             addx    %r1, %r1            ; shift the partial remainder one bit left
0x8940: 10 00                         #             addx    %r0, %r0            ; shift dividend left one bit thru carry
0x8942: 85 04                         #             jnc     udiv16_no_qbit      ; if no carry, skip moving bit into partial rem
0x8944: 54 21                         #             orx     %r1, 1              ; move carry into bottom bit of shifted partial rem
0x8946:                               # udiv16_no_qbit:
0x8946: 11 28                         #             sub     %r1, %r2            ; attempt subtraction from partial remainder
0x8948: 85 06                         #             jnc     udiv16_no_borrow    ; if that subtraction succeeded, set bit of quotient
0x894a: 10 28                         #             add     %r1, %r2            ; otherwise, restore partial remainder
0x894c: 8e 04                         #             jmp     udiv16_step         ; and skip setting quotient bit
0x894e:                               # udiv16_no_borrow:
0x894e: 54 01                         #             orx     %r0, 1              ; set bottom bit of the dividend (growing quotient)
0x8950:                               # udiv16_step:
0x8950: 41 61                         #             subh    %r3, 1              ; decrement counter
0x8952: 99 ec                         #             ja      udiv16_loop         ; continue as long as counter remains > 0
0x8954: 1c 78                         #             popx    %r3                 ; otherwise we're done. Restore r3
0x8956: af ee                         #             ret
0x8958:                               # itoa:
0x8958: 57 5f                         #             testx   %r2, -1             ; test the input number for sign
0x895a: 83 0c                         #             jnn     utoa                ; if it's already positive, go straight to utoa
0x895c: 58 21 5c 2d                   #             mov     %r1, 45             ; otherwise, prepare a minus sign '-'
0x8960: 0b 20                         #             sth     %r1, %r0            ; to put in the buffer
0x8962: 50 01                         #             addx    %r0, 1              ; buf++
0x8964: 52 40                         #             rsubx   %r2, 0              ; d = -d
0x8966:                               # utoa:
0x8966: 1d dc                         #             pushx   %ln
0x8968: 1d d0                         #             pushx   %r4                 ; wind
0x896a: 1d c0                         #             pushx   %r0                 ; save original value of buffer
0x896c: 58 81 5c 90                   #             mov     %r4, 48             ; stash '0' for quick access
0x8970: 19 60                         #             mov     %r3, %r0            ; p = buf
0x8972: 19 08                         #             mov     %r0, %r2            ; dividend = d
0x8974: 59 4a                         #             mov     %r2, 10             ; divisor = base = 10
0x8976:                               # itoa_loop:
0x8976: bf c2                         #             call    udiv16              ; r0 = quotient, r1 = remainder, r2 still 10
0x8978: 00 30                         #             addh    %r1, %r4            ; chr = remainder + '0'
0x897a: 0b 2c                         #             sth     %r1, %r3            ; *p = chr
0x897c: 50 61                         #             addx    %r3, 1              ; p++
0x897e: 57 1f                         #             testx   %r0, -1             ; test quotient for zero
0x8980: 91 f6                         #             jnz     itoa_loop           ; loop as long as quotient is not yet zero
0x8982: 0b 0c                         #             sth     %r0, %r3            ; *p = 0, terminate the string
0x8984: 51 61                         #             subx    %r3, 1              ; p2 = p - 1
0x8986: 1c 18                         #             popx    %r0                 ; p1 = buf
0x8988: 1c 98                         #             popx    %r4
0x898a: 1c f8                         #             popx    %ln                 ; fully unwind the stack to prepare for
0x898c: 8e 0e                         #             jmp     itoa_rev_check      ; enter loop at check
0x898e:                               # itoa_rev_loop:
0x898e: 0a 40                         #             ldh     %r2, %r0            ; tmp = *p1
0x8990: 0a 2c                         #             ldh     %r1, %r3            ; r1 = *p2
0x8992: 0b 20                         #             sth     %r1, %r0            ; *p1 = *p2
0x8994: 0b 4c                         #             sth     %r2, %r3            ; *p2 = tmp
0x8996: 50 01                         #             addx    %r0, 1              ; p1++
0x8998: 51 61                         #             subx    %r3, 1              ; p2--
0x899a:                               # itoa_rev_check:
0x899a: 13 0c                         #             cmpx    %r0, %r3            ; p1 <? p2
0x899c: 94 f2                         #             jb      itoa_rev_loop       ; loop if yes
0x899e: af ee                         #             ret                         ; otherwise we're done, return.
0x89a0:                               # puts_L1:
0x89a0: 4b 23                         #             sth     %r1, OUTPUT         ; putchar(*str)
0x89a2: 50 01                         #             addx    %r0, 1              ; ++str
0x89a4:                               # puts:
0x89a4: 0a 20                         #             ldh     %r1, %r0            ; r1 = *str
0x89a6: 47 3f                         #             testh   %r1, -1             ; test *str
0x89a8: 91 f8                         #             jnz     puts_L1             ; loop if *str != 0
0x89aa: af ee                         #             ret                         ; return if *str == 0
0x89ac:                               # syscall_exit:
0x89ac: 1d c4                         #             pushx   %r1                     ; save status
0x89ae: b0 1e                         #             call    syscall_exit_with_msg   ; get msg into ln
0x89b0: 50 72 6f 67 72 61 6d 20 65 78 69 74 65 64 20 77 69 74 68 20 73 74 61 74 75 73 20 00#             .asciiz "Program exited with status "
0x89cc:                               # syscall_exit_with_msg:
0x89cc: 19 1c                         #             mov     %r0, %r7            ; arg 0 = msg
0x89ce: bf d6                         #             call    puts                ; print the msg
0x89d0: 1c 58                         #             popx    %r2                 ; arg 2 = status
0x89d2: 59 10 5c 01 5c 00             #             mov     %r0, 0xC020         ; arg 0 = runtime buffer after kernel data
0x89d8: 19 80                         #             mov     %r4, %r0            ; save buffer addr
0x89da: bf 8c                         #             call    utoa                ; write str(code) into buffer
0x89dc: 19 10                         #             mov     %r0, %r4            ; arg 0 = buffer again
0x89de: bf c6                         #             call    puts                ; print the code
0x89e0: 8e 00                         #             hlt                         ; terminate
0x89e2:                               # syscall_putuint:
0x89e2:                               # syscall_putsint:
0x89e2: 1d c8                         #             pushx   %r2                 ; wind stack to save all user registers that we would clobber
0x89e4: 1d cc                         #             pushx   %r3
0x89e6: 1d d0                         #             pushx   %r4
0x89e8: 43 02                         #             cmph    %r0, 2              ; compare 2*service_no to 2. If it's 2, print unsigned.
0x89ea: 19 44                         #             movx    %r2, %r1            ; arg 2 = number
0x89ec: 59 10 5c 01 5c 00             #             mov     %r0, 0xC020         ; arg 0 = runtime buffer after kernel data
0x89f2: 19 80                         #             movx    %r4, %r0            ; and save this address
0x89f4: 81 06                         #             jne     syscall_do_signed   ; if service no is not 2, use itoa
0x89f6: bf 70                         #             call    utoa                ; otherwise use utoa
0x89f8: 8e 04                         #             jmp     syscall_have_a
0x89fa:                               # syscall_do_signed:
0x89fa: bf 5e                         #             call    itoa
0x89fc:                               # syscall_have_a:                         ; now the buffer has the rep of the number to print
0x89fc: 19 10                         #             movx    %r0, %r4            ; get its address back
0x89fe: bf a6                         #             call    puts                ; and print the number
0x8a00: 1c 98                         #             popx    %r4
0x8a02: 1c 78                         #             popx    %r3
0x8a04: 1c 58                         #             popx    %r2                 ; unwind
0x8a06: 8e 1a                         #             jmp     syscall_return
0x8a08:                               # syscall_puts:
0x8a08: 19 04                         #             movx    %r0, %r1            ; arg 0 = message
0x8a0a: bf 9a                         #             call    puts                ; print it
0x8a0c: 8e 14                         #             jmp     syscall_return
0x8a0e:                               # syscall_sbrk:
0x8a0e: 59 f0 5c e0 5c f0             #             mov     %r7, STATIC_DATA_PTR ; r7 = &static_data.break
0x8a14: 1a 1c                         #             ldx     %r0, %r7            ; r0 = static_data->break
0x8a16: 10 20                         #             addx    %r1, %r0            ; r1 = static_data->break + numbytes
0x8a18: 50 23                         #             addx    %r1, 3
0x8a1a: 56 3c                         #             andx    %r1, -4             ; dword align the new break
0x8a1c: 1b 3c                         #             stx     %r1, %r7            ; record the new break
0x8a1e: 8e 02                         #             jmp     syscall_return
0x8a20:                               # syscall_return:
0x8a20: 1c f8                         #             popx    %ln                 ; restore our return address
0x8a22: 59 d0 5c c0 5c ca             #             mov     %sp, 0xC00A         ; &static_data->user_sp
0x8a28: 1a d8                         #             ldx     %sp, %sp            ; %sp = static_data->user_sp
0x8a2a: af ee                         #             ret
0x8a2c:                               # invalid_msg:
0x8a2c: 69 6e 76 61 6c 69 64 20       #             .ascii  "invalid "
0x8a34:                               # empty_str:
0x8a34:                               # empty_msg:                  ; share the NUL-terminator to get empty string
0x8a34: 00                            #             .half   0
0x8a35:                               # out_of_msg:
0x8a35: 6f 75 74 20 6f 66 20 00       #             .asciiz "out of "
0x8a3d:                               # syntax_msg:
0x8a3d: 73 79 6e 74 61 78 00          #             .asciiz "syntax"
0x8a44:                               # register_msg:
0x8a44: 72 65 67 69 73 74 65 72 00    #             .asciiz "register"
0x8a4d:                               # immediate_msg:
0x8a4d: 69 6d 6d 65 64 69 61 74 65 00 #             .asciiz "immediate"
0x8a57:                               # range_msg:
0x8a57: 72 61 6e 67 65 00             #             .asciiz "range"
0x8a5d:                               # memory_msg:
0x8a5d: 6d 65 6d 6f 72 79 00          #             .asciiz "memory"
0x8a64:                               # unknown_symbol_msg:
0x8a64: 75 6e 6b 6e 6f 77 6e 20 73 79 6d 62 6f 6c 20 00#             .asciiz "unknown symbol "
0x8a74:                               # completed_assembly_msg:
0x8a74: 61 73 73 65 6d 62 6c 79 20 63 6f 6d 70 6c 65 74 65 21 0a 00#             .asciiz "assembly complete!\n"
0x8a88:                               # exit_with_status_msg:
0x8a88: 70 72 6f 67 72 61 6d 20 65 78 69 74 65 64 20 77 69 74 68 20 73 74 61 74 75 73 20 00#             .asciiz "program exited with status "
0x8aa4:                               # id_str:
0x8aa4: 69 64 00                      #             .asciiz "id"
0x8aa7:                               # at_str:
0x8aa7: 61 74 00                      #             .asciiz "at"
0x8aaa:                               # opcode_table2:
0x8aaa: 04                            #             .half   4
0x8aab:                               # opcode_tables:                  ; pointer directly to 'name'
0x8aab: 6f 72                         #             .ascii  "or"
0x8aad: 0a                            #             .half   10
0x8aae: 6c 64                         #             .ascii  "ld"
0x8ab0: 0b                            #             .half   11
0x8ab1: 73 74                         #             .ascii  "st"
0x8ab3:                               # opcode_table3short:
0x8ab3: 00                            #             .half   0
0x8ab4: 61 64 64                      #             .ascii  "add"
0x8ab7: 01                            #             .half   1
0x8ab8: 73 75 62                      #             .ascii  "sub"
0x8abb: 03                            #             .half   3
0x8abc: 63 6d 70                      #             .ascii  "cmp"
0x8abf: 05                            #             .half   5
0x8ac0: 78 6f 72                      #             .ascii  "xor"
0x8ac3: 06                            #             .half   6
0x8ac4: 61 6e 64                      #             .ascii  "and"
0x8ac7: 0c                            #             .half   12
0x8ac8: 73 6c 6f                      #             .ascii  "slo"
0x8acb:                               # opcode_table3:
0x8acb: 09 07 02                      #             .half   9   7   2
0x8ace: 6d 6f 76                      #             .ascii  "mov"
0x8ad1: 0c 04 03                      #             .half   12  4   3
0x8ad4: 70 6f 70                      #             .ascii  "pop"
0x8ad7: 0e 0b 03                      #             .half   14  11  3
0x8ada: 68 6c 74                      #             .ascii  "hlt"
0x8add: 0f 0b 03                      #             .half   15  11  3
0x8ae0: 6e 6f 70                      #             .ascii  "nop"
0x8ae3: 10 0b 01                      #             .half   16  11  1
0x8ae6: 72 65 74                      #             .ascii  "ret"
0x8ae9:                               # opcode_table4:
0x8ae9: 02                            #             .half   2   
0x8aea:                               # opcode_table4_state:
0x8aea: 05 03                         #             .half   5   3
0x8aec: 72 73 75 62                   #             .ascii  "rsub"
0x8af0: 07 05 03                      #             .half   7   5   3
0x8af3: 74 65 73 74                   #             .ascii  "test"
0x8af7: 08 05 03                      #             .half   8   5   3
0x8afa: 6d 6f 76 7a                   #             .ascii  "movz"
0x8afe: 09 05 03                      #             .half   9   5   3
0x8b01: 6d 6f 76 73                   #             .ascii  "movs"
0x8b05: 0d 02 03                      #             .half   13  2   3
0x8b08: 70 75 73 68                   #             .ascii  "push"
0x8b0c: 10 03 01                      #             .half   16  3   1
0x8b0f: 63 61 6c 6c                   #             .ascii  "call"
0x8b13:                               # cond_table:
0x8b13: 0e                            #             .half   14
0x8b14:                               # cond_table_name:
0x8b14: 6d 70 00                      #             .asciiz "mp"
0x8b17: 00                            #             .half   0
0x8b18: 7a 00 00                      #             .asciiz "z\0"
0x8b1b: 00                            #             .half   0
0x8b1c: 65 00 00                      #             .asciiz "e\0"
0x8b1f: 01                            #             .half   1
0x8b20: 6e 7a 00                      #             .asciiz "nz"
0x8b23: 01                            #             .half   1
0x8b24: 6e 65 00                      #             .asciiz "ne"
0x8b27: 02                            #             .half   2
0x8b28: 6e 00 00                      #             .asciiz "n\0"
0x8b2b: 03                            #             .half   3
0x8b2c: 6e 6e 00                      #             .asciiz "nn"
0x8b2f: 04                            #             .half   4
0x8b30: 63 00 00                      #             .asciiz "c\0"
0x8b33: 04                            #             .half   4
0x8b34: 62 00 00                      #             .asciiz "b\0"
0x8b37: 05                            #             .half   5
0x8b38: 6e 63 00                      #             .asciiz "nc"
0x8b3b: 05                            #             .half   5
0x8b3c: 61 65 00                      #             .asciiz "ae"
0x8b3f: 06                            #             .half   6
0x8b40: 6f 00 00                      #             .asciiz "o\0"
0x8b43: 07                            #             .half   7
0x8b44: 6e 6f 00                      #             .asciiz "no"
0x8b47: 08                            #             .half   8
0x8b48: 62 65 00                      #             .asciiz "be"
0x8b4b: 09                            #             .half   9
0x8b4c: 61 00 00                      #             .asciiz "a\0"
0x8b4f: 0a                            #             .half   10
0x8b50: 6c 00 00                      #             .asciiz "l\0"
0x8b53: 0b                            #             .half   11
0x8b54: 67 65 00                      #             .asciiz "ge"
0x8b57: 0c                            #             .half   12
0x8b58: 6c 65 00                      #             .asciiz "le"
0x8b5b: 0d                            #             .half   13
0x8b5c: 67 00 00                      #             .asciiz "g\0"
0x8b5f: 0e                            #             .half   14
0x8b60: 00 00 00                      #             .asciiz "\0\0"
